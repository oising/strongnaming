<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.PowerShell.Commands.Utility</name>
    </assembly>
    <members>
        <member name="T:Microsoft.PowerShell.Commands.NewObjectCommand">
            <summary>Create a new .net object</summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewObjectCommand.TypeName">
            <summary> the number</summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewObjectCommand.ComObject">
            <summary> the ProgID of the Com object</summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewObjectCommand.ArgumentList">
            <summary>
            The parameters for the constructor
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewObjectCommand.Strict">
            <summary>
            True if we should have an error when Com objects will use an interop assembly
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewObjectCommand.Property">
            <summary>
            gets the properties to be set.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.NewObjectCommand.BeginProcessing">
            <summary> Create the object </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.NewObjectNativeMethods">
            <summary>
            Native methods for dealing with COM objects
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.NewObjectNativeMethods.CLSIDFromProgID(System.String,System.Guid@)">
            Return Type: HRESULT->LONG->int
        </member>
        <member name="T:Microsoft.PowerShell.Commands.MeasureInfo">
            <summary>
            Class output by Measure-Object
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MeasureInfo.Property">
            <summary>
            
            property name
            
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GenericMeasureInfo">
            <summary>
            Class output by Measure-Object
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GenericMeasureInfo.#ctor">
            <summary>
            default ctor
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GenericMeasureInfo.Count">
            <summary>
            
            Keeping track of number of objects with a certain property
            
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GenericMeasureInfo.Average">
            <summary>
            
            The average of property values
            
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GenericMeasureInfo.Sum">
            <summary>
            
            The sum of property values
            
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GenericMeasureInfo.Maximum">
            <summary>
            
            The max of property values
            
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GenericMeasureInfo.Minimum">
            <summary>
            
            The min of property values
            
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GenericObjectMeasureInfo">
            <summary>
            Class output by Measure-Object. 
            </summary>
            <remarks>
            This class is created for fixing "Measure-Object -MAX -MIN  should work with ANYTHING that supports CompareTo"
            bug (Win8:343911).  
            GenericMeasureInfo class is shipped with PowerShell V2. Fixing this bug requires, changing the type of
            Maximum and Minimum properties which would be a breaking change. Hence created a new class to not
            have an appcompat issues with PS V2.
            </remarks>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GenericObjectMeasureInfo.#ctor">
            <summary>
            default ctor
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GenericObjectMeasureInfo.Count">
            <summary>
            
            Keeping track of number of objects with a certain property
            
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GenericObjectMeasureInfo.Average">
            <summary>
            
            The average of property values
            
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GenericObjectMeasureInfo.Sum">
            <summary>
            
            The sum of property values
            
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GenericObjectMeasureInfo.Maximum">
            <summary>
            
            The max of property values
            
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GenericObjectMeasureInfo.Minimum">
            <summary>
            
            The min of property values
            
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.TextMeasureInfo">
            <summary>
            Class output by Measure-Object
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.TextMeasureInfo.#ctor">
            <summary>
            default ctor
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TextMeasureInfo.Lines">
            <summary>
            
            Keeping track of number of objects with a certain property
            
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TextMeasureInfo.Words">
            <summary>
            
            The average of property values
            
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TextMeasureInfo.Characters">
            <summary>
            
            The sum of property values
            
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.MeasureObjectCommand">
            <summary>
            measure object cmdlet
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.MeasureObjectCommand.MeasureObjectDictionary`1">
            <summary>
            Dictionary to be used by Measure-Object implementation
            Keys are strings. Keys are compared with OrdinalIgnoreCase.
            </summary>
            <typeparam name="V">Value type.</typeparam>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.MeasureObjectCommand.MeasureObjectDictionary`1.#ctor">
            <summary>
            default ctor
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.MeasureObjectCommand.MeasureObjectDictionary`1.EnsureEntry(System.String)">
            <summary>
            Attempt to look up the value associated with the
            the specified key. If a value is not found, associate
            the key with a new value created via the value type's
            default constructor.
            </summary>
            <param name="key">The key to look up</param>
            <returns>
            The existing value, or a newly-created value.
            </returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.MeasureObjectCommand.Statistics">
            <summary>
            Convenience class to track statistics without having
            to maintain two sets of MeasureInfo and constantly checking
            what mode we're in.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.MeasureObjectCommand.#ctor">
            <summary>
            default constructor
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MeasureObjectCommand.InputObject">
            <summary>
            incoming object
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MeasureObjectCommand.Property">
            <summary>
            Properties to be examined
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MeasureObjectCommand.Sum">
            <summary>
            Set to true is Sum is to be returned
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MeasureObjectCommand.Average">
            <summary>
            Set to true is Average is to be returned
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MeasureObjectCommand.Maximum">
            <summary>
            Set to true is Max is to be returned
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MeasureObjectCommand.Minimum">
            <summary>
            Set to true is Min is to be returned
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MeasureObjectCommand.Line">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MeasureObjectCommand.Word">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MeasureObjectCommand.Character">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MeasureObjectCommand.IgnoreWhiteSpace">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MeasureObjectCommand.IsMeasuringGeneric">
            <summary>
            Which parameter set the Cmdlet is in.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.MeasureObjectCommand.ProcessRecord">
            <summary>
            Collect data about each record that comes in. 
            Side effects: Updates totalRecordCount.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.MeasureObjectCommand.AnalyzeObjectProperties(System.Management.Automation.PSObject)">
            <summary>
            Analyze an object on a property-by-property basis instead
            of as a simple value.
            Side effects: Updates statistics.
            <param name="inObj">The object to analyze.</param>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.MeasureObjectCommand.AnalyzeValue(System.String,System.Object)">
            <summary>
            Analyze a value for generic/text statistics.
            Side effects: Updates statistics. May set nonNumericError.
            <param name="propertyName">The property this value corresponds to.</param>
            <param name="objValue">The value to analyze.</param>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.MeasureObjectCommand.Compare(System.Object,System.Object,System.Boolean)">
            <summary>
            Compare is a helper function used to find the min/max between the supplied input values.
            </summary>
            <param name="objValue">
            Current input value.
            </param>
            <param name="statMinOrMaxValue">
            Current minimum or maximum value in the statistics.
            </param>
            <param name="isMin">
            Indicates if minimum or maximum value has to be found. 
            If true is passed in then the minimum of the two values would be returned.
            If false is passed in then maximum of the two values will be returned.</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.MeasureObjectCommand.TextCountUtilities">
            <summary>
            Class contains util static functions
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.MeasureObjectCommand.TextCountUtilities.CountChar(System.String,System.Boolean)">
            <summary>
            count chars in inStr
            </summary>
            <param name="inStr">string whose chars are counted</param>
            <param name="ignoreWhiteSpace">true to discount white space</param>
            <returns>number of chars in inStr</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.MeasureObjectCommand.TextCountUtilities.CountWord(System.String)">
            <summary>
            count words in inStr
            </summary>
            <param name="inStr">string whose words are counted</param>
            <returns>number of words in inStr</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.MeasureObjectCommand.TextCountUtilities.CountLine(System.String)">
            <summary>
            count lines in inStr
            </summary>
            <param name="inStr">string whose lines are counted</param>
            <returns>number of lines in inStr</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.MeasureObjectCommand.AnalyzeString(System.String,Microsoft.PowerShell.Commands.MeasureObjectCommand.Statistics)">
            <summary>
            Update text statistics.
            <param name="strValue">The text to analyze.</param>
            <param name="stat">The Statistics object to update.</param>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.MeasureObjectCommand.AnalyzeNumber(System.Double,Microsoft.PowerShell.Commands.MeasureObjectCommand.Statistics)">
            <summary>
            Update number statistics.
            <param name="numValue">The number to analyze.</param>
            <param name="stat">The Statistics object to update.</param>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.MeasureObjectCommand.WritePropertyNotFoundError(System.String,System.String)">
            <summary>
            WriteError when a property is not found
            </summary>
            <param name="propertyName">The missing property.</param>
            <param name="errorId">The error ID to write.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.MeasureObjectCommand.EndProcessing">
            <summary>
            Output collected statistics.
            Side effects: Updates statistics. Writes objects to stream.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.MeasureObjectCommand.CreateGenericMeasureInfo(Microsoft.PowerShell.Commands.MeasureObjectCommand.Statistics,System.Boolean)">
            <summary>
            Create a MeasureInfo object for generic stats.
            <param name="stat">The statistics to use.</param>
            <returns>A new GenericMeasureInfo object.</returns>
            </summary>
            <param name="shouldUseGenericMeasureInfo"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.MeasureObjectCommand.CreateTextMeasureInfo(Microsoft.PowerShell.Commands.MeasureObjectCommand.Statistics)">
            <summary>
            Create a MeasureInfo object for text stats.
            <param name="stat">The statistics to use.</param>
            <returns>A new TextMeasureInfo object.</returns>
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.MeasureObjectCommand.statistics">
            <summary>
            The observed statistics keyed by property name. If
            Property is not set, then the key used will be the
            value of thisObject.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.MeasureObjectCommand.nonNumericError">
            <summary>
            Whether or not a numeric conversion error occurred.
            If true, then average/sum will not be output.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.MeasureObjectCommand.totalRecordCount">
            <summary>
            The total number of records encountered.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.MeasureObjectCommand.GenericParameterSet">
            <summary>
            Parameter set name for measuring objects.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.MeasureObjectCommand.TextParameterSet">
            <summary>
            Parameter set name for measuring text.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.MeasureObjectCommand.thisObject">
            <summary>
            Key that statistics are stored under when Property is not set.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.MshExpressionFilter">
            <summary>
            helper class to do wildcard matching on MshExpressions
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.MshExpressionFilter.#ctor(System.String[])">
            <summary>
            construnt the class, using an array of patterns
            </summary>
            <param name="wildcardPatternsStrings">array of pattern strings to use</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.MshExpressionFilter.IsMatch(Microsoft.PowerShell.Commands.Internal.Format.MshExpression)">
            <summary>
            try to match the expression against the array of wildcard patterns.
            the first match shortcircuits the search
            </summary>
            <param name="expression">MshExpression to test against</param>
            <returns>true if there is a match, else false</returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SelectObjectCommand">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SelectObjectCommand.InputObject">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SelectObjectCommand.Property">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SelectObjectCommand.ExcludeProperty">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SelectObjectCommand.ExpandProperty">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SelectObjectCommand.Unique">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SelectObjectCommand.Last">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SelectObjectCommand.First">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SelectObjectCommand.Skip">
            <summary>
            Skips the sepecified number of items from top when used with First,from end when used with Last
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SelectObjectCommand.SkipLast">
            <summary>
            Skip the specified number of items from end.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SelectObjectCommand.Wait">
            <summary>
            With this switch present, the cmdlet won't "short-circuit" 
            (i.e. won't stop upstream cmdlets after it knows that no further objects will be emitted downstream)
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SelectObjectCommand.Index">
            <summary>
            Used to display the object at specified index
            </summary>
            <value></value>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SelectObjectCommand.propertyMshParameterList">
            <summary>
            list of processed parameters obtained from the Expression array
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SelectObjectCommand.expandMshParameterList">
            <summary>
            singleton list of process parameters obtained from ExpandProperty
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SelectObjectCommand.BeginProcessing">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SelectObjectCommand.ProcessRecord">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SelectObjectCommand.EndProcessing">
            <summary>
            
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SelectObjectException">
            <summary>
            Used only internally for select-object
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SortObjectCommand">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SortObjectCommand.Descending">
            <summary>
            This param specifies if sort order is ascending. 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SortObjectCommand.Unique">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SortObjectCommand.RemoveDuplicates(Microsoft.PowerShell.Commands.OrderByProperty)">
            <summary>
            Remove Duplicated from <paramref name="sortedList"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SortObjectCommand.EndProcessing">
            <summary>
            
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ObjectCommandPropertyValue">
            <summary>
            Keeps the property value of inputObject. Because the value of a non-existing property is null,
             isExistingProperty is needed to distinguish whether a property exists and its value is null or
             the property does not exist at all.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ObjectCommandPropertyValue.#ctor(System.Object,System.Boolean,System.Globalization.CultureInfo)">
            <summary>
            ObjectCommandPropertyValue constructor.
            </summary>
            <param name="propVal">Property Value.</param>
            <param name="isCaseSensitive">Indicates if the Property value comparison has to be case sensitive or not.</param>
            <param name="cultureInfo">Culture Info of the Property Value.</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ObjectCommandPropertyValue.CaseSensitive">
            <summary>
            Indicates if the Property Value comparion has to be Case sensitive or not.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ObjectCommandPropertyValue.Culture">
            <summary>
            Gets the Culture Info of the Property Value.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ObjectCommandPropertyValue.Equals(System.Object)">
            <summary>
            Provides an Equals implementation.
            </summary>
            <param name="inputObject">Input Object.</param>
            <returns>True if both the objects are same or else returns false.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ObjectCommandPropertyValue.GetHashCode">
            <summary>
            Provides a GetHashCode() implementation.
            </summary>
            <returns>Hashcode in the form of an integer.</returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ObjectCommandComparer">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ObjectCommandComparer.#ctor(System.Boolean,System.Globalization.CultureInfo,System.Boolean)">
            <summary>
            Constructor that doesn't set any private field.
            Necessary because compareTo can compare two objects by calling
            ((ICompare)obj1).CompareTo(obj2) without using a key.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ObjectCommandComparer.Compare(System.Object,System.Object)">
             <summary>
             Main method that will compare first and second by
             their keys considering case and order
             </summary>
             <param name="first">
             first object to extract value
             </param>
             <param name="second">
             second object to extract value
             </param>
             <returns> 
             0 if they are the same, less than 0 if first is smaller, more than 0 if first is greater
            </returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SortObjectParameterDefinitionKeys">
            <summary>
            definitions for hash table keys
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SortObjectExpressionParameterDefinition">
            <summary>
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GroupObjectExpressionParameterDefinition">
            <summary>
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ObjectCmdletBase">
            <summary>
            Base Cmdlet for cmdlets which deal with raw objects
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ObjectCmdletBase.Culture">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ObjectCmdletBase.CaseSensitive">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ObjectBase">
            <summary>
            Base Cmdlet for object cmdlets that deal with Grouping, Sorting and Comparison.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ObjectBase.InputObject">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ObjectBase.Property">
            <summary>
            Gets or Sets the Properties that would be used for Grouping, Sorting and Comparison.
            </summary>
            <value></value>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.OrderObjectBase">
            <summary>
            Base Cmdlet for object cmdlets that deal with Ordering and Camparison.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.OrderObjectBase.DescendingOrder">
            <summary>
            Specifies sorting order. 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.OrderObjectBase.ConvertedCulture">
            <summary>
            CultureInfo converted from the Culture Cmdlet parameter
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.OrderObjectBase.ProcessRecord">
            <summary>
            
            Simply accumulates the incoming objects
            
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OrderObjectBase.inputObjects">
            <summary>
            list of incoming objects to compare
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.OrderByProperty.#ctor">
            <summary>
            OrderByProperty constructor.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.OrderByProperty.CreateOrderByPropertyEntry(System.Management.Automation.PSCmdlet,System.Management.Automation.PSObject,System.Boolean,System.Globalization.CultureInfo)">
            <summary>
            Utility function used to create OrderByPropertyEntry for the supplied input object.
            </summary>
            <param name="cmdlet">PSCmdlet</param>
            <param name="inputObject">Input Object.</param>
            <param name="isCaseSensitive">Indicates if the Property value comparisons need to be case sensitive or not.</param>
            <param name="cultureInfo">Culture Info that needs to be used for comparison.</param>
            <returns>OrderByPropertyEntry for the supplied InputObject.</returns>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OrderByProperty.comparer">
            <summary>
            comparer for orderMatrix
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OrderByProperty.orderMatrix">
            <summary>
            a logical matrix where each row is an input object and its property values specified by Properties
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.OrderByPropertyEntry">
            <summary>
            This is the row of the OrderMatrix
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.WriteDebugCommand">
            <summary>
            This class implements Write-Debug command
            
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteDebugCommand.Message">
            <summary>
            Message to be sent and processed if debug mode is on.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WriteDebugCommand.ProcessRecord">
            <summary>
            This method implements the ProcessRecord method for Write-Debug command
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.WriteVerboseCommand">
            <summary>
            This class implements Write-Verbose command
            
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteVerboseCommand.Message">
            <summary>
            Message to be sent if verbose messages are being shown.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WriteVerboseCommand.ProcessRecord">
            <summary>
            This method implements the ProcessRecord method for Write-verbose command
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.WriteWarningCommand">
            <summary>
            This class implements Write-Warning command
            
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteWarningCommand.Message">
            <summary>
            Message to be sent if warning messages are being shown.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WriteWarningCommand.ProcessRecord">
            <summary>
            This method implements the ProcessRecord method for Write-Warning command
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.WriteInformationCommand">
            <summary>
            This class implements Write-Information command
            
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteInformationCommand.MessageData">
            <summary>
            Object to be sent to the Information stream.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteInformationCommand.Tags">
            <summary>
            Any tags to be associated with this information
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WriteInformationCommand.BeginProcessing">
            <summary>
            This method implements the processing of the Write-Information command
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.WriteOrThrowErrorCommand">
            <summary>
            This class implements the Write-Error command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteOrThrowErrorCommand.Exception">
            <summary>
            ErrorRecord.Exception -- if not specified, ErrorRecord.Exception is
            System.Exception.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteOrThrowErrorCommand.Message">
            <summary>
            If Exception is specified, this is ErrorRecord.ErrorDetails.Message.
            Otherwise, the Exception is System.Exception, and this is
            Exception.Message.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteOrThrowErrorCommand.ErrorRecord">
            <summary>
            If Exception is specified, this is ErrorRecord.ErrorDetails.Message.
            Otherwise, the Exception is System.Exception, and this is
            Exception.Message.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteOrThrowErrorCommand.Category">
            <summary>
            ErrorRecord.CategoryInfo.Category
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteOrThrowErrorCommand.ErrorId">
            <summary>
            ErrorRecord.ErrorId
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteOrThrowErrorCommand.TargetObject">
            <summary>
            ErrorRecord.TargetObject
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteOrThrowErrorCommand.RecommendedAction">
            <summary>
            ErrorRecord.ErrorDetails.RecommendedAction
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteOrThrowErrorCommand.CategoryActivity">
            <summary>
            ErrorRecord.CategoryInfo.Activity
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteOrThrowErrorCommand.CategoryReason">
            <summary>
            ErrorRecord.CategoryInfo.Reason
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteOrThrowErrorCommand.CategoryTargetName">
            <summary>
            ErrorRecord.CategoryInfo.TargetName
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteOrThrowErrorCommand.CategoryTargetType">
            <summary>
            ErrorRecord.CategoryInfo.TargetType
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WriteOrThrowErrorCommand.ProcessRecord">
            <summary>
            Write an error to the output pipe, or throw a terminating error.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.WriteErrorCommand">
            <summary>
            This class implements Write-Error command
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WriteErrorCommand.#ctor">
            <summary>
            constructor
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.WriteErrorException">
            <summary>
            The write-error cmdlet uses WriteErrorException
            when the user only specifies a string and not
            an Exception or ErrorRecord.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WriteErrorException.#ctor">
            <summary>
            Constructor for class WriteErrorException
            </summary>
            <returns> constructed object </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WriteErrorException.#ctor(System.String)">
            <summary>
            Constructor for class WriteErrorException
            </summary>
            <param name="message">  </param>
            <returns> constructed object </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WriteErrorException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor for class WriteErrorException
            </summary>
            <param name="message">  </param>
            <param name="innerException">  </param>
            <returns> constructed object </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WriteErrorException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialization constructor for class WriteErrorException
            </summary>
            <param name="info"> serialization information </param>
            <param name="context"> streaming context </param>
            <returns> constructed object </returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.VariableCommandBase">
            <summary>
            Base class for all variable commands.
            
            Because -Scope is defined in VariableCommandBase, all derived commands
            must implement -Scope.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.VariableCommandBase.Scope">
            <summary>
            Selects active scope to work with; used for all variable commands.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.VariableCommandBase.IncludeFilters">
            <summary>
            The Include parameter for all the variable commands
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.VariableCommandBase.ExcludeFilters">
            <summary>
            The Exclude parameter for all the variable commands
            </summary>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.VariableCommandBase.GetMatchingVariables(System.String,System.String,System.Boolean@,System.Boolean)">
            <summary>
            Gets the matching variable for the specified name, using the
            Include, Exclude, and Scope parameters defined in the base class.
            </summary>
            
            <param name="name">
            The name or pattern of the variables to retrieve.
            </param>
            
            <param name="lookupScope">
            The scope to do the lookup in. If null or empty the normal scoping
            rules apply.
            </param>
            
            <param name="wasFiltered">
            True is returned if a variable exists of the given name but was filtered
            out via globbing, include, or exclude.
            </param>
            
            <param name="quiet">
            If true, don't report errors when trying to access private variables.
            </param>
            
            <returns>
            A collection of the variables matching the name, include, and exclude
            pattern in the specified scope.
            </returns>
            
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GetVariableCommand">
            <summary>
            Implements get-variable command.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetVariableCommand.Name">
            <summary>
            Name of the PSVariable
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetVariableCommand.ValueOnly">
            <summary>
            Output only the value(s) of the requested variable(s).
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetVariableCommand.Include">
            <summary>
            The Include parameter for all the variable commands
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetVariableCommand.Exclude">
            <summary>
            The Exclude parameter for all the variable commands
            </summary>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetVariableCommand.ProcessRecord">
            <summary>
            Implements ProcessRecord() method for get-variabit's le command.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.NewVariableCommand">
            <summary>
            Class implementing new-variable command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewVariableCommand.Name">
            <summary>
            Name of the PSVariable
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewVariableCommand.Value">
            <summary>
            Value of the PSVariable
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewVariableCommand.Description">
            <summary>
            Description of the variable
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewVariableCommand.Option">
            <summary>
            The options for the variable to specify if the variable should
            be ReadOnly, Constant, and/or Private.
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewVariableCommand.Visibility">
            <summary>
            Specifies the visiblity of the new variable...
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewVariableCommand.Force">
            <summary>
            Force the operation to make the best attempt at setting the variable.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewVariableCommand.PassThru">
            <summary>
            The variable object should be passed down the pipeline.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.NewVariableCommand.ProcessRecord">
            <summary>
            Add objects received on the pipeline to an ArrayList of values, to
            take the place of the Value parameter if none was specified on the
            command line. 
            </summary>
            
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SetVariableCommand">
            <summary>
            This class implements set-variable command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetVariableCommand.Name">
            <summary>
            Name of the PSVariable(s) to set
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetVariableCommand.Value">
            <summary>
            Value of the PSVariable
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetVariableCommand.Include">
            <summary>
            The Include parameter for all the variable commands
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetVariableCommand.Exclude">
            <summary>
            The Exclude parameter for all the variable commands
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetVariableCommand.Description">
            <summary>
            Description of the variable
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetVariableCommand.Option">
            <summary>
            The options for the variable to specify if the variable should
            be ReadOnly, Constant, and/or Private.
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetVariableCommand.Force">
            <summary>
            Force the operation to make the best attempt at setting the variable.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetVariableCommand.Visibility">
            <summary>
            Sets the visibility of the variable...
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetVariableCommand.PassThru">
            <summary>
            The variable object should be passed down the pipeline.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SetVariableCommand.BeginProcessing">
            <summary>
            Checks to see if the name and value parameters were
            bound as formal parameters.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SetVariableCommand.ProcessRecord">
            <summary>
            If name and value are both specified as a formal parameters, then
            just ignore the incoming objects in ProcessRecord.
            If name is a formal parameter but the value is coming from the pipeline,
            then accumulate the values in the valueList and set the variable during
            EndProcessing().
            If name is not a formal parameter, then set
            the variable each time ProcessRecord is called.
            </summary>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SetVariableCommand.EndProcessing">
            <summary>
            Sets the variable if the name was specified as a formal parameter
            but the value came from the pipeline.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SetVariableCommand.SetVariable(System.String[],System.Object)">
            <summary>
            Sets the variables of the given names to the specified value.
            </summary>
            
            <param name="varNames">
            The name(s) of the variables to set.
            </param>
            
            <param name="varValue">
            The value to set the variable to.
            </param>
            
        </member>
        <member name="T:Microsoft.PowerShell.Commands.RemoveVariableCommand">
            <summary>
            The Remove-Variable cmdlet implementation
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemoveVariableCommand.Name">
            <summary>
            Name of the PSVariable(s) to set
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemoveVariableCommand.Include">
            <summary>
            The Include parameter for all the variable commands
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemoveVariableCommand.Exclude">
            <summary>
            The Exclude parameter for all the variable commands
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemoveVariableCommand.Force">
            <summary>
            If true, the variable is removed even if it is ReadOnly
            </summary>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RemoveVariableCommand.ProcessRecord">
            <summary>
            Removes the matching variables from the specified scope
            </summary>
            
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ClearVariableCommand">
            <summary>
            This class implements set-variable command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ClearVariableCommand.Name">
            <summary>
            Name of the PSVariable(s) to set
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ClearVariableCommand.Include">
            <summary>
            The Include parameter for all the variable commands
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ClearVariableCommand.Exclude">
            <summary>
            The Exclude parameter for all the variable commands
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ClearVariableCommand.Force">
            <summary>
            Force the operation to make the best attempt at clearing the variable.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ClearVariableCommand.PassThru">
            <summary>
            The variable object should be passed down the pipeline.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ClearVariableCommand.ProcessRecord">
            <summary>
            The implementation of the Clear-Variable command
            </summary>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ClearVariableCommand.ClearValue(System.Management.Automation.PSVariable)">
            <summary>
            Clears the value of the variable using the PSVariable instance if the scope
            was specified or using standard variable lookup if the scope was not specified.
            </summary>
            
            <param name="matchingVariable">
            The variable that matched the name parameter(s).
            </param>
            
        </member>
        <member name="T:Microsoft.PowerShell.Commands.MemberDefinition">
            <summary>
            Class with member information that this cmdlet writes to the pipeline
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.MemberDefinition.ToString">
            <summary>
            returns the member definition
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.MemberDefinition.#ctor(System.String,System.String,System.Management.Automation.PSMemberTypes,System.String)">
            <summary>
            Initializes a new instance of this class
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MemberDefinition.TypeName">
            <summary>
            type name
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MemberDefinition.Name">
            <summary>
            member name
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MemberDefinition.MemberType">
            <summary>
            member type
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MemberDefinition.Definition">
            <summary>
            member definition
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GetMemberCommand">
            <summary>
            This class implements get-member command.  
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetMemberCommand.InputObject">
            <summary>
            The object to retrieve properties from
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetMemberCommand.Name">
            <summary>
            The member names to be retrieved
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetMemberCommand.MemberType">
            <summary>
            The member types to be retrieved
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetMemberCommand.View">
            <summary>
            View from which the members are retrieved.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetMemberCommand.Static">
            <summary>
            True if we should return static members
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetMemberCommand.Force">
            <summary>
            Gets or sets the force property
            </summary>
            <remarks>
            Gives the Member matcher guidance on how vigorous the Match should be.
            If set to true all members in a given view + membertype are displayed.
            This parameter is added to hide Get/Set property accessor methods by
            default. If a user wants to see these methods, -force should be set to
            true.
            </remarks>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetMemberCommand.ProcessRecord">
            <summary>
            This method implements the ProcessRecord method for get-member command
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetMemberCommand.EndProcessing">
            <summary>
            This method implements the End method for get-member  command
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.PSTuple">
            <summary>
            PSTuple is a helper class used to create Tuple from an input array.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PSTuple.ArrayToTuple(System.Object[])">
            <summary>
            ArrayToTuple is a helper method used to create a tuple for the supplied input array.
            </summary>
            <param name="inputObjects">Input objects used to create a tuple.</param>
            <returns>Tuple object.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PSTuple.ArrayToTuple(System.Object[],System.Int32)">
            <summary>
            ArrayToTuple is a helper method used to create a tuple for the supplied input array.
            </summary>
            <param name="inputObjects">Input objects used to create a tuple</param>
            <param name="startIndex">Start index of the array from which the objects have to considered for the tuple creation.</param>
            <returns>Tuple object.</returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GroupInfoNoElement">
            <summary>
            Emitted by Group-Object when the NoElement option is true
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GroupInfo">
            <summary>
            Emitted by Group-Object
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GroupInfo.Values">
             <summary>
             
             Values of the group
            
             </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GroupInfo.Count">
             <summary>
            
             Number of objects in the group
            
             </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GroupInfo.Group">
             <summary>
            
             The list of objects in this group
            
             </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GroupInfo.Name">
             <summary>
            
             The name of the group
            
             </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GroupInfo.GroupValue">
             <summary>
            
             The OrderByPropertyEntry used to build this group object
            
             </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GroupObjectCommand">
             <summary>
            
             Group-Object implementation
            
             </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.GroupObjectCommand.tracer">
            <summary>
            An instance of the PSTraceSource class used for trace output
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GroupObjectCommand.NoElement">
            <summary>
            
            Flatten the groups
            
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GroupObjectCommand.AsHashTable">
            <summary>
            the Ashashtable parameter
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GroupObjectCommand.AsString">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GroupObjectCommand.DoGrouping(Microsoft.PowerShell.Commands.OrderByPropertyEntry,System.Boolean,System.Collections.Generic.List{Microsoft.PowerShell.Commands.GroupInfo},System.Collections.Generic.Dictionary{System.Object,Microsoft.PowerShell.Commands.GroupInfo},Microsoft.PowerShell.Commands.OrderByPropertyComparer)">
            <summary>
            Utility function called by Group-Object to create Groups.
            </summary>
            <param name="currentObjectEntry">Input object that needs to be grouped.</param>
            <param name="noElement">true if we are not acumulating objects</param>
            <param name="groups">List containing Groups.</param>
            <param name="groupInfoDictionary">Dictionary used to keep track of the groups with hash of the property values being the key.</param>
            <param name="orderByPropertyComparer">The Comparer to be used while comparing to check if new group has to be created.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GroupObjectCommand.ProcessRecord">
            <summary>
            Process every input object to group them.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GroupObjectCommand.EndProcessing">
            <summary>
            
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.WriteHostCommand">
             <summary>
            
             Class comment
            
             </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteHostCommand.Object">
             <summary>
            
             Object to be output.
            
             </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteHostCommand.NoNewline">
             <summary>
            
             False to add a newline to the end of the output string, true if not.
            
             </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteHostCommand.Separator">
            <summary>
            
            The separator to print between objects
            
            </summary>
            <value></value>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WriteHostCommand.ProcessRecord">
             <summary>
            
             Outputs the object to the host console, with optional newline
            
             </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ConsoleColorCmdlet">
            <summary>
            
            Base class for a variety of commandlets that take color parameters
            
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConsoleColorCmdlet.#ctor">
            <summary>
            Default ctor
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ConsoleColorCmdlet.ForegroundColor">
            <summary>
            
            The -ForegroundColor parameter
            
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ConsoleColorCmdlet.BackgroundColor">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.AddMemberCommand">
            <summary>
            This class implements get-member command.  
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddMemberCommand.InputObject">
            <summary>
            The object to add a member to
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddMemberCommand.MemberType">
            <summary>
            The member type of to be added
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddMemberCommand.Name">
            <summary>
            The name of the new member
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddMemberCommand.Value">
            <summary>
            First value of the new member. The meaning of this value
            changes according to the member type.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddMemberCommand.SecondValue">
            <summary>
            Second value of the new member. The meaning of this value
            changes according to the member type.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddMemberCommand.TypeName">
            <summary>
            Add new type name to the specified object for TypeNameSet
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddMemberCommand.Force">
            <summary>
            True if we should overwrite a possibly existing member
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddMemberCommand.PassThru">
            <summary>
            Gets or sets the parameter -passThru which states output from
            the command should be placed in the pipeline.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddMemberCommand.NotePropertyName">
            <summary>
            The name of the new NoteProperty member
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddMemberCommand.NotePropertyValue">
            <summary>
            The value of the new NoteProperty member
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddMemberCommand.NotePropertyMembers">
            <summary>
            The NoteProperty members to be set
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.AddMemberCommand.ProcessRecord">
            <summary>
            This method implements the ProcessRecord method for add-member command
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.AddMemberCommand.AddMemberToTarget(System.Management.Automation.PSMemberInfo)">
            <summary>
            Add the member to the target object
            </summary>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.AddMemberCommand.ProcessNotePropertyMultiMemberSet">
            <summary>
            Process the 'NotePropertyMultiMemberSet' parameter set
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.AddMemberCommand.ValidateNotePropertyNameAttribute">
            <summary>
            This ValidateArgumentsAttribute is used to guarantee the argument to be bound to
            -NotePropertyName parameter cannot be converted to the enum type PSMemberTypes.
            So when given a string or a number that can be converted, we make sure it gets 
            bound to -MemberType, instead of -NotePropertyName.
            </summary>
            
            <remarks>
            This exception will be hidden in the positional binding phase. So we make sure
            if the argument can be converted to PSMemberTypes, it gets bound to the -MemberType
            parameter. We are sure that when this exception is thrown, the current positional
            argument can be successfully bound to 
            </remarks>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.AddMemberCommand.NotePropertyTransformationAttribute">
            <summary>
            Transform the integer arguments to strings for the parameter NotePropertyName
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.Language">
            <summary>
            Languages supported for code generation
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.Language.CSharp">
            <summary>
            The C# programming language: latest version.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.Language.CSharpVersion3">
            <summary>
            The C# programming language v3 (for Linq, etc)
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.Language.CSharpVersion2">
            <summary>
            The C# programming language v2 
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.Language.VisualBasic">
            <summary>
            The Visual Basic programming language
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.Language.JScript">
            <summary>
            The Managed JScript programming language
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.OutputAssemblyType">
            <summary>
            Types supported for the OutputAssembly parameter
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OutputAssemblyType.Library">
            <summary>
            A Dynamically linked library (DLL)
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OutputAssemblyType.ConsoleApplication">
            <summary>
            An executable application that targets the console subsystem
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OutputAssemblyType.WindowsApplication">
            <summary>
            An executable application that targets the graphical subsystem
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.AddTypeCompilerError">
            <summary>
            Compile error or warning.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddTypeCompilerError.FileName">
            <summary>
            FileName, if compiled from paths.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddTypeCompilerError.Line">
            <summary>
            Line number.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddTypeCompilerError.Column">
            <summary>
            Column number.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddTypeCompilerError.ErrorNumber">
            <summary>
            Error number code, i.e. CS0116
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddTypeCompilerError.ErrorText">
            <summary>
            Error message text.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddTypeCompilerError.IsWarning">
            <summary>
            true if warning. false if error. 
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.AddTypeCommandBase">
            <summary>
            Base class that contains logic for Add-Type cmdlet based on 
            - CodeDomProvider 
            - CodeAnalysis(Roslyn)
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddTypeCommandBase.TypeDefinition">
            <summary>
            The source code of this type
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddTypeCommandBase.Name">
            <summary>
            The name of the type used for auto-generated types
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddTypeCommandBase.MemberDefinition">
            <summary>
            The source code of this method / member
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddTypeCommandBase.Namespace">
            <summary>
            The namespaced used for the auto-generated type
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddTypeCommandBase.UsingNamespace">
            <summary>
            Any using statements required by the auto-generated type
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddTypeCommandBase.Path">
            <summary>
            The path to the source code or DLL to load
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddTypeCommandBase.LiteralPath">
            <summary>
            The literal path to the source code or DLL to load
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddTypeCommandBase.AssemblyName">
            <summary>
            The name of the assembly to load
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddTypeCommandBase.Language">
            <summary>
            The language used to generate source code
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.AddTypeCommandBase.PostSetLanguage(Microsoft.PowerShell.Commands.Language)">
            <summary>
            Post-action for Language setter.
            </summary>
            <param name="language"></param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddTypeCommandBase.ReferencedAssemblies">
            <summary>
            Any reference DLLs to use in the compilation
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddTypeCommandBase.OutputAssembly">
            <summary>
            The path to the output assembly
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddTypeCommandBase.OutputType">
            <summary>
            The output type of the assembly
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddTypeCommandBase.PassThru">
            <summary>
            Flag to pass the resulting types along
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddTypeCommandBase.IgnoreWarnings">
            <summary>
            Flag to ignore warnings during compilation
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.AddTypeCommandBase.EndProcessing">
            <summary>
            Perform common error checks.
            Populate source code.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.AddTypeCommand">
            <summary>
            Adds a new type to the Application Domain. 
            This version is based on CodeDomProvider.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddTypeCommand.CodeDomProvider">
            <summary>
            A specific CodeProvider to use
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddTypeCommand.CompilerParameters">
            <summary>
            Specific compiler parameters to use
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.AddTypeCommand.EndProcessing">
            <summary>
            Generate the type(s)
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.WriteOutputCommand">
            <summary>
            This class implements Write-output command
            
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteOutputCommand.InputObject">
            <summary>
            Holds the list of objects to be Written
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteOutputCommand.NoEnumerate">
            <summary>
            Prevents Write-Output from unravelling collections passed to the InputObject
            parameter.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WriteOutputCommand.ProcessRecord">
            <summary>
            This method implements the ProcessRecord method for Write-output command
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StartSleepCommand">
            <summary>
            Suspend shell, script, or runspace activity for the specified period of time.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StartSleepCommand.Dispose">
            <summary>
             Dispose method of IDisposable interface.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StartSleepCommand.Seconds">
            <summary>
            Allows sleep time to be specified in seconds
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StartSleepCommand.Milliseconds">
            <summary>
            Allows sleep time to be specified in milliseconds
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StartSleepCommand.Sleep(System.Int32)">
            <summary>
            This method causes calling thread to sleep for 
            specified milliseconds
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StartSleepCommand.ProcessRecord">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StartSleepCommand.StopProcessing">
            <summary>
            stopprocessing override
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GetCultureCommand">
            <summary>
            Returns the thread's current culture.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetCultureCommand.BeginProcessing">
            <summary>
            Output the current Culture info object
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GetUICultureCommand">
            <summary>
            Returns the thread's current UI culture.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetUICultureCommand.BeginProcessing">
            <summary>
            Output the current UI Culture info object
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GetPSCallStackCommand">
            <summary>
            This class implements Get-PSCallStack.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetPSCallStackCommand.ProcessRecord">
            <summary>
            Get the call stack
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GetUniqueCommand">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetUniqueCommand.InputObject">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetUniqueCommand.AsString">
            <summary>
            This parameter specifies that objects should be converted to
            strings and the strings should be compared.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetUniqueCommand.OnType">
            <summary>
            This parameter specifies that just the types of the objects
            should be compared.
            </summary>
            <value></value>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetUniqueCommand.ProcessRecord">
            <summary>
            
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GetDateCommand">
            <summary> 
            implementation for the get-date command 
            </summary> 
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetDateCommand.Date">
            <summary>
            Allows user to override the date/time object that will be processed
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetDateCommand.Year">
            <summary>
            Allows the user to override the year
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetDateCommand.Month">
            <summary>
            Allows the user to override the month
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetDateCommand.Day">
            <summary>
            Allows the user to override the day
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetDateCommand.Hour">
            <summary>
            Allows the user to override the hour
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetDateCommand.Minute">
            <summary>
            Allows the user to override the minute
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetDateCommand.Second">
            <summary>
            Allows the user to override the second
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetDateCommand.Millisecond">
            <summary>
            Allows the user to override the millisecond
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetDateCommand.DisplayHint">
            <summary>
            This option determines the default output format used to display the object get-date emits
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetDateCommand.UFormat">
            <summary>
            Unix format string
            </summary> 
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetDateCommand.Format">
            <summary>
            Unix format string
            </summary> 
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetDateCommand.ProcessRecord">
            <summary>
            get the time
            </summary> 
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetDateCommand.UFormatDateString(System.DateTime)">
            <summary>
            This is more an implementation of the UNIX strftime
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.DisplayHintType">
            <summary>
            Display Hint type
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.DisplayHintType.Date">
            <summary>
            Display prerence Date-Only
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.DisplayHintType.Time">
            <summary>
            Display prerence Time-Only
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.DisplayHintType.DateTime">
            <summary>
            Display prerence Date and Time
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SetDateCommand">
            <summary> 
            implementation for the set-date command 
            </summary> 
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetDateCommand.Date">
            <summary>
            Allows user to override the date/time object that will be processed
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetDateCommand.Adjust">
            <summary>
            Allows a use to specify a timespan with which to apply to the current time
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetDateCommand.DisplayHint">
            <summary>
            This option determines the default output format used to display the object set-date emits
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SetDateCommand.ProcessRecord">
            <summary>
            set the date
            </summary> 
        </member>
        <member name="T:Microsoft.PowerShell.Commands.MatchInfoContext">
            <summary>
            Context information about a match.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MatchInfoContext.PreContext">
            <summary>
            Lines found before a match.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MatchInfoContext.PostContext">
            <summary>
            Lines found after a match.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MatchInfoContext.DisplayPreContext">
            <summary>
            Lines found before a match. Does not include
            overlapping context and thus can be used to
            display contiguous match regions.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MatchInfoContext.DisplayPostContext">
            <summary>
            Lines found after a match. Does not include
            overlapping context and thus can be used to
            display contiguous match regions.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.MatchInfoContext.Clone">
            <summary>
            Produce a deep copy of this object.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.MatchInfo">
            <summary>
            The object returned by select-string representing the result of a match.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MatchInfo.IgnoreCase">
            <summary>
            Indicates if the match was done ignoring case.
            </summary>
            <value>True if case was ignored.</value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MatchInfo.LineNumber">
            <summary>
            Returns the number of the matching line.
            </summary>
            <value>The number of the matching line.</value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MatchInfo.Line">
            <summary>
            Returns the text of the matching line.
            </summary>
            <value>The text of the matching line.</value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MatchInfo.Filename">
            <summary>
            Returns the base name of the file containing the matching line.
            <remarks>
            It will be the string "InputStream" if the object came from the input stream.
            This is a readonly propery calculated from <paramref name="Path"/>.
            </remarks>
            </summary>
            <value>The file name</value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MatchInfo.Path">
            <summary>
            The full path of the file containing the matching line.
            <remarks>
            It will be "InputStream" if the object came from the input stream.
            </remarks>
            </summary>
            <value>The path name</value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MatchInfo.Pattern">
            <summary>
            Returns the pattern that was used in the match.
            </summary>
            <value>The pattern string</value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MatchInfo.Context">
            <summary>
            The context for the match, or null if -context was not
            specified.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.MatchInfo.RelativePath(System.String)">
            <summary>
            Returns the path of the matching file truncated relative to the <paramref name="directory"/> parameter.
            <remarks>
            For example, if the matching path was c:\foo\bar\baz.c and the directory argument was c:\foo
            the routine would return bar\baz.c
            </remarks>
            </summary>
            <param name="directory">The directory base the truncation on.</param>
            <returns>The relative path that was produced.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.MatchInfo.ToString">
            <summary>
            Returns the string representation of this object. The format
            depends on whether a path has been set for this object or not.
            <remarks>
            If the path component is set, as would be the case when matching
            in a file, ToString() would return the path, line number and line text.
            If path is not set, then just the line text is presented.
            </remarks>
            </summary>
            <returns>The string representation of the match object</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.MatchInfo.ToString(System.String)">
            <summary>
            Returns the string representation of the match object same format as ToString()
            but trims the path to be relative to the <paramref name="directory"/> argument.
            </summary>
            <param name="directory">Directory to use as the root when calcualting the relative path</param>
            <returns>The string representation of the match object</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.MatchInfo.FormatLine(System.String,System.Int32,System.String,System.String)">
            <summary>
            Formats a line for use in ToString.
            </summary>
            <param name="lineStr">The line to format.</param>
            <param name="displayLineNumber">The line number to display.</param>
            <param name="displayPath">The file path, formatted for display.</param>
            <param name="prefix">The match prefix.</param>
            <returns>The formatted line as a string.</returns>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MatchInfo.Matches">
            <summary>
            A list of all Regex matches on the matching line.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.MatchInfo.Clone">
            <summary>
            Create a deep copy of this MatchInfo instance.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SelectStringCommand">
            <summary>
            A cmdlet to search through strings and files for particular patterns.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SelectStringCommand.CircularBuffer`1">
            <summary>
            A generic circular buffer.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SelectStringCommand.CircularBuffer`1.#ctor(System.Int32)">
            <summary>
            Construct a new buffer of the specified capacity.
            </summary>
            <param name="capacity">The maximum capacity of the buffer.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">If <paramref name="capacity" /> is negative.</exception>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SelectStringCommand.CircularBuffer`1.Capacity">
            <summary>
            The maximum capacity of the buffer. If more items
            are added than the buffer has capacity for, then
            older items will be removed from the buffer with
            a first-in, first-out policy.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SelectStringCommand.CircularBuffer`1.IsFull">
            <summary>
            Whether or not the buffer is at capacity.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SelectStringCommand.CircularBuffer`1.WrapIndex(System.Int32)">
            <summary>
            Convert from a 0-based index to a buffer index which
            has been properly offset and wrapped.
            </summary>
            <param name="zeroBasedIndex">The index to wrap.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">If <paramref name="zeroBasedIndex" /> is out of range.</exception>
            <returns>
            The actual index that <param ref="zeroBasedIndex" />
            maps to.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SelectStringCommand.CircularBuffer`1.Add(`0)">
            <summary>
            Adds an item to the buffer. If the buffer is already
            full, the oldest item in the list will be removed,
            and the new item added at the logical end of the list.
            </summary>
            <param name="item">The item to add.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SelectStringCommand.CircularBuffer`1.ToArray">
            <summary>
            Create an array of the items in the buffer. Items
            will be in the same order they were added.
            </summary>
            <returns>The new array.</returns>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SelectStringCommand.CircularBuffer`1.Item(System.Int32)">
            <summary>
            Access an item in the buffer. Indexing is based off
            of the order items were added, rather than any
            internal ordering the buffer may be maintaining.
            </summary>
            <param name="index">The index of the item to access.</param>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SelectStringCommand.IContextTracker">
            <summary>
            An interface to a context tracking algorithm.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SelectStringCommand.IContextTracker.EmitQueue">
            <summary>
            Matches with completed context information
            that are ready to be emitted into the pipeline.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SelectStringCommand.IContextTracker.TrackLine(System.String)">
            <summary>
            Track a non-matching line for context.
            </summary>
            <param name="line">The line to track.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SelectStringCommand.IContextTracker.TrackMatch(Microsoft.PowerShell.Commands.MatchInfo)">
            <summary>
            Track a matching line.
            </summary>
            <param name="match">The line to track.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SelectStringCommand.IContextTracker.TrackEOF">
            <summary>
            Track having reached the end of the file,
            giving the tracker a chance to process matches with
            incomplete context information.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SelectStringCommand.DisplayContextTracker">
            <summary>
            A state machine to track display context for each match.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SelectStringCommand.DisplayContextTracker.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor for DisplayContextTracker.
            </summary>
            <param name="preContext">How much precontext to collect at most.</param>
            <param name="postContext">How much precontext to collect at most.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SelectStringCommand.DisplayContextTracker.UpdateQueue">
            <summary>
            Moves matchInfo, if set, to the emitQueue and
            resets the tracking state.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SelectStringCommand.LogicalContextTracker">
            <summary>
            A class to track logical context for each match.
            </summary>
            <remarks>
            The difference between logical and display context is
            that logical context includes as many context lines
            as possible for a given match, up to the specified
            limit, including context lines which overlap between
            matches and other matching lines themselves. Display
            context, on the other hand, is designed to display
            a possibly-continuous set of matches by excluding
            overlapping context (lines will only appear once)
            and other matching lines (since they will appear
            as their own match entries.)
            </remarks>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SelectStringCommand.LogicalContextTracker.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor for LogicalContextTracker.
            </summary>
            <param name="preContext">How much precontext to collect at most.</param>
            <param name="postContext">How much postcontext to collect at most.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SelectStringCommand.LogicalContextTracker.EmitAllInRange(System.Int32,System.Int32)">
            <summary>
            Add all matches found in the specified range
            to the emit queue, collecting as much context
            as possible up to the limits specified in the ctor.
            </summary>
            <remarks>
            The range is inclusive; the entries at
            startIndex and endIndex will both be checked.
            </remarks>
            <param name="startIndex">The beginning of the match range.</param>
            <param name="endIndex">The ending of the match range.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SelectStringCommand.LogicalContextTracker.UpdateQueue">
            <summary>
            Add match(es) found in the match region to the
            emit queue. Should be called every time an entry
            is added to the context buffer.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SelectStringCommand.LogicalContextTracker.Emit(Microsoft.PowerShell.Commands.MatchInfo,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Collects context from the specified ranges. Populates
            the specified match with the collected context
            and adds it to the emit queue.
            </summary>
            <remarks>
            Context ranges must be within the bounds of the context
            buffer.
            </remarks>
            <param name="match">The match to operate on.</param>
            <param name="preStartIndex">The start index of the precontext range.</param>
            <param name="preLength">The length of the precontext range.</param>
            <param name="postStartIndex">The start index of the postcontext range.</param>
            <param name="postLength">The length of the precontext range.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SelectStringCommand.LogicalContextTracker.CopyContext(System.Int32,System.Int32)">
            <summary>
            Collects context from the specified ranges.
            </summary>
            <remarks>
            The range must be within the bounds of the context buffer.
            </remarks>
            <param name="startIndex">The index to start at.</param>
            <param name="length">The length of the range.</param>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SelectStringCommand.ContextTracker">
            <summary>
            A class to track both logical and display contexts.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SelectStringCommand.ContextTracker.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor for LogicalContextTracker.
            </summary>
            <param name="preContext">How much precontext to collect at most.</param>
            <param name="postContext">How much postcontext to collect at most.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SelectStringCommand.ContextTracker.UpdateQueue">
            <summary>
            Update the emit queue based on the wrapped trackers.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SelectStringCommand.InputObject">
            <summary>
            This parameter specifies the current pipeline object 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SelectStringCommand.Pattern">
             <summary>
             String index to start from the beginning.
            
             If the value is negative, the length is counted from the
             end of the string.
             </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SelectStringCommand.Path">
            <summary>
            file to read from 
            Globbing is done on these
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SelectStringCommand.LiteralPath">
            <summary>
            Literal file to read from 
            Globbing is not done on these
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SelectStringCommand.SimpleMatch">
            <summary> If set, match pattern string literally. 
            If not (default) search using pattern as a Regular Expression
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SelectStringCommand.CaseSensitive">
            <summary> 
             If true, then do case-sensitive searches...
             </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SelectStringCommand.Quiet">
            <summary>
            If true the cmdlet will stop processing at the first successful match and
            return true.  If both List and Quiet parameters are given, an exception is thrown.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SelectStringCommand.List">
            <summary> 
            list files where a match is found
            This is the Unix functionality this switch is intended to mimic; 
            the actual action of this option is to stop after the first match 
            is found and returned from any particular file. 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SelectStringCommand.Include">
            <summary>
            Lets you include particular files.  Files not matching
            one of these (if specified) are excluded.
            </summary>
            <exception cref="T:System.Management.Automation.WildcardPatternException">Invalid wildcard pattern was specified.</exception>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SelectStringCommand.Exclude">
            <summary>
            Lets you exclude particular files.  Files matching
            one of these (if specified) are excluded.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SelectStringCommand.NotMatch">
            <summary>
            Only show lines which do not match.
            Equivalent to grep -v/findstr -v.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SelectStringCommand.AllMatches">
             <summary>
             If set, sets the Matches property of MatchInfo to the result
             of calling System.Text.RegularExpressions.Regex.Matches() on
             the corresponding line.
            
             Has no effect if -SimpleMatch is also specified.
             </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SelectStringCommand.Encoding">
            <summary>
            The text encoding to process each file as.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SelectStringCommand.Context">
            <summary>
            The number of context lines to collect. If set to a
            single integer value N, collects N lines each of pre-
            and post- context. If set to a 2-tuple B,A, collects B
            lines of pre- and A lines of post- context.
            If set to a list with more than 2 elements, the
            excess elements are ignored.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SelectStringCommand.doneProcessing">
            <summary>
            This is used to handle the case were we're done processing input objects.
            If true, process record will just return.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SelectStringCommand.BeginProcessing">
            <summary>
            Read command line parameters.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SelectStringCommand.ProcessRecord">
             <summary>
             process the input
             </summary>
            
             <returns> Does not return a value </returns>
            
             <exception cref="T:System.ArgumentException">Regular expression parsing error, path error</exception>
             <exception cref="T:System.IO.FileNotFoundException">A file cannot be found.</exception>
             <exception cref="T:System.IO.DirectoryNotFoundException">A file cannot be found.</exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SelectStringCommand.ProcessFile(System.String)">
            <summary>
            Process a file which was either specified on the
            command line or passed in as a FileInfo object.
            </summary>
            <param name="filename">The file to process.</param>
            <returns>True if a match was found; otherwise false.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SelectStringCommand.FlushTrackerQueue(Microsoft.PowerShell.Commands.SelectStringCommand.ContextTracker)">
            <summary>
            Emit any objects which have been queued up, and clear
            the queue.
            </summary>
            <param name="contextTracker">The context tracker to operate on.</param>
            <returns>Whether or not any objects were emitted.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SelectStringCommand.EndProcessing">
            <summary>
            Complete processing. Emits any objects which have been queued up
            due to -context tracking.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SelectStringCommand.doMatchWorker(System.String,Microsoft.PowerShell.Commands.MatchInfo,Microsoft.PowerShell.Commands.MatchInfo@)">
            <summary>
            Check the operand and see if it matches, if this.quiet is not set, then
            return a partially populated MatchInfo object with Line, Pattern, IgnoreCase
            set.
            </summary>
            <param name="matchInfo"></param>
            <param name="matchResult">the match info object - this will be
            null if this.quiet is set. </param>
            <param name="operandString">the result of converting operand to
            a string.</param>
            <returns>true if the input object matched</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SelectStringCommand.ResolveFilePaths(System.String[],System.Boolean)">
            Get a list or resolved file paths.
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SelectStringCommand.FileinfoToStringAttribute">
            <summary>
            Magic class that works around the limitations on ToString() for FileInfo.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SelectStringCommand.meetsIncludeExcludeCriteria(System.String)">
            <summary>
            Check whether the supplied name meets the include/exclude criteria.
            That is - it's on the include list if there is one and not on
            the exclude list if there was one of those.
            </summary>
            <param name="filename"></param>
            <returns>True if the filename is acceptable.</returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.CompareObjectCommand">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CompareObjectCommand.ReferenceObject">
             <summary>
            
             </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CompareObjectCommand.DifferenceObject">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CompareObjectCommand.SyncWindow">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CompareObjectCommand.Property">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CompareObjectCommand.ExcludeDifferent">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CompareObjectCommand.IncludeEqual">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CompareObjectCommand.PassThru">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.CompareObjectCommand.Process(Microsoft.PowerShell.Commands.OrderByPropertyEntry)">
            <summary>
            The following is the matching algorithm:
            Retrieve the incoming object (differenceEntry) if any
            Retrieve the next reference object (referenceEntry) if any
            If differenceEntry matches referenceEntry
              Emit referenceEntry as a match
              Return
            If differenceEntry matches any entry in referenceEntryBacklog
              Emit the backlog entry as a match
              Remove the backlog entry from referenceEntryBacklog
              Clear differenceEntry
            If referenceEntry (if any) matches any entry in differenceEntryBacklog
              Emit referenceEntry as a match
              Remove the backlog entry from differenceEntryBacklog
              Clear referenceEntry
            If differenceEntry is still present
              If SyncWindow is 0
                Emit differenceEntry as unmatched
              Else
                While there is no space in differenceEntryBacklog
                  Emit oldest entry in differenceEntryBacklog as unmatched
                  Remove oldest entry from differenceEntryBacklog
                Add differenceEntry to differenceEntryBacklog
            If referenceEntry is still present
              If SyncWindow is 0
                Emit referenceEntry as unmatched
              Else
                While there is no space in referenceEntryBacklog
                  Emit oldest entry in referenceEntryBacklog as unmatched
                  Remove oldest entry from referenceEntryBacklog
                Add referenceEntry to referenceEntryBacklog
            </summary>
            <param name="differenceEntry"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.CompareObjectCommand.BeginProcessing">
            <summary>
            If the parameter 'ExcludeDifferent' is present, then we need to turn on the 
            'IncludeEqual' switch unless it's turned off by the user specifically.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.CompareObjectCommand.ProcessRecord">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.CompareObjectCommand.EndProcessing">
            <summary>
            
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GetHostCommand">
            <summary>
            
            Writes the PSHost object to the success stream
            
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetHostCommand.BeginProcessing">
            <summary>
            
            See base class
            
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GetRandomCommand">
            <summary>
            This class implements get-random cmdlet.  
            </summary>
            <!-- author: LukaszA -->
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetRandomCommand.Generator">
            <summary>
            Gets and sets generator associated with the current runspace
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetRandomCommand.SetSeed">
            <summary>
            Seed used to reinitialize random numbers generator
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetRandomCommand.Maximum">
            <summary>
            Maximum number to generate 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetRandomCommand.Minimum">
            <summary>
            Minimum number to generate
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetRandomCommand.InputObject">
            <summary>
            List from which random elements are chosen
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetRandomCommand.Count">
            <summary>
            Number of items to output (number of list items or of numbers) 
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetRandomCommand.GetRandomInt64(System.Int64,System.Int64)">
            <summary>
            Get a random Int64 type number
            </summary>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetRandomCommand.BeginProcessing">
            <summary>
            This method implements the BeginProcessing method for get-random command
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetRandomCommand.ProcessRecord">
            <summary>
            This method implements the ProcessRecord method for get-random command
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetRandomCommand.EndProcessing">
            <summary>
            This method implements the EndProcessing method for get-random command
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.PolymorphicRandomNumberGenerator">
            <summary>
            Provides an adapter API for random numbers that may be either cryptographically random, or
            generated with the regular pseudo-random number generator. Re-implementations of
            methods using the NextBytes() primitive based on the CLR implementation:
                http://referencesource.microsoft.com/#mscorlib/system/random.cs
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PolymorphicRandomNumberGenerator.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PolymorphicRandomNumberGenerator.NextDouble">
            <summary>
            Generates a random floating-point number that is greater than or equal to 0.0, and less than 1.0.
            </summary>
            <returns>A random floating-point number that is greater than or equal to 0.0, and less than 1.0</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PolymorphicRandomNumberGenerator.Next">
            <summary>
            Generates a non-negative random integer.
            </summary>
            <returns>A non-negative random integer.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PolymorphicRandomNumberGenerator.Next(System.Int32)">
            <summary>
            Returns a random integer that is within a specified range.
            </summary>
            <param name="maxValue">The exclusive upper bound of the random number returned.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PolymorphicRandomNumberGenerator.Next(System.Int32,System.Int32)">
            <summary>
            Returns a random integer that is within a specified range.
            </summary>
            <param name="minValue">The inclusive lower bound of the random number returned.</param>
            <param name="maxValue">The exclusive upper bound of the random number returned. maxValue must be greater than or equal to minValue</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PolymorphicRandomNumberGenerator.NextBytes(System.Byte[])">
            <summary>
            Fills the elements of a specified array of bytes with random numbers.
            </summary>
            <param name="buffer">The array to be filled</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PolymorphicRandomNumberGenerator.InternalSample">
            <summary>
            Samples a random integer
            </summary>
            <returns>A random integer, using the full range of Int32</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PolymorphicRandomNumberGenerator.InternalSampleLargeRange">
            <summary>
            Samples a random int when the range is large. This does
            not need to be in the range of -Double.MaxValue .. Double.MaxValue,
            just 0.. (2 * Int32.MaxValue) - 1
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.InvokeExpressionCommand">
            <summary>
            Class implemeting Invoke-Expression
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.InvokeExpressionCommand.Command">
            <summary>
            Command to execute.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.InvokeExpressionCommand.ProcessRecord">
            <summary>
            For each record, execute it, and push the results into the 
            success stream.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.NewTimeSpanCommand">
            <summary> 
            implementation for the new-timespan command 
            </summary> 
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewTimeSpanCommand.Start">
            <summary>
            This parameter indicates the date the time span begins;
            it is used if two times are being compared
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewTimeSpanCommand.End">
            <summary>
            This parameter indicates the end of a time span.  It is used if two
            times are being compared.  If one of the times is not specified,
            the current system time is used.  
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewTimeSpanCommand.Days">
            <summary>
            Allows the user to override the day
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewTimeSpanCommand.Hours">
            <summary>
            Allows the user to override the hour
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewTimeSpanCommand.Minutes">
            <summary>
            Allows the user to override the minute
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewTimeSpanCommand.Seconds">
            <summary>
            Allows the user to override the second
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.NewTimeSpanCommand.ProcessRecord">
            <summary>
            Calculate and write out the appropriate timespan
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.TeeObjectCommand">
            <summary>
            Class for Tee-object implementation
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TeeObjectCommand.InputObject">
            <summary>
            object to process
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TeeObjectCommand.FilePath">
            <summary>
            FilePath parameter
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TeeObjectCommand.LiteralPath">
            <summary>
            Literal FilePath parameter
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TeeObjectCommand.Append">
            <summary>
            Append switch
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TeeObjectCommand.Variable">
            <summary>
            Variable parameter
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.TeeObjectCommand.BeginProcessing">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.TeeObjectCommand.ProcessRecord">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.TeeObjectCommand.EndProcessing">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.TeeObjectCommand.Dispose">
            <summary>
            Dispose method in IDisposeable
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.TeeObjectCommand.Finalize">
            <summary>
            Finalizer
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.MeasureCommandCommand">
            <summary>
            Implements a cmdlet that applies a script block
            to each element of the pipeline.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MeasureCommandCommand.InputObject">
            <summary>
            This parameter specifies the current pipeline object 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MeasureCommandCommand.Expression">
            <summary>
            The script block to apply
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.MeasureCommandCommand.EndProcessing">
            <summary>
            Output the timer
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.MeasureCommandCommand.ProcessRecord">
            <summary>
            Execute the script block passing in the current pipeline object as
            it's only parameter.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.UnblockFileCommand">
            <summary>Removes the Zone.Identifier stream from a file.</summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.UnblockFileCommand.Path">
            <summary>
            The path of the file to unblock
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.UnblockFileCommand.LiteralPath">
            <summary>
            The literal path of the file to unblock
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.UnblockFileCommand.ProcessRecord">
            <summary>
            Generate the type(s)
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.UnblockFileCommand.IsValidFileForUnblocking(System.String)">
            <summary>
            IsValidFileForUnblocking is a helper method used to validate if 
            the supplied file path has to be considered for unblocking.
            </summary>
            <param name="resolvedpath">File or directory path.</param>
            <returns>True is the supplied path is a 
            valid file path or else false is returned. 
            If the supplied path is a directory path then false is returned.</returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.UtilityCommon">
            <summary>
            The base class for all command processor classes. It provides
            abstract methods to execute a command.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.UtilityCommon.CheckForSevereException(System.Management.Automation.PSCmdlet,System.Exception)">
            <summary>
            Checks whether the exception is a severe exception which should
            cause immediate process failure.
            </summary>
            <param name="cmdlet">can be null</param>
            <param name="e"></param>
            <remarks>
            CB says 02/23/2005: I personally would err on the side
            of treating OOM like an application exception, rather than
            a critical system failure.I think this will be easier to justify
            in Orcas, if we tease apart the two cases of OOM better.
            But even in Whidbey, how likely is it that we couldnt JIT
            some backout code?  At that point, the process or possibly
            the machine is likely to stop executing soon no matter
            what you do in this routine.  So I would just consider
            AccessViolationException.  (I understand why you have SO here,
            at least temporarily).
            </remarks>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.UtilityCommon.GetEncodingFromEnum(Microsoft.PowerShell.Commands.TextEncodingType)">
            <summary>
            Converts the textencodingtype enum value to the corresponding encoding
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.TextEncodingType">
            <summary>
            abc
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.TextEncodingType.Unknown">
            <summary>
            No encoding.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.TextEncodingType.String">
            <summary>
            Unicode encoding.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.TextEncodingType.Unicode">
            <summary>
            Unicode encoding.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.TextEncodingType.Byte">
            <summary>
            Byte encoding.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.TextEncodingType.BigEndianUnicode">
            <summary>
            Big Endian Unicode encoding.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.TextEncodingType.Utf8">
            <summary>
            UTF8 encoding.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.TextEncodingType.Utf7">
            <summary>
            UTF7 encoding.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.TextEncodingType.Ascii">
            <summary>
            ASCII encoding.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.UtilityResources">
            <summary>
            Utility class to contain resources for the Microsoft.PowerShell.Utility module
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.UtilityResources.PathDoesNotExist">
            <summary>
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.UtilityResources.FileReadError">
            <summary>
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.UtilityResources.FormatHexTypeNotSupported">
            <summary>
            Error message to indicate that Format-Hex cmdlet does not directly support the type provided as input.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.UtilityResources.FormatHexResolvePathError">
            <summary>
            Error message to indicate that Format-Hex cmdlet does not directly support the type provided as input.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.UtilityResources.FormatHexPathPrefix">
            <summary>
            The resource string used to indicate 'PATH:' in the formating header.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.UtilityResources.AlgorithmTypeNotSupported">
            <summary>
            Error message to indicate that requested algorithm  is not supported on the target platform.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.UtilityResources.CouldNotParseAsPowerShellDataFile">
            <summary>
            The file '{0}' could not be parsed as a PowerShell Data File.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ByteCollection">
            <summary>
            ByteCollection is used as a wrapper class for the collection of bytes.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ByteCollection.#ctor(System.UInt32,System.Byte[],System.String)">
            <summary>
            ByteCollection constructor.
            </summary>
            <param name="offset">The Offset address to be used while displaying the bytes in the collection.</param>
            <param name="value">Underlying bytes stored in the collection.</param>
            <param name="path">Indicates the path of the file whose contents are wrapped in the ByteCollection.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ByteCollection.#ctor(System.UInt32,System.Byte[])">
            <summary>
            ByteCollection constructor.
            </summary>
            <param name="offset">The Offset address to be used while displaying the bytes in the collection.</param>
            <param name="value">Underlying bytes stored in the collection.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ByteCollection.#ctor(System.Byte[])">
            <summary>
            ByteCollection constructor.
            </summary>
            <param name="value">Underlying bytes stored in the collection.</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ByteCollection.Offset">
            <summary>
            The Offset address to be used while displaying the bytes in the collection.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ByteCollection.Bytes">
            <summary>
            Underlying bytes stored in the collection.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ByteCollection.Path">
            <summary>
            Indicates the path of the file whose contents are wrapped in the ByteCollection.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ByteCollection.ToString">
            <summary>
            Displays the hexadecimal format of the bytes stored in the collection.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SetAliasCommand">
            <summary>
            The implementation of the "set-alias" cmdlet
            </summary>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SetAliasCommand.ProcessRecord">
            <summary>
            The main processing loop of the command.
            </summary>
            
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GetAliasCommand">
            <summary>
            The implementation of the "get-alias" cmdlet
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetAliasCommand.Name">
            <summary>
            The Name parameter for the command
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetAliasCommand.Exclude">
            <summary>
            The Exclude parameter for the command
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetAliasCommand.Scope">
            <summary>
            The scope parameter for the command determines
            which scope the aliases are retrieved from.
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetAliasCommand.Definition">
            <summary>
            Parameter definition to retrieve aliases based on their definitions.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetAliasCommand.ProcessRecord">
            <summary>
            The main processing loop of the command.
            </summary>
            
        </member>
        <member name="T:Microsoft.PowerShell.Commands.NewAliasCommand">
            <summary>
            The implementation of the "new-alias" cmdlet
            </summary>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.NewAliasCommand.ProcessRecord">
            <summary>
            The main processing loop of the command.
            </summary>
            
        </member>
        <member name="T:Microsoft.PowerShell.Commands.WriteAliasCommandBase">
            <summary>
            The base class for the SetAliasCommand and NewAliasCommand
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteAliasCommandBase.Name">
            <summary>
            The Name parameter for the command
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteAliasCommandBase.Value">
            <summary>
            The Value parameter for the command
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteAliasCommandBase.Description">
            <summary>
            The description for the alias.
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteAliasCommandBase.Option">
            <summary>
            The Option parameter allows the alias to be set to 
            ReadOnly (for existing aliases) and/or Constant (only
            for new aliases).
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteAliasCommandBase.PassThru">
            <summary>
            If set to true, the alias that is set is passed to the
            pipeline.
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteAliasCommandBase.Scope">
            <summary>
            The scope parameter for the command determines
            which scope the alias is set in.
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteAliasCommandBase.Force">
            <summary>
            If set to true and an existing alias of the same name exists
            and is ReadOnly, the alias will be overwritten.
            </summary>
            
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ExportAliasFormat">
            <summary>
            The formats that export-alias supports
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ExportAliasFormat.Csv">
            <summary>
            Aliases will be exported to a CSV file
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ExportAliasFormat.Script">
            <summary>
            Aliases will be exported as an MSH script
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ExportAliasCommand">
            <summary>
            The implementation of the "export-alias" cmdlet
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ExportAliasCommand.Path">
            <summary>
            The Path of the file to export the aliases to.
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ExportAliasCommand.LiteralPath">
            <summary>
            The literal path of the file to export the aliases to.
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ExportAliasCommand.Name">
            <summary>
            The Name parameter for the command
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ExportAliasCommand.PassThru">
            <summary>
            If set to true, the alias that is set is passed to the
            pipeline.
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ExportAliasCommand.As">
             <summary>
             Parameter that determines the format of the file created.
             </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ExportAliasCommand.Append">
            <summary>
            Property that sets append parameter.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ExportAliasCommand.Force">
            <summary>
            Property that sets force parameter.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ExportAliasCommand.NoClobber">
            <summary>
            Property that prevents file overwrite.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ExportAliasCommand.Description">
            <summary>
            The description that gets added to the file as a comment
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ExportAliasCommand.Scope">
            <summary>
            The scope parameter for the command determines
            which scope the aliases are retrieved from.
            </summary>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ExportAliasCommand.ProcessRecord">
            <summary>
            The main processing loop of the command.
            </summary>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ExportAliasCommand.EndProcessing">
            <summary>
            Writes the aliases to the file
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ExportAliasCommand.matchingAliases">
            <summary>
            Holds all the matching aliases for writing to the file
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ExportAliasCommand.OpenFile(System.IO.FileInfo@)">
            <summary>
            Open the file to which aliases should be exported
            </summary>
            <param name="readOnlyFileInfo">
            If not null, this is the file whose read-only attribute
            was cleared (due to the -Force parameter).  The attribute
            should be reset.
            </param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ImportAliasCommand">
            <summary>
            The implementation of the "import-alias" cmdlet
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ImportAliasCommand.Path">
            <summary>
            The path from which to import the aliases
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ImportAliasCommand.LiteralPath">
            <summary>
            The literal path from which to import the aliases
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ImportAliasCommand.Scope">
            <summary>
            The scope to import the aliases to.
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ImportAliasCommand.PassThru">
            <summary>
            If set to true, the alias that is set is passed to the
            pipeline.
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ImportAliasCommand.Force">
            <summary>
            If set to true and an existing alias of the same name exists
            and is ReadOnly, the alias will be overwritten.
            </summary>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ImportAliasCommand.ProcessRecord">
            <summary>
            The main processing loop of the command.
            </summary>
            
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ImportLocalizedData">
            <summary>
            The implementation of the "import-localizeddata" cmdlet
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ImportLocalizedData.BindingVariable">
            <summary>
            The path from which to import the aliases
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ImportLocalizedData.UICulture">
            <summary>
            The scope to import the aliases to.
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ImportLocalizedData.BaseDirectory">
            <summary>
            The scope to import the aliases to.
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ImportLocalizedData.FileName">
            <summary>
            The scope to import the aliases to.
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ImportLocalizedData.SupportedCommand">
            <summary>
            The command allowed in the data file.  If unspecified, then ConvertFrom-StringData
            is allowed.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ImportLocalizedData.ProcessRecord">
            <summary>
            The main processing loop of the command.
            </summary>
            
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ConvertFromStringDataCommand">
            <summary>
            Class comment
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ConvertFromStringDataCommand.StringData">
            <summary>
            The list of properties to display
            These take the form of an MshExpression
            </summary>
            <value></value>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertFromStringDataCommand.ProcessRecord">
            <summary>
            
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ReadHostCommand">
             <summary>
            
             Retrieves input from the host virtual console and writes it to the pipeline output.
            
             </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ReadHostCommand.#ctor">
             <summary>
            
             Constructs a new instance.
             
             </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ReadHostCommand.Prompt">
             <summary>
            
             The objects to display on the host before collecting input.
            
             </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ReadHostCommand.AsSecureString">
             <summary>
            
             Set to no echo the input as is is typed.
            
             </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ReadHostCommand.BeginProcessing">
             <summary>
            
             Write the prompt, then collect a line of input from the host, then
             output it to the output stream.
            
             </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.CSVHelper">
            <summary>
            This class is used to parse CSV text.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CSVHelper.Delimiter">
            <summary>
            Gets or sets the delimiter that separates the values
            </summary>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.CSVHelper.ParseCsv(System.String)">
             <summary>
             Parse a CSV String.
             </summary>
             
             <param name="csv">
             String to be parsed
             </param>
            
        </member>
        <member name="T:Microsoft.PowerShell.Commands.BaseCsvWritingCommand">
            <summary>
            This class implements the base for exportcsv and converttocsv commands
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.BaseCsvWritingCommand.Delimiter">
            <summary>
            Property that sets delimiter
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.BaseCsvWritingCommand._delimiter">
            <summary>
            Delimiter to be used.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.BaseCsvWritingCommand.UseCulture">
            <summary>
            Culture switch for csv conversion        
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.BaseCsvWritingCommand.InputObject">
            <summary>
            Abstract Property - Input Object which is written in Csv format
            Derived as Different Attributes.In ConvertTo-CSV, This is a positional parameter. Export-CSV not a Positional behaviour.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.BaseCsvWritingCommand.NoTypeInformation">
            <summary>
            NoTypeInformation : should the #TYPE line be generated
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.BaseCsvWritingCommand.WriteCsvLine(System.String)">
            <summary>
            Write the string to a file or pipelin
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.BaseCsvWritingCommand.BeginProcessing">
            <summary>
            BeginProcessing override
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ExportCsvCommand">
            <summary>
            implementation for the export-csv command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ExportCsvCommand.InputObject">
            <summary>
            Input Object for CSV Writing.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ExportCsvCommand.Path">
            <summary>
            mandatory file name to write to
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ExportCsvCommand.LiteralPath">
            <summary>
            The literal path of the mandatory file name to write to
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ExportCsvCommand.Force">
            <summary>
            Property that sets force parameter.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ExportCsvCommand.NoClobber">
            <summary>
            Property that prevents file overwrite.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ExportCsvCommand.Encoding">
            <summary>
            Encoding optional flag
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ExportCsvCommand.Append">
            <summary>
            Property that sets append parameter.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ExportCsvCommand.BeginProcessing">
            <summary>
            BeginProcessing override
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ExportCsvCommand.ProcessRecord">
            <summary>
            Convert the current input object to Csv and write to file/WriteObject
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ExportCsvCommand.EndProcessing">
            <summary>
            EndProcessing
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ExportCsvCommand._fs">
            <summary>
            handle to file stream
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ExportCsvCommand._sw">
            <summary>
            stream writer used to write to file
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ExportCsvCommand.readOnlyFileInfo">
            <summary>
            handle to file whose read-only attribute should be reset when we are done
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ExportCsvCommand.WriteCsvLine(System.String)">
            <summary>
            Write the csv line to file
            </summary>
            <param name="line"></param>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ExportCsvCommand._disposed">
            <summary>
            Set to true when object is disposed
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ExportCsvCommand.Dispose">
            <summary>
            public dispose method
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ImportCsvCommand">
            <summary>
            Implements Import-Csv command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ImportCsvCommand.Delimiter">
            <summary>
            Property that sets delimiter
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ImportCsvCommand.Path">
            <summary>
            mandatory file name to read from
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ImportCsvCommand.LiteralPath">
            <summary>
            The literal path of the mandatory file name to read from
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ImportCsvCommand.UseCulture">
            <summary>
            Property that sets UseCulture parameter
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ImportCsvCommand.Header">
            <summary>
             Header property to customize the names
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ImportCsvCommand.Encoding">
            <summary>
            Encoding optional flag
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ImportCsvCommand._alreadyWarnedUnspecifiedNames">
            <summary>
            Avoid writing out duplicate warning messages when there are 
            one or more unspecified names
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ImportCsvCommand.BeginProcessing">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ImportCsvCommand.ProcessRecord">
            <summary>
            ProcessRecord overload
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ConvertToCsvCommand">
            <summary>
            Implements ConvertTo-Csv command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ConvertToCsvCommand.InputObject">
            <summary>
            Overrides Base InputObject 
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ConvertToCsvCommand._propertyNames">
            <summary>
            Stores Property Names
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ConvertToCsvCommand.helper">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertToCsvCommand.BeginProcessing">
            <summary>
            BeginProcessing override
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertToCsvCommand.ProcessRecord">
            <summary>
            Convert the current input object to Csv and write to stream/WriteObject
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertToCsvCommand.WriteCsvLine(System.String)">
            <summary>
            
            </summary>
            <param name="line"></param>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ConvertFromCsvCommand">
            <summary>
            Implements ConvertFrom-Csv command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ConvertFromCsvCommand.Delimiter">
            <summary>
            Property that sets delimiter
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ConvertFromCsvCommand.UseCulture">
            <summary>
            Culture switch for csv conversion        
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ConvertFromCsvCommand.InputObject">
            <summary>
            Input Object which is written in Csv format
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ConvertFromCsvCommand.Header">
            <summary>
             Header property to customize the names
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ConvertFromCsvCommand._alreadyWarnedUnspecifiedNames">
            <summary>
            Avoid writing out duplicate warning messages when there are 
            one or more unspecified names
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertFromCsvCommand.BeginProcessing">
            <summary>
            BeginProcessing override
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertFromCsvCommand.ProcessRecord">
            <summary>
            Convert the current input object to Csv and write to stream/WriteObject
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ExportCsvHelper">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ExportCsvHelper._cmdlet">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ExportCsvHelper.#ctor(System.Management.Automation.PSCmdlet,System.Char)">
            <summary>
            
            </summary>
            <param name="cmdlet"></param>
            <param name="delimiter"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ExportCsvHelper.BuildPropertyNames(System.Management.Automation.PSObject,System.Collections.Generic.IList{System.String})">
            <summary>
            Get the name of properties from source PSObject and 
            add them to _propertyNames.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ExportCsvHelper.ConvertPropertyNamesCSV(System.Collections.Generic.IList{System.String})">
            <summary>
            Converts PropertyNames in to a CSV string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ExportCsvHelper.ConvertPSObjectToCSV(System.Management.Automation.PSObject,System.Collections.Generic.IList{System.String})">
            <summary>
            
            </summary>
            <param name="mshObject"></param>
            <param name="propertyNames"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ExportCsvHelper.GetToStringValueForProperty(System.Management.Automation.PSPropertyInfo)">
            <summary>
            Get value from property object
            </summary>
            <param name="property"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ExportCsvHelper.GetTypeString(System.Management.Automation.PSObject)">
            <summary>
            Prepares string for writing type information
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ExportCsvHelper.EscapeAndAppendString(System.Text.StringBuilder,System.String)">
            <summary>
            Escapes the " in string if necessary.
            Encloses the string in double quotes if necessary.
            </summary>
            <returns></returns>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ExportCsvHelper._disposed">
            <summary>
            Set to true when object is disposed
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ExportCsvHelper.Dispose">
            <summary>
            public dispose method
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ImportCsvHelper">
            <summary>
            Helper class to import single CSV file
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ImportCsvHelper._cmdlet">
            <summary>
            Reference to cmdlet which is using this helper class
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ImportCsvHelper._delimiter">
            <summary>
            CSV delimiter (default is the "comma" / "," character)
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ImportCsvHelper.UnspecifiedName">
            <summary>
            Use "UnspecifiedName" when the name is null or empty
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ImportCsvHelper._alreadyWarnedUnspecifiedName">
            <summary>
            Avoid writing out duplicate warning messages when there are 
            one or more unspecified names
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ImportCsvHelper.Header">
            <summary>
            Reference to header values
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ImportCsvHelper.TypeName">
            <summary>
            ETS type name from the first line / comment in the CSV
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ImportCsvHelper._sr">
            <summary>
            Reader of the csv content
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ImportCsvHelper.EOF">
            <summary>
            This is set to true when end of file is reached
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ImportCsvHelper.PeekNextChar(System.Char)">
            <summary>
            Peeks the next character in the stream and returns true if it is
            same as passed in character.
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ImportCsvHelper.ReadLine">
            <summary>
            Reads a line from file. This consumes the end of line.
            Only use it when end of line chars are not important.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ImportCsvHelper.ValidatePropertyNames(System.Collections.Generic.IList{System.String})">
            <summary>
            Validate the names of properties
            </summary>
            <param name="names"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ImportCsvHelper.ReadTypeInformation">
            <summary>
            Read the type information, if present
            </summary>
            <returns>Type string if present else null</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ImportCsvHelper.ParseNextRecord(System.Boolean)">
            <summary>
            Reads the next record from the file and returns parsed collection
            of string.
            </summary>
            <param name="isHeaderRow">
            Indicates if the parsed row is a header row or a values row.
            </param>
            <returns>
            Parsed collection of strings.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ImportCsvHelper.ReadTillNextDelimiter(System.Text.StringBuilder,System.Boolean@,System.Boolean)">
            <summary>
            This function reads the characters till next delimiter and adds them
            to current
            </summary>
            <param name="current"></param>
            <param name="endOfRecord">
            this is true if end of record is reached
            when delimiter is hit. This would be true if delimiter is NewLine
            </param>
            <param name="eatTrailingBlanks">
            If this is true, eat the trailing blanks. Note:if there are non
            whitespace characters present, then trailing blanks are not consumed
            </param>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ImportExportCSVHelper">
            <summary>
            Helper class for CSV conversion
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SetPSBreakpointCommand">
            <summary>
            This class implements Set-PSBreakpoint command.  
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetPSBreakpointCommand.Action">
            <summary>
            the action to take when hitting this breakpoint
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetPSBreakpointCommand.Column">
            <summary>
            The column to set the breakpoint on
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetPSBreakpointCommand.Command">
            <summary>
            the command(s) to set the breakpoint on
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetPSBreakpointCommand.Line">
            <summary>
            the line to set the breakpoint on
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetPSBreakpointCommand.Script">
            <summary>
            the script to set the breakpoint on
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetPSBreakpointCommand.Variable">
            <summary>
            the variables to set the breakpoint(s) on
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetPSBreakpointCommand.Mode">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SetPSBreakpointCommand.BeginProcessing">
            <summary>
            verifies that debugging is supported
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SetPSBreakpointCommand.ProcessRecord">
            <summary>
            set a new breakpoint
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.BreakpointType">
            <summary>
            Types of breakpoints
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.BreakpointType.Line">
            <summary>Breakpoint on a line within a script</summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.BreakpointType.Variable">
            <summary>
            Breakpoint on a variable</summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.BreakpointType.Command">
            <summary>Breakpoint on a command</summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GetPSBreakpointCommand">
            <summary>
            This class implements Remove-PSBreakpoint 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetPSBreakpointCommand.Script">
            <summary>
            Scripts of the breakpoints to output
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetPSBreakpointCommand.Id">
            <summary>
            IDs of the breakpoints to output
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetPSBreakpointCommand.Variable">
            <summary>
            Variables of the breakpoints to output
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetPSBreakpointCommand.Command">
            <summary>
            Commands of the breakpoints to output
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetPSBreakpointCommand.Type">
            <summary>
            Commands of the breakpoints to output
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetPSBreakpointCommand.ProcessRecord">
            <summary>
            remove breakpoints
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GetPSBreakpointCommand.FilterSelector`1">
            <summary>
            Gives the criteria to filter breakpoints
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetPSBreakpointCommand.Filter``1(System.Collections.Generic.List{System.Management.Automation.Breakpoint},``0[],Microsoft.PowerShell.Commands.GetPSBreakpointCommand.FilterSelector{``0})">
            <summary>
            Returns the items in the input list that match an item in the filter array according to
            the given selection criterion.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.RemovePSBreakpointCommand">
            <summary>
            This class implements Remove-PSBreakpoint 
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RemovePSBreakpointCommand.ProcessBreakpoint(System.Management.Automation.Breakpoint)">
            <summary>
            Removes the given breakpoint
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.PSBreakpointCommandBase">
            <summary>
            Base class for Enable/Disable/Remove-PSBreakpoint 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.PSBreakpointCommandBase.Breakpoint">
            <summary>
            the breakpoint to enable
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.PSBreakpointCommandBase.Id">
            <summary>
            The Id of the breakpoint to enable
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PSBreakpointCommandBase.ProcessRecord">
            <summary>
            Gathers the list of breakpoints to process and calls ProcessBreakpoints
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PSBreakpointCommandBase.ProcessBreakpoint(System.Management.Automation.Breakpoint)">
            <summary>
            Process the given breakpoint
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.EnablePSBreakpointCommand">
            <summary>
            This class implements Enable-PSBreakpoint 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.EnablePSBreakpointCommand.PassThru">
            <summary>
            Gets or sets the parameter -passThru which states whether the
            command should place the breakpoints it processes in the pipeline.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.EnablePSBreakpointCommand.ProcessBreakpoint(System.Management.Automation.Breakpoint)">
            <summary>
            Enables the given breakpoint
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.DisablePSBreakpointCommand">
            <summary>
            This class implements Disable-PSBreakpoint 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.DisablePSBreakpointCommand.PassThru">
            <summary>
            Gets or sets the parameter -passThru which states whether the
            command should place the breakpoints it processes in the pipeline.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.DisablePSBreakpointCommand.ProcessBreakpoint(System.Management.Automation.Breakpoint)">
            <summary>
            Disables the given breakpoint
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.DebugRunspaceCommand">
            <summary>
            This cmdlet takes a Runspace object and checks to see if it is debuggable (i.e, if 
            it is running a script or is currently stopped in the debugger.  If it
            is debuggable then it breaks into the Runspace debugger in step mode.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.DebugRunspaceCommand.Runspace">
            <summary>
            The Runspace to be debugged.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.DebugRunspaceCommand.Name">
            <summary>
            The name of a Runspace to be debugged.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.DebugRunspaceCommand.Id">
            <summary>
            The Id of a Runsapce to be debugged.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.DebugRunspaceCommand.InstanceId">
            <summary>
            The InstanceId of a Runspace to be debugged.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.DebugRunspaceCommand.EndProcessing">
            <summary>
            End processing.  Do work.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.DebugRunspaceCommand.StopProcessing">
            <summary>
            Stop processing.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GetRunspaceCommand">
            <summary>
            This cmdlet returns runspaces in the PowerShell session.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetRunspaceCommand.Name">
            <summary>
            Specifies name or names of Runspaces to return.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetRunspaceCommand.Id">
            <summary>
            Specifies one or more Ids of Runspaces to return.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetRunspaceCommand.InstanceId">
            <summary>
            Specifies one or more InstanceId Guids of Runspaces to return.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetRunspaceCommand.ProcessRecord">
            <summary>
            Process record
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.PSRunspaceDebug">
            <summary>
            Runspace Debug Options class
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.PSRunspaceDebug.Enabled">
            <summary>
            When true this property will cause any breakpoints set in a Runspace to stop 
            the running command or script when the breakpoint is hit, regardless of whether a
            debugger is currently attached.  The script or command will remain stopped until
            a debugger is attached to debug the breakpoint.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.PSRunspaceDebug.BreakAll">
            <summary>
            When true this property will cause any running command or script in the Runspace
            to stop in step mode, regardless of whether a debugger is currently attached.  The 
            script or command will remain stopped until a debugger is attached to debug the 
            current stop point.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.PSRunspaceDebug.RunspaceName">
            <summary>
            Name of runspace for which the options apply.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.PSRunspaceDebug.RunspaceId">
            <summary>
            Local Id of runspace for which the options apply.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PSRunspaceDebug.#ctor(System.Boolean,System.Boolean,System.String,System.Int32)">
            <summary>
            Constructor.
            </summary>
            <param name="enabled">Enable debugger option</param>
            <param name="breakAll">BreakAll option</param>
            <param name="runspaceName">Runspace name</param>
            <param name="runspaceId">Runspace local Id</param>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.CommonRunspaceCommandBase">
            <summary>
            Abstract class that defines common Runpace Command parameters.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CommonRunspaceCommandBase.RunspaceParameterSet">
            <summary>
            RunspaceParameterSet
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CommonRunspaceCommandBase.RunspaceNameParameterSet">
            <summary>
            RunspaceNameParameterSet
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CommonRunspaceCommandBase.RunspaceIdParameterSet">
            <summary>
            RunspaceIdParameterSet
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CommonRunspaceCommandBase.RunspaceInstanceIdParameterSet">
            <summary>
            RunspaceInstanceIdParameterSet
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CommonRunspaceCommandBase.ProcessNameParameterSet">
            <summary>
            ProcessNameParameterSet
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CommonRunspaceCommandBase.RunspaceName">
            <summary>
            Runspace Name
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CommonRunspaceCommandBase.Runspace">
            <summary>
            Runpace
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CommonRunspaceCommandBase.RunspaceId">
            <summary>
            Runspace Id
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CommonRunspaceCommandBase.RunspaceInstanceId">
            <summary>
            RunspaceInstanceId
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CommonRunspaceCommandBase.ProcessName">
            <summary>
            Gets or Sets the ProcessName for which runspace debugging has to be enabled or disabled. 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CommonRunspaceCommandBase.AppDomainName">
            <summary>
            Gets or Sets the AppDomain Names for which runspace debugging has to be enabled or disabled. 
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.CommonRunspaceCommandBase.GetRunspaces">
            <summary>
            Returns a list of valid runspaces based on current parameter set.
            </summary>
            <returns>IReadOnlyList</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.CommonRunspaceCommandBase.GetDebuggerFromRunspace(System.Management.Automation.Runspaces.Runspace)">
            <summary>
            Returns Runspace Debugger
            </summary>
            <param name="runspace">Runspace</param>
            <returns>Debugger</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.CommonRunspaceCommandBase.SetDebugPreferenceHelper(System.String,System.String[],System.Boolean,System.String)">
            <summary>
            SetDebugPreferenceHelper is a helper method used to enable/disabe debug preference.
            </summary>
            <param name="processName">Process Name</param>
            <param name="appDomainName">App Domain Name</param>
            <param name="enable">Indicates if debug preference has to be enabled or disabled.</param>
            <param name="fullyQualifiedErrorId">FullyQualifiedErrorId to be used on error.</param>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.EnableRunspaceDebugCommand">
            <summary>
            This cmdlet enables debugging for selected runspaces in the current or specified process.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.EnableRunspaceDebugCommand.BreakAll">
            <summary>
            When true this property will cause any running command or script in the Runspace
            to stop in step mode, regardless of whether a debugger is currently attached.  The 
            script or command will remain stopped until a debugger is attached to debug the 
            current stop point.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.EnableRunspaceDebugCommand.ProcessRecord">
            <summary>
            Process Record
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.DisableRunspaceDebugCommand">
            <summary>
            This cmdlet disables Runspace debugging in selected Runspaces.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.DisableRunspaceDebugCommand.ProcessRecord">
            <summary>
            Process Record
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GetRunspaceDebugCommand">
            <summary>
            This cmdlet returns a PSRunspaceDebug object for each found Runspace object.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetRunspaceDebugCommand.ProcessRecord">
            <summary>
            Process Record
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.WaitDebuggerCommand">
            <summary>
            This cmdlet causes a running script or command to stop in the debugger at the next execution point.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WaitDebuggerCommand.EndProcessing">
            <summary>
            EndProcessing
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.WriteProgressCommand">
            <summary>
            
            Implements the write-progress cmdlet
            
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteProgressCommand.Activity">
            <summary>
            
            Describes the activity for which progress is being reported.
            
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteProgressCommand.Status">
            <summary>
            
            Describes the current state of the activity.
            
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteProgressCommand.Id">
            <summary>
            
            Uniquely identifies this activity for purposes of chaining subordinate activities.
            
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteProgressCommand.PercentComplete">
            <summary>
            
            Percentage completion of the activity, or -1 if n/a
            
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteProgressCommand.SecondsRemaining">
            <summary>
            
            Seconds remaining to complete the operation, or -1 if n/a
            
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteProgressCommand.CurrentOperation">
            <summary>
            
            Description of current operation in activity, empty if n/a
            
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteProgressCommand.ParentId">
            <summary>
            
            Identifies the parent Id of this activity, or -1 if none.
            
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteProgressCommand.Completed">
            <summary>
            
            Identifies whether the activity has completed (and the display for it should be removed),
            or if it is proceededing (and the display for it should be shown).
            
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteProgressCommand.SourceId">
            <summary>
            
            Identifies the source of the record.
            
            </summary>
            <value></value>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WriteProgressCommand.ProcessRecord">
            <summary>
            
            Writes a ProgressRecord created from the parameters.
            
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.UpdateData">
            <summary>
            This is the base class for update-typedata and update-formatdata
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.UpdateData.FileParameterSet">
            <summary>
            File parameter set name
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.UpdateData.AppendPath">
            <summary>
            Files to append to the existing set
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.UpdateData.PrependPath">
            <summary>
            Files to prepend to the existing set
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.UpdateData.Glob(System.String[],System.String,System.Management.Automation.PSCmdlet)">
            <summary>
            
            </summary>
            <param name="files"></param>
            <param name="errorId"></param>
            <param name="cmdlet"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.UpdateTypeDataCommand">
            <summary>
            This class implements update-typeData command.  
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.UpdateTypeDataCommand.MemberType">
            <summary>
            The member type of to be added
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.UpdateTypeDataCommand.MemberName">
            <summary>
            The name of the new member
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.UpdateTypeDataCommand.Value">
            <summary>
            First value of the new member. The meaning of this value
            changes according to the member type.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.UpdateTypeDataCommand.SecondValue">
            <summary>
            Second value of the new member. The meaning of this value
            changes according to the member type.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.UpdateTypeDataCommand.TypeConverter">
            <summary>
            The type converter to be added
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.UpdateTypeDataCommand.TypeAdapter">
            <summary>
            The type adapter to be added
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.UpdateTypeDataCommand.SerializationMethod">
            <summary>
            SerializationMethod
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.UpdateTypeDataCommand.TargetTypeForDeserialization">
            <summary>
            TargetTypeForDeserialization
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.UpdateTypeDataCommand.SerializationDepth">
            <summary>
            SerializationDepth
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.UpdateTypeDataCommand.DefaultDisplayProperty">
            <summary>
            DefaultDisplayProperty
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.UpdateTypeDataCommand.InheritPropertySerializationSet">
            <summary>
            InheritPropertySerializationSet
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.UpdateTypeDataCommand.StringSerializationSource">
            <summary>
            StringSerializationSource
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.UpdateTypeDataCommand.DefaultDisplayPropertySet">
            <summary>
            DefaultDisplayPropertySet
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.UpdateTypeDataCommand.DefaultKeyPropertySet">
            <summary>
            DefaultKeyPropertySet
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.UpdateTypeDataCommand.PropertySerializationSet">
            <summary>
            PropertySerializationSet
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.UpdateTypeDataCommand.TypeName">
            <summary>
            The type name we want to update on
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.UpdateTypeDataCommand.Force">
            <summary>
            True if we should overwrite a possibly existing member
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.UpdateTypeDataCommand.TypeData">
            <summary>
            The TypeData instances
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.UpdateTypeDataCommand.BeginProcessing">
            <summary>
            This method verify if the Type Table is shared and cannot be updated
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.UpdateTypeDataCommand.ProcessRecord">
            <summary>
            This method implements the ProcessRecord method for update-typeData  command
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.UpdateTypeDataCommand.EndProcessing">
            <summary>
            This method implements the EndProcessing method for update-typeData  command
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.UpdateTypeDataCommand.ProcessDynamicType">
            <summary>
            Process the dynamic type update
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.UpdateTypeDataCommand.GetMembers(System.Collections.Generic.Dictionary{System.String,System.Management.Automation.Runspaces.TypeMemberData})">
            <summary>
            Get the members for the TypeData
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.UpdateTypeDataCommand.EnsureTypeDataIsNotEmpty(System.Management.Automation.Runspaces.TypeData)">
            <summary>
            Check if the TypeData instance contains no members
            </summary>
            <param name="typeData"></param>
            <returns>false if empty, true if not</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.UpdateTypeDataCommand.NewError(System.String,System.String,System.Object,System.Object[])">
            <summary>
            Generate error record
            </summary>
            <param name="errorId"></param>
            <param name="template"></param>
            <param name="targetObject"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.UpdateFormatDataCommand">
            <summary>
            This class implements update-typeData command.  
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.UpdateFormatDataCommand.BeginProcessing">
            <summary>
            This method verify if the Format database manager is shared and cannot be updated
            </summary>   
        </member>
        <member name="M:Microsoft.PowerShell.Commands.UpdateFormatDataCommand.ProcessRecord">
            <summary>
            This method implements the ProcessRecord method for update-FormatData  command
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.RemoveTypeDataCommand">
            <summary>
            Remove-TypeData cmdlet
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemoveTypeDataCommand.TypeName">
            <summary>
            The target type to remove
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemoveTypeDataCommand.Path">
            <summary>
            The type xml file to remove from the cache
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemoveTypeDataCommand.TypeData">
            <summary>
            The TypeData to remove
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RemoveTypeDataCommand.ProcessRecord">
            <summary>
            This method implements the ProcessRecord method for Remove-TypeData command
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RemoveTypeDataCommand.EndProcessing">
            <summary>
            This method implements the EndProcessing method for Remove-TypeData command
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GetTypeDataCommand">
            <summary>
            Get-TypeData cmdlet
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetTypeDataCommand.TypeName">
            <summary>
            Get Formatting information only for the specified
            typename
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetTypeDataCommand.ProcessRecord">
            <summary>
            Takes out the content from the database and writes them
            out
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ArgumentToTypeNameTransformationAttribute">
            <summary>
            To make it easier to specify a TypeName, we add an ArgumentTransformationAttribute here.
            * string: retrun the string
            * Type: return the Type.ToString()
            * instance: return instance.GetType().ToString()
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ExportClixmlCommand">
            <summary>
            implementation for the Export-Clixml command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ExportClixmlCommand.Depth">
            <summary>
            Depth of serialization
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ExportClixmlCommand.Path">
            <summary>
            mandatory file name to write to
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ExportClixmlCommand.LiteralPath">
            <summary>
            mandatory file name to write to
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ExportClixmlCommand.InputObject">
            <summary>
            Input object to be exported
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ExportClixmlCommand.Force">
            <summary>
            Property that sets force parameter.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ExportClixmlCommand.NoClobber">
            <summary>
            Property that prevents file overwrite.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ExportClixmlCommand.Encoding">
            <summary>
            Encoding optional flag
            </summary>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ExportClixmlCommand.BeginProcessing">
            <summary>
            BeginProcessing override
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ExportClixmlCommand.ProcessRecord">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ExportClixmlCommand.EndProcessing">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ExportClixmlCommand.StopProcessing">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ExportClixmlCommand._fs">
            <summary>
            handle to file stream
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ExportClixmlCommand._xw">
            <summary>
            stream writer used to write to file
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ExportClixmlCommand._serializer">
            <summary>
            Serializer used for serialization
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ExportClixmlCommand.readOnlyFileInfo">
            <summary>
            FileInfo of file to clear read-only flag when operation is complete
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ExportClixmlCommand._disposed">
            <summary>
            Set to true when object is disposed
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ExportClixmlCommand.Dispose">
            <summary>
            public dispose method
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ImportClixmlCommand">
            <summary>
            Implements Import-Clixml command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ImportClixmlCommand.Path">
            <summary>
            mandatory file name to read from
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ImportClixmlCommand.LiteralPath">
            <summary>
            mandatory file name to read from
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ImportClixmlCommand.Dispose">
            <summary>
            public dispose method
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ImportClixmlCommand.ProcessRecord">
            <summary>
            ProcessRecord overload
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ImportClixmlCommand.StopProcessing">
            <summary>
            
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ConvertToXmlCommand">
            <summary>
            implementation for the convertto-xml command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ConvertToXmlCommand.Depth">
            <summary>
            Depth of serialization
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ConvertToXmlCommand.InputObject">
            <summary>
            Input Object which is written to XML format
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ConvertToXmlCommand.NoTypeInformation">
            <summary>
            Property that sets NoTypeInformation parameter.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ConvertToXmlCommand.As">
            <summary>
            Property that sets As parameter.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertToXmlCommand.BeginProcessing">
            <summary>
            BeginProcessing override
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertToXmlCommand.ProcessRecord">
            <summary>
            override ProcessRecord
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertToXmlCommand.EndProcessing">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertToXmlCommand.StopProcessing">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ConvertToXmlCommand._xw">
            <summary>
            XmlText writer 
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ConvertToXmlCommand._serializer">
            <summary>
            Serializer used for serialization
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ConvertToXmlCommand._ms">
             <summary>
            Memory Stream used for  serialization
             </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertToXmlCommand.CleanUp">
             <summary>
            Cleaning up the MemoryStream 
             </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ConvertToXmlCommand._disposed">
            <summary>
            Set to true when object is disposed
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertToXmlCommand.Dispose">
            <summary>
            public dispose method
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ImportXmlHelper">
            <summary>
            Helper class to import single XML file
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ImportXmlHelper._path">
            <summary>
            XML file to import
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ImportXmlHelper._cmdlet">
            <summary>
            Reference to cmdlet which is using this helper class
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ImportXmlHelper._fs">
            <summary>
            handle to file stream
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ImportXmlHelper._xr">
            <summary>
            XmlReader used to read file
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ImportXmlHelper._disposed">
            <summary>
            Set to true when object is disposed
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ImportXmlHelper.Dispose">
            <summary>
            public dispose method
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SelectXmlCommand">
            <summary>
            This cmdlet is used to search an xml document based on the XPath Query.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SelectXmlCommand.Path">
            <summary>
            Specifies the path which contains the xml files. The default is the current 
            user directory
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SelectXmlCommand.LiteralPath">
            <summary>
            Specifies the literal path which contains the xml files. The default is the current 
            user directory
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SelectXmlCommand.Xml">
            <summary>
            The following is the definition of the input parameter "XML".
            Specifies the xml Node
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SelectXmlCommand.Content">
            <summary>
            The following is the definition of the input parameter in string format.
            Specifies the string format of a fully qualified xml.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SelectXmlCommand.XPath">
            <summary>
            The following is the definition of the input parameter "Xpath".
            Specifies the String in XPath language syntax. The xml documents will be 
            searched for the nodes/values represented by this parameter.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SelectXmlCommand.Namespace">
            <summary>
            The following definition used to specify the 
            NameSpace of xml.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SelectXmlCommand.ProcessRecord">
            <summary>
            ProcessRecord method.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SelectXmlInfo">
            <summary>
            The object returned by Select-Xml representing the result of a match.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SelectXmlInfo.inputStream">
            <summary>
            If the object is InputObject, Input Stream is used.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SelectXmlInfo.Node">
            <summary>
            The XmlNode that matches search
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SelectXmlInfo.Path">
            <summary>
            The FileName from which the match is found.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SelectXmlInfo.Pattern">
            <summary>
            The pattern used to search
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SelectXmlInfo.ToString">
            <summary>
            Returns the string representation of this object. The format
            depends on whether a path has been set for this object or not.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SelectXmlInfo.ToString(System.String)">
            <summary>
            Return String representation of the object
            </summary>
            <param name="directory"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SelectXmlInfo.GetNodeText">
            <summary>
            Returns the XmlNode Value or InnerXml.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SelectXmlInfo.RelativePath(System.String)">
            <summary>
            Returns the path of the matching file truncated relative to the <paramref name="directory"/> parameter.
            <remarks>
            For example, if the matching path was c:\foo\bar\baz.c and the directory argument was c:\foo
            the routine would return bar\baz.c
            </remarks>
            </summary>
            <param name="directory">The directory base the truncation on.</param>
            <returns>The relative path that was produced.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SelectXmlInfo.FormatLine(System.String,System.String)">
            <summary>
            Formats a line for use in ToString.
            </summary>
            <param name="text"></param>
            <param name="displaypath"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ConvertToHtmlCommand">
             <summary>
            
             Class comment
            
             </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ConvertToHtmlCommand.InputObject">
            <summary>The incoming object</summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ConvertToHtmlCommand.Property">
            <summary>
            The list of properties to display
            These take the form of an MshExpression
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ConvertToHtmlCommand.Body">
            <summary>
            Text to go after the opening body tag
            and before the table
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ConvertToHtmlCommand.Head">
            <summary>
            Text to go into the head section
            of the html doc
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ConvertToHtmlCommand.Title">
            <summary>
            The string for the title tag
            The title is also placed in the body of the document
            before the table between h3 tags
            If the -Head parameter is used, this parameter has no
            effect.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ConvertToHtmlCommand.As">
            <summary>
            This specifies whether the objects should
            be rendered as an HTML TABLE or
            HTML LIST
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ConvertToHtmlCommand.CssUri">
            <summary>
            This specifies a full or partial URI
            for the CSS information.
            The html should reference the css file specified
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ConvertToHtmlCommand.Fragment">
            <summary>
            When this switch is specified generate only the
            HTML representation of the incoming object
            without the HTML,HEAD,TITLE,BODY,etc tags.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ConvertToHtmlCommand.PostContent">
            <summary>
            Specifies the text to include prior the 
            closing body tag of the HTML output
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ConvertToHtmlCommand.PreContent">
            <summary>
            Specifies the text to include after the 
            body tag of the HTML output
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ConvertToHtmlCommand.ConvertHTMLParameterDefinitionKeys">
            <summary>
            definitions for hash table keys
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ConvertToHtmlCommand.ConvertHTMLExpressionParameterDefinition">
            <summary>
            This allows for @{e='foo';label='bar';alignment='center';width='20'}
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertToHtmlCommand.ProcessParameter(System.Object[])">
            <summary>
            Create a list of MshParameter from properties
            </summary>
            <param name="properties">can be a string, ScriptBlock, or Hashtable</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertToHtmlCommand.InitializeResolvedNameMshParameters">
            <summary>
            Resolve all wildcards in user input Property into resolvedNameMshParameters
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertToHtmlCommand.SafeToString(System.Object)">
            <summary>
            calls ToString. If an exception occurs, eats it and return string.Empty
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertToHtmlCommand.BeginProcessing">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertToHtmlCommand.WriteColumns(System.Collections.Generic.List{Microsoft.PowerShell.Commands.Internal.Format.MshParameter})">
            <summary>
            Reads Width and Alignment from Property and write Col tags
            </summary>
            <param name="mshParams"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertToHtmlCommand.WriteListEntry">
            <summary>
            Writes the list entries when the As parameter has value List
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertToHtmlCommand.WritePropertyName(System.Text.StringBuilder,Microsoft.PowerShell.Commands.Internal.Format.MshParameter)">
            <summary>
            To write the Property name
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertToHtmlCommand.WritePropertyValue(System.Text.StringBuilder,Microsoft.PowerShell.Commands.Internal.Format.MshParameter)">
            <summary>
            To write the Property value
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertToHtmlCommand.WriteTableHeader(System.Text.StringBuilder,System.Collections.Generic.List{Microsoft.PowerShell.Commands.Internal.Format.MshParameter})">
            <summary>
            To write the Table header for the object property names
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertToHtmlCommand.WriteTableRow(System.Text.StringBuilder,System.Collections.Generic.List{Microsoft.PowerShell.Commands.Internal.Format.MshParameter})">
            <summary>
            To write the Table row for the object property values
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertToHtmlCommand.ProcessRecord">
            <summary>
            
            
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertToHtmlCommand.EndProcessing">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ConvertToHtmlCommand.isTHWritten">
            <summary>
            list of incoming objects to compare
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ExportPSSessionCommand">
            <summary>
            This class implements Export-PSSession cmdlet.  
            Spec: TBD
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ExportPSSessionCommand.VersionOfScriptGenerator">
            <summary>
            Version of the script generator used (by this Export-PSSession cmdlet) to generate psm1 and psd1 files.
            Generated script checks this version to see if it needs to be regenerated.  There are 2 situations where this is needed
            1. the script needs to be regenerated because a bug fix made previous versions incompatible with the rest of the system (i.e. with ObjectModelWrapper)
            2. ths script needs to be regenerated because a security vulnerability was found inside generated code (there is no way to service generated code, but we can service the dll that reports the version that the generated script checks against)
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ExportPSSessionCommand.OutputModule">
            <summary>
            Mandatory file name to write to
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ExportPSSessionCommand.Force">
            <summary>
            Property that sets force parameter.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ExportPSSessionCommand.Encoding">
            <summary>
            Encoding optional flag
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ExportPSSessionCommand.BeginProcessing">
            <summary>
            Performs initialization of cmdlet execution.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ImportPSSessionCommand">
            <summary>
            This class implements Import-PSSession cmdlet.  
            Spec: http://cmdletdesigner/SpecViewer/Default.aspx?Project=PowerShell&amp;Cmdlet=Import-Command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ImportPSSessionCommand.Prefix">
            <summary>
            This parameter specified a prefix used to modify names of imported commands
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ImportPSSessionCommand.DisableNameChecking">
            <summary>
            Disable warnings on cmdlet and function names that have non-standard verbs
            or non-standard characters in the noun.
            Also disable security related checks against command and parameter names.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ImportPSSessionCommand.BeginProcessing">
            <summary>
            Performs initialization of cmdlet execution.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ImplicitRemotingCommandBase">
            <summary>
            Base class for implicit remoting cmdlets
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ImplicitRemotingCommandBase.CommandName">
            <summary>
            Gets or sets the path(s) or name(s) of the commands to retrieve
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ImplicitRemotingCommandBase.AllowClobber">
            <summary>
            Allows shadowing and/or overwriting of existing local/client commands
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ImplicitRemotingCommandBase.ArgumentList">
            <summary>
            The parameter that all additional arguments get bound to. These arguments are used
            when retrieving dynamic parameters from cmdlets that support them.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ImplicitRemotingCommandBase.CommandType">
            <summary>
            Gets or sets the type of the command to get
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ImplicitRemotingCommandBase.Module">
            <summary>
            Gets or sets the PSSnapin parameter to the cmdlet
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ImplicitRemotingCommandBase.FullyQualifiedModule">
            <summary>
            Gets or sets the FullyQualifiedModule parameter to the cmdlet
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ImplicitRemotingCommandBase.FormatTypeName">
            <summary>
            Gets or sets the types for which we should get formatting and output data
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ImplicitRemotingCommandBase.Prefix">
            <summary>
            This parameter specified a prefix used to modify names of imported commands
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ImplicitRemotingCommandBase.Certificate">
            <summary>
            Gets or sets the certificate with which to sign the format file and psm1 file.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ImplicitRemotingCommandBase.Session">
            <summary>
            The PSSession object describing the remote runspace
            using which the specified cmdlet operation will be performed
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ImplicitRemotingCommandBase.IsCommandNameAllowedForImport(System.String)">
            <summary>
            Returns true if command doesn't shadow OR is in the -AllowShadowing parameter
            </summary>
            <param name="commandName"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ImplicitRemotingCommandBase.IsSafeNameOrIdentifier(System.String)">
            <summary>
            Validates that a name or identifier is safe to use in generated code
            (i.e. it can't be used for code injection attacks)
            </summary>
            <param name="name">name to validate</param>
            <returns><c>true</c> if the name is safe; <c>false</c> otherwise</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ImplicitRemotingCommandBase.IsSafeParameterName(System.String)">
            <summary>
            Validates that a parameter name is safe to use in generated code
            (i.e. it can't be used for code injection attacks)
            </summary>
            <param name="parameterName">parameter name to validate</param>
            <returns><c>true</c> if the name is safe; <c>false</c> otherwise</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ImplicitRemotingCommandBase.IsSafeTypeConstraint(System.Type)">
            <summary>
            Validates that a type can be safely used as a type constraint
            (i.e. it doesn't introduce any side effects on the client)
            </summary>
            <param name="type">type to validate</param>
            <returns><c>true</c> if the type is safe; <c>false</c> otherwise</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ImplicitRemotingCommandBase.IsSafeCommandMetadata(System.Management.Automation.CommandMetadata)">
            <summary>
            Validates that command metadata returned from the (potentially malicious) server is safe.
            Writes error messages if necessary.  Modifies command metadata to make it safe if necessary.
            </summary>
            <param name="commandMetadata">command metadata to verify</param>
            <returns><c>true</c> if the command metadata is safe; <c>false</c> otherwise</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ImplicitRemotingCommandBase.AddRemoteCommandMetadata(System.Collections.Generic.Dictionary{System.String,System.Management.Automation.CommandMetadata},System.Collections.Generic.Dictionary{System.String,System.String},System.Management.Automation.PSObject)">
            <summary>
            Converts remote (deserialized) CommandInfo objects into CommandMetadata equivalents
            </summary>
            <param name="name2commandMetadata">Dictionary where rehydrated CommandMetadata are going to be stored</param>
            <param name="alias2resolvedCommandName">Dictionary mapping alias names to resolved command names</param>
            <param name="remoteCommandInfo">Remote (deserialized) CommandInfo object</param>
            <returns>CommandMetadata equivalents</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ImplicitRemotingCommandBase.GetRemoteFormatData">
            <summary>
            Gets CommandMetadata objects from remote runspace
            </summary>
            <returns>(rehydrated) CommandMetadata objects</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ImplicitRemotingCommandBase.HandleHostCallReceived(System.Object,System.Management.Automation.RemoteDataEventArgs{System.Management.Automation.Remoting.RemoteHostCall})">
            <summary>
            
            </summary>
            <param name="sender"></param>
            <param name="eventArgs"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ImplicitRemotingCommandBase.GetRemoteCommandMetadata(System.Collections.Generic.Dictionary{System.String,System.String}@)">
            <summary>
            Gets CommandMetadata objects from remote runspace
            </summary>
            <returns>(rehydrated) CommandMetadata objects</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ImplicitRemotingCommandBase.GenerateProxyModule(System.IO.DirectoryInfo,System.String,System.Text.Encoding,System.Boolean,System.Collections.Generic.List{System.Management.Automation.CommandMetadata},System.Collections.Generic.Dictionary{System.String,System.String},System.Collections.Generic.List{System.Management.Automation.ExtendedTypeDefinition})">
            <summary>
            Generates a proxy module in the given directory.
            </summary>
            <param name="moduleRootDirectory">base directory for the module</param>
            <param name="moduleNamePrefix">fileName prefix for module files</param>
            <param name="encoding">encoding of generated files</param>
            <param name="force">whether to overwrite files</param>
            <param name="listOfCommandMetadata">remote commands to generate proxies for</param>
            <param name="alias2resolvedCommandName">dictionary mapping alias names to resolved command names</param>
            <param name="listOfFormatData">remote format data to generate format.ps1xml for</param>
            <returns>Paths to generated files</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ImplicitRemotingCodeGenerator.GetConnectionString">
            <summary>
            Gets a connection URI associated with the remote runspace
            </summary>
            <returns>Connection URI associated with the remote runspace</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ImplicitRemotingCodeGenerator.GenerateConnectionStringForNewRunspace">
            <summary>
            This is needed to work with Default Port DCR change from WSMan. See BUG
            542726. If http/https is specified in the connectionURI and no port is
            specified then defaults for http/https (80/443) are applied. But WSMan
            by default listens on 5985/5986. To overcome this, this function
            creates a -ComputerName parameter set or -ConnectionUri parameter
            set depending on the situation.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ImplicitRemotingCodeGenerator.GenerateProxyModule(System.IO.DirectoryInfo,System.String,System.Text.Encoding,System.Boolean,System.Collections.Generic.List{System.Management.Automation.CommandMetadata},System.Collections.Generic.Dictionary{System.String,System.String},System.Collections.Generic.List{System.Management.Automation.ExtendedTypeDefinition},System.Security.Cryptography.X509Certificates.X509Certificate2)">
            <summary>
            Generates a proxy module in the given directory.
            </summary>
            <param name="moduleRootDirectory">base directory for the module</param>
            <param name="fileNamePrefix">filename prefix for module files</param>
            <param name="encoding">encoding of generated files</param>
            <param name="force">whether to overwrite files</param>
            <param name="listOfCommandMetadata">remote commands to generate proxies for</param>
            <param name="alias2resolvedCommandName">dictionary mapping alias names to resolved command names</param>
            <param name="listOfFormatData">remote format data to generate format.ps1xml for</param>
            <param name="certificate">certificate with which to sign the format files</param>
            <returns>Path to the created files</returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.UpdateListCommand">
            <summary>
            This cmdlet updates the property of incoming objects and passes them to the 
            pipeline. This cmdlet also returns a .NET object with properties that 
            defines the update action on a list.
            
            This cmdlet is most helpful when the cmdlet author wants the user to do 
            update action on object list that are not directly exposed through 
            cmdlet parameter. One wants to update a property value which is a list 
            (multi-valued parameter for a cmdlet), without exposing the list.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.UpdateListCommand.Add">
            <summary>
            The following is the definition of the input parameter "Add".
            Objects to be add to the list
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.UpdateListCommand.Remove">
            <summary>
            The following is the definition of the input parameter "Remove".
            Objects to be removed from the list
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.UpdateListCommand.Replace">
            <summary>
            The following is the definition of the input parameter "Replace".
            Objects in this list replace the objects in the target list.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.UpdateListCommand.InputObject">
            <summary>
            The following is the definition of the input parameter "InputObject".
            List of InputObjects where the updates needs to applied to the 
            specific property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.UpdateListCommand.Property">
            <summary>
            The following is the definition of the input parameter "Property".
            Defines which property of the input object should be updated with Add and 
            Remove actions
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.UpdateListCommand.ProcessRecord">
            <summary>
            ProcessRecord method.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.UpdateListCommand.EndProcessing">
            <summary>
            EndProcessing method.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SendMailMessage">
            <summary>
            implementation for the Send-MailMessage command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SendMailMessage.Attachments">
            <summary>
            Specifies the files names to be attached to the email.
            If the filename specified can not be found, then the relevant error  
            message should be thrown.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SendMailMessage.Bcc">
            <summary>
            Specifies the address collection that contains the 
            blind carbon copy (BCC) recipients for the e-mail message.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SendMailMessage.Body">
            <summary>
            Specifies the body (content) of the message
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SendMailMessage.BodyAsHtml">
            <summary>
            Specifies a value indicating whether the mail message body is in Html.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SendMailMessage.Encoding">
            <summary>
            Specifies the encoding used for the content of the body and also the subject. 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SendMailMessage.Cc">
            <summary>
            Specifies the address collection that contains the 
            carbon copy (CC) recipients for the e-mail message.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SendMailMessage.DeliveryNotificationOption">
            <summary>
            Specifies the delivery notifications options for the e-mail message. The various 
            option available for this parameter are None, OnSuccess, OnFailure, Delay and  Never 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SendMailMessage.From">
            <summary>
            Specifies the from address for this e-mail message. The default value for 
            this parameter is the email address of the currently logged on user 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SendMailMessage.SmtpServer">
            <summary>
            Specifies the name of the Host used to send the email. This host name will be assigned  
            to the Powershell variable PSEmailServer,if this host can not reached an appropriate error 
            message will be displayed.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SendMailMessage.Priority">
            <summary>
            Specifies the priority of the email message. The valid values for this are Normal, High and Low
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SendMailMessage.Subject">
            <summary>
            Specifies the  subject of the email message.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SendMailMessage.To">
            <summary>
            Specifies the To address for this e-mail message.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SendMailMessage.Credential">
            <summary>
            Specifies the credential for this e-mail message.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SendMailMessage.UseSsl">
            <summary>
            Specifies if Secured layer is required or not
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SendMailMessage.Port">
            <summary>
            Specifies the Port to be used on <paramref name="SmtpServer"/>
            </summary>
            <remarks>
            Value must be greater than zero.
            </remarks>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SendMailMessage.AddAddressesToMailMessage(System.Object,System.String)">
            <summary>
            Add the input addresses which are either string or hashtable to the MailMessage
            It returns true if the from parameter has more than one value
            </summary>
            <param name="address"></param>
            <param name="param"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SendMailMessage.BeginProcessing">
            <summary>
            ProcessRecord override
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SendMailMessage.ProcessRecord">
            <summary>
            ProcessRecord override
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SendMailMessage.EndProcessing">
            <summary>
            EndProcessing
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ArgumentToEncodingNameTransformationAttribute">
            <summary>
            To make it easier to specify -Encoding parameter, we add an ArgumentTransformationAttribute here.
            When the input data is of type string and is valid to be converted to System.Text.Encoding, we do 
            the conversion and return the converted value. Otherwise, we just return the input data.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GetFormatDataCommand">
            <summary>
            Gets formatting information from the loading
            format information database
            </summary>
            <remarks>Currently supports only table controls
            </remarks>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetFormatDataCommand.TypeName">
            <summary>
            Get Formatting information only for the specified
            typename
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetFormatDataCommand.PowerShellVersion">
            <summary>
            When specified, helps control whether or not to send richer formatting data
            that was not supported by earlier versions of PowerShell.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetFormatDataCommand.BeginProcessing">
            <summary>
            set the default filter
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetFormatDataCommand.ProcessRecord">
            <summary>
            Takes out the content from the database and writes them
            out
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ExportFormatDataCommand">
            <summary>
            Cmdlet used to write a collection of formatting directives to
            an XML file
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ExportFormatDataCommand.InputObject">
            <summary>
            type definition to include in export
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ExportFormatDataCommand.Path">
            <summary>
            Path of the XML file
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ExportFormatDataCommand.LiteralPath">
            <summary>
            Literal path of the XML file
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ExportFormatDataCommand.Force">
            <summary>
            Force writing a file
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ExportFormatDataCommand.NoClobber">
            <summary>
            Do not overwrite file if exists
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ExportFormatDataCommand.IncludeScriptBlock">
            <summary>
            Include scriptblocks for export
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ExportFormatDataCommand.ProcessRecord">
            <summary>
            Adds the type to the collection
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ExportFormatDataCommand.EndProcessing">
            <summary>
            writes out the formatting directives from the 
            collection to the specified XML file
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.FormatListCommand">
            <summary>
            implementation for the format-table command
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.FormatListCommand.#ctor">
            <summary>
            constructor to set the inner command
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.FormatCustomCommand">
            <summary>
            implementation for the format-custom command. It just calls the formatting
            engine on complex shape
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.FormatCustomCommand.#ctor">
            <summary>
            constructor to se the inner command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.FormatCustomCommand.Property">
            <summary>
            Positional parameter for properties, property sets and table sets
            specified on the command line.
            The paramater is optional, since the defaults
            will be determined using property sets, etc.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.FormatCustomCommand.Depth">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.FormatTableCommand">
            <summary>
            implementation for the format-table command
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.FormatTableCommand.#ctor">
            <summary>
            constructor to set the inner command
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.FormatWideCommand">
            <summary>
            implementation for the format-table command
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.FormatWideCommand.#ctor">
            <summary>
            constructor to se the inner command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.FormatWideCommand.Property">
            <summary>
            Positional parameter for properties, property sets and table sets
            specified on the command line.
            The paramater is optional, since the defaults
            will be determined using property sets, etc.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.FormatWideCommand.AutoSize">
            <summary>
            optional, non positional parameter
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.FormatWideCommand.Column">
            <summary>
            optional, non positional parameter
            </summary>
            <value></value>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.OutFileCommand">
            <summary>
            implementation for the out-file command
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.OutFileCommand.#ctor">
            <summary>
            set inner command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.OutFileCommand.FilePath">
            <summary>
            mandatory file name to write to
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.OutFileCommand.LiteralPath">
            <summary>
            mandatory file name to write to
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.OutFileCommand.Encoding">
            <summary>
            Encoding optional flag
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.OutFileCommand.Append">
            <summary>
            Property that sets append parameter.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.OutFileCommand.Force">
            <summary>
            Property that sets force parameter.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.OutFileCommand.NoClobber">
            <summary>
            Property that prevents file overwrite.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.OutFileCommand.Width">
            <summary>
            optional, number of columns to use when writing to device
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.OutFileCommand.NoNewline">
            <summary>
            False to add a newline to the end of the output string, true if not.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.OutFileCommand.BeginProcessing">
            <summary>
            read command line parameters
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.OutFileCommand.InstantiateLineOutputInterface">
            <summary>
            one time initialization: acquire a screen host interface
            by creating one on top of a file
            NOTICE: we assume that at this time the file name is
            available in the CRO. JonN recommends: file name has to be
            a MANDATORY parameter on the command line
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.OutFileCommand.ProcessRecord">
            <summary>
            execution entry point
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.OutFileCommand.EndProcessing">
            <summary>
            execution entry point
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.OutFileCommand.InternalDispose">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OutFileCommand.fs">
            <summary>
            handle to file stream
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OutFileCommand.sw">
            <summary>
            stream writer used to write to file
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OutFileCommand.processRecordExecuted">
            <summary>
            indicate whether the ProcessRecord method was executed.
            When the Out-File is used in a redirection pipelineProcessor,
            its ProcessRecord method may not be called when nothing is written to the 
            output pipe, for example:
                Write-Error error > test.txt
            In this case, the EndProcess method should return immediately as if it's 
            never been called.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OutFileCommand.readOnlyFileInfo">
            <summary>
            FileInfo of file to clear read-only flag when operation is complete
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.OutStringCommand">
            <summary>
            implementation for the out-string command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.OutStringCommand.Stream">
            <summary>
            optional, non positional parameter to specify the
            streaming behavior
            FALSE: accumulate all the data, then write a single string
            TRUE: write one line at the time
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.OutStringCommand.Width">
            <summary>
            optional, number of columns to use when writing to device
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.OutStringCommand.#ctor">
            <summary>
            set inner command
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.OutStringCommand.BeginProcessing">
            <summary>
            read command line parameters
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.OutStringCommand.InstantiateLineOutputInterface">
            <summary>
            one time initialization: acquire a screen host interface
            by creating one on top of a stream
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.OutStringCommand.OnWriteLine(System.String)">
            <summary>
            callback to add lines to the buffer or to write them to
            the output stream
            </summary>
            <param name="s"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.OutStringCommand.ProcessRecord">
            <summary>
            execution entry point
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.OutStringCommand.EndProcessing">
            <summary>
            execution entry point
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OutStringCommand.writer">
            <summary>
            writer used by the LineOutput
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OutStringCommand.buffer">
            <summary>
             buffer used when buffering until the end
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.Internal.Format.PrinterLineOutput">
            <summary>
            Implementation of the LineOutput interface for printer
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.Internal.Format.PrinterLineOutput.RequiresBuffering">
            <summary>
            full buffering for printer
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.Internal.Format.PrinterLineOutput.ExecuteBufferPlayBack(Microsoft.PowerShell.Commands.Internal.Format.LineOutput.DoPlayBackCall)">
            <summary>
            do the printing on playback
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.Internal.Format.PrinterLineOutput.ColumnNumber">
            <summary>
            the # of columns for the printer
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.Internal.Format.PrinterLineOutput.RowNumber">
            <summary>
            the # of rows for the printer
            </summary>
            <value></value>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.Internal.Format.PrinterLineOutput.WriteLine(System.String)">
            <summary>
            write a line to the output device
            </summary>
            <param name="s">line to write</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.Internal.Format.PrinterLineOutput.#cctor">
            <summary>
            Used for static initializations like DefaultPrintFontName
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.Internal.Format.PrinterLineOutput.#ctor(System.String)">
            <summary>
            constructor for the class
            </summary>
            <param name="printerName">name of printer, if null use default printer</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.Internal.Format.PrinterLineOutput.OnWriteLine(System.String)">
            <summary>
            callback to be called when IConsole.WriteLine() is called by WriteLineHelper 
            </summary>
            <param name="s">string to write</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.Internal.Format.PrinterLineOutput.OnWrite(System.String)">
            <summary>
            callback to be called when Console.Write() is called by WriteLineHelper
            This is called when the WriteLineHelper needs to write a line whose length
            is the same as the width of the screen buffer
            </summary>
            <param name="s">string to write</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.Internal.Format.PrinterLineOutput.DoPrint">
            <summary>
            do the printing
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.Internal.Format.PrinterLineOutput.CreateFont(System.Drawing.Graphics)">
            <summary>
            helper to create a font. 
            If the font object exists, it does nothing.
            Else, the a new object is created and verified
            </summary>
            <param name="g">GDI+ graphics object needed for verification</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.Internal.Format.PrinterLineOutput.VerifyFont(System.Drawing.Graphics)">
            <summary>
            internal helper to verify that the font is fixed pitch. If the test fails,
            it reverts to the default font
            </summary>
            <param name="g">GDI+ graphics object needed for verification</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.Internal.Format.PrinterLineOutput.pd_PrintPage(System.Object,System.Drawing.Printing.PrintPageEventArgs)">
            <summary>
            Event fired for each page to print 
            </summary>
            <param name="sender">sender, not used</param>
            <param name="ev">print page event</param>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.Internal.Format.PrinterLineOutput.printingInitalized">
            <summary>
            flag for one time initialization of the interface (columns, etc.)
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.Internal.Format.PrinterLineOutput.playbackCall">
            <summary>
            callback to ask the outputter to playback its cache
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.Internal.Format.PrinterLineOutput.printerName">
            <summary>
            name of the printer to print to. Null means default printer
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.Internal.Format.PrinterLineOutput.printFontName">
            <summary>
            name of the font to use, if null the default is used
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.Internal.Format.PrinterLineOutput.printFontSize">
            <summary>
            font size
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.Internal.Format.PrinterLineOutput.DefaultPrintFontName">
            <summary>
            default font, used if the printFont is not specified or if the
            printFont is not fixed pitch. 
            </summary>
            <remarks>
            This default must be loaded from a resource file as different
            cultures will have different defaults and the localizer would
            know the default for different cultures.
            </remarks>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.Internal.Format.PrinterLineOutput.DefaultPrintFontSize">
            <summary>
            default size for the default font
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.Internal.Format.PrinterLineOutput.deviceColumns">
            <summary>
            number of columns on the sheet
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.Internal.Format.PrinterLineOutput.lines">
            <summary>
            text lines ready to print (after output cache playback)
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.Internal.Format.PrinterLineOutput.printFont">
            <summary>
            cached font object
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.OutPrinterCommand">
            <summary>
            implementation for the out-printer command
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.OutPrinterCommand.#ctor">
            <summary>
            set inner command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.OutPrinterCommand.Name">
            <summary>
            optional name of the printer to print to
            The alias allows "lp -P printer"
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.OutPrinterCommand.BeginProcessing">
            <summary>
            read command line parameters
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.OutPrinterCommand.InstantiateLineOutputInterface">
            <summary>
            one time initialization: acquire a screen host interface
            by creating one on top of a memory buffer
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ColumnInfo.LimitString(System.Object)">
            <summary>
            Auxiliar used in GetValue methods since the list does not deal well with unlimited sized lines
            </summary>
            <param name="src">source string</param>
            <returns>the source string limited in the number of lines</returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.OutputModeOption">
            <summary>
            Enum for SelectionMode parameter.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OutputModeOption.None">
            <summary>
            None is the default and it means OK and Cancel will not be present
            and no objects will be written to the pipeline.
            The selectionMode of the actual list will still be multiple
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OutputModeOption.Single">
            <summary>
            Allow selection of one sinlge item to be written to the pipeline.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OutputModeOption.Multiple">
             <summary>
            Allow select of multiple items to be written to the pipeline.
             </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.OutGridViewCommand">
            <summary>
            Implementation for the Out-GridView command
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.OutGridViewCommand.#ctor">
            <summary>
            Constructor for OutGridView
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.OutGridViewCommand.InputObject">
            <summary>
            This parameter specifies the current pipeline object 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.OutGridViewCommand.Title">
            <summary>
            Gets/sets the title of the Out-GridView window.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OutGridViewCommand.wait">
            <summary>
            Field used for the Block parameter.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.OutGridViewCommand.Wait">
            <summary>
            Get or sets a value indicating whether the cmdlet should wait for the window to be closed
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OutGridViewCommand.outputMode">
            <summary>
            Field used for the OutputMode parameter.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.OutGridViewCommand.OutputMode">
            <summary>
            Get or sets a value indicating whether the selected items should be written to the pipeline
            and if it should be possible to select multiple or single list items
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.OutGridViewCommand.PassThru">
            <summary>
            Gets or sets a value indicating whether the selected items should be written to the pipeline
            Setting this to true is the same as setting the OutputMode to Multiple
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.OutGridViewCommand.BeginProcessing">
            <summary>
            Provides a one-time, pre-processing functionality for the cmdlet.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.OutGridViewCommand.EndProcessing">
            <summary>
            Blocks depending on the wait and selected 
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.OutGridViewCommand.ProcessRecord">
            <summary>
            Provides a record-by-record processing functionality for the cmdlet.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.OutGridViewCommand.StopProcessing">
            <summary>
            StopProcessing is called close the window when Ctrl+C in the command prompt.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.OutGridViewCommand.ConvertToString(System.Management.Automation.PSObject)">
            <summary>
            Converts the provided PSObject to a string preserving PowerShell formatting.
            </summary>
            <param name="liveObject">PSObject to be converted to a string.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.OutGridViewCommand.ProcessObject(System.Management.Automation.PSObject)">
            <summary>
            Execute formatting on a single object
            </summary>
            <param name="input">object to process</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.OutGridViewCommand.Dispose(System.Boolean)">
            <summary>
            Implements IDisposable logic
            </summary>
            <param name="isDisposing">true if being called from Dispose</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.OutGridViewCommand.Dispose">
            <summary>
            Dispose method in IDisposeable
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.OutGridViewCommand.Finalize">
            <summary>
            Finalizer
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OutWindowProxy.headerInfo">
            <summary> Columns definition of the underlying Management List</summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.OutWindowProxy.#ctor(System.String,Microsoft.PowerShell.Commands.OutputModeOption,Microsoft.PowerShell.Commands.OutGridViewCommand)">
            <summary>
            Initializes a new instance of the OutWindowProxy class.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.OutWindowProxy.AddColumns(System.String[],System.String[],System.Type[])">
            <summary>
            Adds columns to the output window.
            </summary>
            <param name="propertyNames">An array of property names to add.</param>
            <param name="displayNames">An array of display names to add.</param>
            <param name="types">An array of types to add.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.OutWindowProxy.AddItem(System.Management.Automation.PSObject)">
            <summary>
            Adds an item to the out window.
            </summary>
            <param name="livePSObject">
            The item to add.
            </param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.OutWindowProxy.AddHeteroViewItem(System.Management.Automation.PSObject)">
            <summary>
            Adds an item to the out window.
            </summary>
            <param name="livePSObject">
            The item to add.
            </param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.OutWindowProxy.ShowWindow">
            <summary>
            Shows the out window if it has not already been displayed.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.OutWindowProxy.Dispose(System.Boolean)">
            <summary>
            Implements IDisposable logic
            </summary>
            <param name="isDisposing">true if being called from Dispose</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.OutWindowProxy.Dispose">
            <summary>
            Dispose method in IDisposeable
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.OutWindowProxy.CloseWindow">
            <summary>
            Close the window if it has already been displayed.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.OutWindowProxy.IsWindowClosed">
            <summary>
            Gets a value indicating whether the out window is closed.
            </summary>
            <returns>
            True if the out window is closed, false otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.OutWindowProxy.GetLastException">
            <summary>Returns any exception that has been thrown by previous method calls.</summary>
            <returns>The thrown and caught exception. It returns null if no exceptions were thrown by any previous method calls.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.OutWindowProxy.GetSelectedItems">
            <summary>
            Return the selected item of the OutGridView.
            </summary>
            <returns>
            The selected item
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.TableView.FilterActiveAssociationList(System.Collections.Generic.List{Microsoft.PowerShell.Commands.Internal.Format.MshResolvedExpressionParameterAssociation})">
            <summary>
            Method to filter resolved expressions as per table view needs.
            For v1.0, table view supports only 10 properties.
            
            This method filters and updates "activeAssociationList" instance property.
            </summary>
            <returns>None.</returns>
            <remarks>This method updates "activeAssociationList" instance property.</remarks>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ConvertFromJsonCommand">
            <summary>
            The ConvertFrom-Json command
            This command convert a Json string representation to a JsonObject
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ConvertFromJsonCommand.InputObject">
            <summary>
            gets or sets the InputString property
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ConvertFromJsonCommand.inputObjectBuffer">
            <summary>
            inputObjectBuffer buffers all InputObjet contents avaliable in the pipeline.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertFromJsonCommand.BeginProcessing">
            <summary>
            Prerequisite checks
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertFromJsonCommand.ProcessRecord">
            <summary>
            Buffers InputObjet contents avaliable in the pipeline.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertFromJsonCommand.EndProcessing">
            <summary>
            the main execution method for the convertfrom-json command
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertFromJsonCommand.ConvertFromJsonHelper(System.String)">
            <summary>
            ConvertFromJsonHelper is a helper method to convert to Json input to .Net Type.
            </summary>
            <param name="input">Input String.</param>
            <returns>True if successfully converted, else returns false.</returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ConvertToJsonCommand">
            <summary>
            The ConvertTo-Json command
            This command convert an object to a Json string representation
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ConvertToJsonCommand.InputObject">
            <summary>
            gets or sets the InputObject property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ConvertToJsonCommand.Depth">
            <summary>
            gets or sets the Depth property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ConvertToJsonCommand.Compress">
            <summary>
            gets or sets the Compress property.
            If the Compress property is set to be true, the Json string will
            be output in the compressed way. Otherwise, the Json string will
            be output with indentations.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertToJsonCommand.BeginProcessing">
            <summary>
            Prerequisite checks
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertToJsonCommand.ProcessRecord">
            <summary>
            Caching the input objects for the convertto-json command
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertToJsonCommand.EndProcessing">
            <summary>
            Do the conversion to json and write output
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertToJsonCommand.ConvertToPrettyJsonString(System.String)">
            <summary>
            Convert the Json string to a more readable format
            </summary>
            <param name="json"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertToJsonCommand.ConvertList(System.String,System.Int32,System.Text.StringBuilder,System.String,System.Int32)">
            <summary>
            Convert a Json List, which starts with '['.
            </summary>
            <param name="json"></param>
            <param name="index"></param>
            <param name="result"></param>
            <param name="padString"></param>
            <param name="numberOfSpaces"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertToJsonCommand.ConvertQuotedString(System.String,System.Int32,System.Text.StringBuilder)">
            <summary>
            Convert the quoted string.
            </summary>
            <param name="json"></param>
            <param name="index"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertToJsonCommand.ConvertDictionary(System.String,System.Int32,System.Text.StringBuilder,System.String,System.Int32)">
            <summary>
            Convert a Json dictionary, which starts with '{'.
            </summary>
            <param name="json"></param>
            <param name="index"></param>
            <param name="result"></param>
            <param name="padString"></param>
            <param name="numberOfSpaces"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertToJsonCommand.AddIndentations(System.Int32,System.Text.StringBuilder)">
            <summary>
            Add tabs to result
            </summary>
            <param name="numberOfTabsToReturn"></param>
            <param name="result"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertToJsonCommand.AddSpaces(System.Int32,System.Text.StringBuilder)">
            <summary>
            Add spaces to result
            </summary>
            <param name="numberOfSpacesToReturn"></param>
            <param name="result"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertToJsonCommand.ProcessValue(System.Object,System.Int32)">
            <summary>
            Return an alternate representation of the specified object that serializes the same JSON, except 
            that properties that cannot be evaluated are treated as having the value null.
            
            Primitive types are returned verbatim.  Aggregate types are processed recursively.
            </summary>
            <param name="obj">The object to be processed</param>
            <param name="depth">The current depth into the object graph</param>
            <returns>An object suitable for serializing to JSON</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertToJsonCommand.AddPsProperties(System.Object,System.Object,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Add to a base object any properties that might have been added to an object (via PSObject) through the Add-Member cmdlet.
            </summary>
            <param name="psobj">The containing PSObject, or null if the base object was not contained in a PSObject</param>
            <param name="obj">The base object that might have been decorated with additional properties</param>
            <param name="depth">The current depth into the object graph</param>
            <param name="isPurePSObj">the processed object is a pure PSObject</param>
            <param name="isCustomObj">the processed object is a custom object</param>
            <returns>
            The original base object if no additional properties had been added,
            otherwise a dictionary containing the value of the original base object in the "value" key
            as well as the names and values of an additional properties.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertToJsonCommand.AppendPsProperties(System.Management.Automation.PSObject,System.Collections.IDictionary,System.Int32,System.Boolean)">
            <summary>
            Append to a dictionary any properties that might have been added to an object (via PSObject) through the Add-Member cmdlet.
            If the passed in object is a custom object (not a simple object, not a dictionary, not a list, get processed in ProcessCustomObject method),
            we also take Adapted properties into account. Otherwise, we only consider the Extended properties.
            When the object is a pure PSObject, it also gets processed in "ProcessCustomObject" before reaching this method, so we will
            iterate both extended and adapted proerpties for it. Since it's a pure PSObject, there will be no adapted properties.
            </summary>
            <param name="psobj">The containing PSObject, or null if the base object was not contained in a PSObject</param>
            <param name="receiver">The dictionary to which any additional properties will be appended</param>
            <param name="depth">The current depth into the object graph</param>
            <param name="isCustomObject">The processed object is a custom object</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertToJsonCommand.ProcessDictionary(System.Collections.IDictionary,System.Int32)">
            <summary>
            Return an alternate representation of the specified dictionary that serializes the same JSON, except 
            that any contained properties that cannot be evaluated are treated as having the value null.
            </summary>
            <param name="dict"></param>
            <param name="depth"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertToJsonCommand.ProcessEnumerable(System.Collections.IEnumerable,System.Int32)">
            <summary>
            Return an alternate representation of the specified collection that serializes the same JSON, except 
            that any contained properties that cannot be evaluated are treated as having the value null.
            </summary>
            <param name="enumerable"></param>
            <param name="depth"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertToJsonCommand.ProcessCustomObject``1(System.Object,System.Int32)">
            <summary>
            Return an alternate representation of the specified aggregate object that serializes the same JSON, except 
            that any contained properties that cannot be evaluated are treated as having the value null.
            
            The result is a dictionary in which all public fields and public gettable properties of the original object
            are represented.  If any exception occurs while retrieving the value of a field or property, that entity
            is included in the output dictionary with a value of null.
            </summary>
            <param name="o"></param>
            <param name="depth"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.FormObject">
            <summary>
            FormObject used in HtmlWebResponseObject
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.FormObject.Id">
            <summary>
            gets or private sets the Id property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.FormObject.Method">
            <summary>
            gets or private sets the Method property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.FormObject.Action">
            <summary>
            gets or private sets the Action property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.FormObject.Fields">
            <summary>
            gets or private sets the Fields property
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.FormObject.#ctor(System.String,System.String,System.String)">
            <summary>
            constructor for FormObject
            </summary>
            <param name="id"></param>
            <param name="method"></param>
            <param name="action"></param>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.FormObjectCollection">
            <summary>
            FormObjectColletion used in HtmlWebResponseObject
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.FormObjectCollection.Item(System.String)">
            <summary>
            Gets the FormObject from the key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.JsonObject">
            <summary>
            JsonObject class
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.JsonObject.ConvertFromJson(System.String,System.Management.Automation.ErrorRecord@)">
            <summary>
            Convert a Json string back to an object
            </summary>
            <param name="input"></param>
            <param name="error"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.PSUserAgent">
            <summary>
            Construct the Useragent string
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.PSUserAgent.InternetExplorer">
            <summary>
            Useragent string for InternetExplorer (9.0)
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.PSUserAgent.FireFox">
            <summary>
            Useragent string for Firefox (4.0)
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.PSUserAgent.Chrome">
            <summary>
            Useragent string for Chrome (7.0)
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.PSUserAgent.Opera">
            <summary>
            Useragent string for Opera (9.0)
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.PSUserAgent.Safari">
            <summary>
            Useragent string for Safari (5.0)
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.WebResponseContentMemoryStream">
            <summary>
            Microsoft.PowerShell.Commands.WebResponse has a public property RawContentStream
            which is of type MemoryStream. We shipped like that in PowerShell 3. Creating
            this class as a wrapper to MemoryStream to lazily initialize. Otherwise, the 
            content will unnecessarily be read even if there are no consumers for it.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WebResponseContentMemoryStream.#ctor(System.IO.Stream,System.Int32,System.Management.Automation.Cmdlet)">
            <summary>
            
            </summary>
            <param name="stream"></param>
            <param name="initialCapacity"></param>
            <param name="cmdlet">Owner cmdlet if any</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebResponseContentMemoryStream.CanRead">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebResponseContentMemoryStream.CanSeek">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebResponseContentMemoryStream.CanTimeout">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebResponseContentMemoryStream.CanWrite">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebResponseContentMemoryStream.Length">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WebResponseContentMemoryStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
            <summary>
            
            </summary>
            <param name="destination"></param>
            <param name="bufferSize"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WebResponseContentMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WebResponseContentMemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WebResponseContentMemoryStream.ReadByte">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WebResponseContentMemoryStream.SetLength(System.Int64)">
            <summary>
            
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WebResponseContentMemoryStream.ToArray">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WebResponseContentMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WebResponseContentMemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WebResponseContentMemoryStream.WriteByte(System.Byte)">
            <summary>
            
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WebResponseContentMemoryStream.WriteTo(System.IO.Stream)">
            <summary>
            
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WebResponseContentMemoryStream.Dispose(System.Boolean)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WebResponseContentMemoryStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WebResponseContentMemoryStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WebResponseContentMemoryStream.GetBuffer">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WebResponseContentMemoryStream.Close">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WebResponseContentMemoryStream.Initialize">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StreamHelper.SaveStreamToFile(System.IO.Stream,System.String,System.Management.Automation.PSCmdlet)">
            <summary>
            Saves content from stream into filePath.
            Caller need to ensure <paramref name="stream"/> postion is properly set.
            </summary>
            <param name="stream"></param>
            <param name="filePath"></param>
            <param name="cmdlet"></param>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.WebCmdletElementCollection">
            <summary>
            WebCmdletElementCollection for elements in html web responses
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WebCmdletElementCollection.Find(System.String)">
            <summary>
            Finds the element with name or id
            </summary>
            <param name="nameOrId"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WebCmdletElementCollection.FindById(System.String)">
            <summary>
            Finds the element by id
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WebCmdletElementCollection.FindByName(System.String)">
            <summary>
            Finds the element by name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.WebRequestMethod">
            <summary>
            enums for web request method.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WebRequestMethod.Default">
            <summary>
            Default method
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WebRequestMethod.Get">
            <summary>
            GET method
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WebRequestMethod.Head">
            <summary>
            HEAD method
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WebRequestMethod.Post">
            <summary>
            POST method
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WebRequestMethod.Put">
            <summary>
            PUT method
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WebRequestMethod.Delete">
            <summary>
            DELETE method
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WebRequestMethod.Trace">
            <summary>
            TRACE method
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WebRequestMethod.Options">
            <summary>
            OPTIONS method
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WebRequestMethod.Merge">
            <summary>
            MERGE method
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WebRequestMethod.Patch">
            <summary>
            PATCH method
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.WebRequestSession">
            <summary>
            WebRequestSession for holding session infos.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebRequestSession.Headers">
            <summary>
            gets or sets the Header property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebRequestSession.Cookies">
            <summary>
            gets or sets the Cookies property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebRequestSession.UseDefaultCredentials">
            <summary>
            gets or sets the UseDefaultCredentials property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebRequestSession.Credentials">
            <summary>
            gets or sets the Credentials property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebRequestSession.Certificates">
            <summary>
            gets or sets the Certificates property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebRequestSession.UserAgent">
            <summary>
            gets or sets the UserAgent property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebRequestSession.Proxy">
            <summary>
            gets or sets the Proxy property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebRequestSession.MaximumRedirection">
            <summary>
            gets or sets the RedirectMax property
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WebRequestSession.#ctor">
            <summary>
            Construct a new instance of a WebRequestSession object.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WebRequestSession.AddCertificate(System.Security.Cryptography.X509Certificates.X509Certificate)">
            <summary>
            Add a X509Certificate to the Certificates collection.
            </summary>
            <param name="certificate">The certificate to be added.</param>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.BasicHtmlWebResponseObject">
            <summary>
            Response object for html content without DOM parsing
            </summary>
            <summary>
            Response object for html content without DOM parsing
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.BasicHtmlWebResponseObject.Content">
            <summary>
            gets or protected sets the Content property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.BasicHtmlWebResponseObject.InputFields">
            <summary>
            gets the Fields property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.BasicHtmlWebResponseObject.Links">
            <summary>
            gets the Links property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.BasicHtmlWebResponseObject.Images">
            <summary>
            gets the Images property
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.BasicHtmlWebResponseObject.InitializeContent">
            <summary>
            Reads the response content from the web response.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.BasicHtmlWebResponseObject.#ctor(System.Net.WebResponse)">
            <summary>
            Constructor for HtmlWebResponseObject
            </summary>
            <param name="response"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.BasicHtmlWebResponseObject.#ctor(System.Net.WebResponse,System.IO.Stream)">
            <summary>
            Constructor for HtmlWebResponseObject with memory stream
            </summary>
            <param name="response"></param>
            <param name="contentStream"></param>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.HtmlWebResponseObject">
            <summary>
            Response object for html content
            </summary>
            <summary>
            Response object for html content
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.HtmlWebResponseObject.Content">
            <summary>
            gets or protected sets the Content property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.HtmlWebResponseObject.ParsedHtml">
            <summary>
            gets the ParsedHtml property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.HtmlWebResponseObject.Forms">
            <summary>
            gets the Forms property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.HtmlWebResponseObject.InputFields">
            <summary>
            gets the Fields property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.HtmlWebResponseObject.Links">
            <summary>
            gets the Links property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.HtmlWebResponseObject.Images">
            <summary>
            gets the Images property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.HtmlWebResponseObject.Scripts">
            <summary>
            gets the Scripts property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.HtmlWebResponseObject.AllElements">
            <summary>
            gets the Elements property
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.HtmlWebResponseObject.InitializeContent">
            <summary>
            Reads the response content from the web response.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.HtmlWebResponseObject.Dispose">
            <summary>
            Dispose the the instance of the class.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.HtmlWebResponseObject.Finalize">
            <summary>
            Finalizer to free the COM objects.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.HtmlWebResponseObject.#ctor(System.Net.WebResponse,System.Management.Automation.ExecutionContext)">
            <summary>
            Constructor for HtmlWebResponseObject
            </summary>
            <param name="response"></param>
            <param name="executionContext"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.HtmlWebResponseObject.#ctor(System.Net.WebResponse,System.IO.Stream,System.Management.Automation.ExecutionContext)">
            <summary>
            Constructor for HtmlWebResponseObject with memory stream
            </summary>
            <param name="response"></param>
            <param name="contentStream"></param>        
            <param name="executionContext"></param>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.InvokeRestMethodCommand">
            <summary>
            The Invoke-RestMethod command
            This command makes an HTTP or HTTPS request to a web service,
            and returns the response in an appropriate way. 
            Intended to work against the wide spectrum of "RESTful" web services 
            currently deployed across the web.  
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.InvokeRestMethodCommand.Method">
            <summary>
            gets or sets the parameter Method 
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.InvokeRestMethodCommand.RestReturnType">
            <summary>
            enum for rest return type.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.InvokeRestMethodCommand.RestReturnType.Detect">
            <summary>
            Return type not defined in reponse, 
            best effort detect
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.InvokeRestMethodCommand.RestReturnType.Json">
            <summary>
            Json return type
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.InvokeRestMethodCommand.RestReturnType.Xml">
            <summary>
            Xml return type
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.InvokeRestMethodCommand.ProcessResponse(System.Net.WebResponse)">
            <summary>
            Process the web reponse and output corresponding objects. 
            </summary>
            <param name="response"></param>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.WebRequestPSCmdlet">
            <summary>
            Base class for Invoke-RestMethod and Invoke-WebRequest commands.
            </summary>
            <summary>
            Base class for Invoke-RestMethod and Invoke-WebRequest commands.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebRequestPSCmdlet.UseBasicParsing">
            <summary>
            gets or sets the parameter UseBasicParsing 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebRequestPSCmdlet.Uri">
            <summary>
            gets or sets the Uri property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebRequestPSCmdlet.WebSession">
            <summary>
            gets or sets the Session property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebRequestPSCmdlet.SessionVariable">
            <summary>
            gets or sets the SessionVariable property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebRequestPSCmdlet.Credential">
            <summary>
            gets or sets the Credential property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebRequestPSCmdlet.UseDefaultCredentials">
            <summary>
            gets or sets the UseDefaultCredentials property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebRequestPSCmdlet.CertificateThumbprint">
            <summary>
            gets or sets the CertificateThumbprint property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebRequestPSCmdlet.Certificate">
            <summary>
            gets or sets the Certificate property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebRequestPSCmdlet.UserAgent">
            <summary>
            gets or sets the UserAgent property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebRequestPSCmdlet.DisableKeepAlive">
            <summary>
            gets or sets the DisableKeepAlive property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebRequestPSCmdlet.TimeoutSec">
            <summary>
            gets or sets the TimeOut property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebRequestPSCmdlet.Headers">
            <summary>
            gets or sets the Headers property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebRequestPSCmdlet.MaximumRedirection">
            <summary>
            gets or sets the RedirectMax property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebRequestPSCmdlet.Method">
            <summary>
            gets or sets the Method property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebRequestPSCmdlet.Proxy">
            <summary>
            gets or sets the Proxy property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebRequestPSCmdlet.ProxyCredential">
            <summary>
            gets or sets the ProxyCredential property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebRequestPSCmdlet.ProxyUseDefaultCredentials">
            <summary>
            gets or sets the ProxyUseDefaultCredentials property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebRequestPSCmdlet.Body">
            <summary>
            gets or sets the Body property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebRequestPSCmdlet.ContentType">
            <summary>
            gets or sets the ContentType property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebRequestPSCmdlet.TransferEncoding">
            <summary>
            gets or sets the TransferEncoding property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebRequestPSCmdlet.InFile">
            <summary>
            gets or sets the InFile property
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WebRequestPSCmdlet._originalFilePath">
            <summary>
            keep the original file path after the resolved provider path is
            assigned to InFile
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebRequestPSCmdlet.OutFile">
            <summary>
            gets or sets the OutFile property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebRequestPSCmdlet.PassThru">
            <summary>
            gets or sets the PassThrough property
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WebRequestPSCmdlet.VerifyInternetExplorerAvailable(System.Boolean)">
            <summary>
            Verifies that Internet Explorer is available, and that its first-run
            configuration is complete.
            </summary>
            <param name="checkComObject">True if we should try to access IE's COM object. Not
            needed if an HtmlDocument will be created shortly.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WebRequestPSCmdlet.ProcessResponse(System.Net.WebResponse)">
            <summary>
            Read the supplied WebResponse object and push the 
            resulting output into the pipeline.
            </summary>
            <param name="response">Instance of a WebResponse object to be processed</param>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WebRequestPSCmdlet._webRequest">
            <summary>
            the WebRequest we will GetResponse for.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WebRequestPSCmdlet.ProcessRecord">
            <summary>
            the main execution method for cmdlets derived from WebRequestPSCmdlet. 
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WebRequestPSCmdlet.StopProcessing">
            <summary>
            Implementing ^C, after start the BeginGetResponse
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WebRequestPSCmdlet.ResponseCallback(System.IAsyncResult)">
            <summary>
            Call back method for BeginGetResponse
            </summary>
            <param name="asyncResult"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WebRequestPSCmdlet.TimeoutCallback(System.Object,System.Boolean)">
            <summary>
            Call back method for timeout
            </summary>
            <param name="state"></param>
            <param name="timeout"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WebRequestPSCmdlet.SetRequestContent(System.Net.WebRequest,System.Byte[])">
            <summary>
            Sets the ContentLength property of the request and writes the specified content to the request's RequestStream.
            </summary>
            <param name="request">The WebRequest who's content is to be set</param>
            <param name="content">A byte array containing the content data.</param>
            <returns>The number of bytes written to the requests RequestStream (and the new value of the request's ContentLength property</returns>
            <remarks>
            Because this function sets the request's ContentLength property and writes content data into the requests's stream,
            it should be called one time maximum on a given request.
            </remarks>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WebRequestPSCmdlet.SetRequestContent(System.Net.WebRequest,System.String)">
            <summary>
            Sets the ContentLength property of the request and writes the specified content to the request's RequestStream.
            </summary>
            <param name="request">The WebRequest who's content is to be set</param>
            <param name="content">A String object containing the content data.</param>
            <returns>The number of bytes written to the requests RequestStream (and the new value of the request's ContentLength property</returns>
            <remarks>
            Because this function sets the request's ContentLength property and writes content data into the requests's stream,
            it should be called one time maximum on a given request.
            </remarks>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WebRequestPSCmdlet.SetRequestContent(System.Net.WebRequest,System.IO.Stream)">
            <summary>
            Sets the ContentLength property of the request and writes the specified content to the request's RequestStream.
            </summary>
            <param name="request">The WebRequest who's content is to be set</param>
            <param name="contentStream">A Stream object containing the content data.</param>
            <returns>The number of bytes written to the requests RequestStream (and the new value of the request's ContentLength property</returns>
            <remarks>
            Because this function sets the request's ContentLength property and writes content data into the requests's stream,
            it should be called one time maximum on a given request.
            </remarks>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.WebRequestPSCmdlet.WebRequestState">
            <summary>
            The web request state is used when place asynchronous call to get response of a web request.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.WebRequestPSCmdlet.TimeoutState">
            <summary>
            The timeout state is used when the request is a http request and need to timeout
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.WebResponseObject">
            <summary>
            WebResponseObject
            </summary>
            <summary>
            WebResponseObject
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebResponseObject.Content">
            <summary>
            gets or protected sets the Content property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebResponseObject.StatusCode">
            <summary>
            gets the StatusCode property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebResponseObject.StatusDescription">
            <summary>
            gets the StatusDescription property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebResponseObject.RawContentStream">
            <summary>
            gets the RawContentStream property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebResponseObject.RawContentLength">
            <summary>
            gets the RawContentLength property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebResponseObject.RawContent">
            <summary>
            gets or protected sets the RawContent property
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WebResponseObject.InitializeContent">
            <summary>
            Reads the response content from the web response.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WebResponseObject.ToString">
            <summary>
            Returns the string representation of this web response.
            </summary>
            <returns>The string representation of this web response.</returns>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebResponseObject.BaseResponse">
            <summary>
            gets or sets the BaseResponse property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WebResponseObject.Headers">
            <summary>
            gets the Headers property
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WebResponseObject.#ctor(System.Net.WebResponse)">
            <summary>
            Constructor for WebResponseObject
            </summary>
            <param name="response"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WebResponseObject.#ctor(System.Net.WebResponse,System.IO.Stream)">
            <summary>
            Constructor for WebResponseObject with contentStream
            </summary>
            <param name="response"></param>
            <param name="contentStream"></param>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.InvokeWebRequestCommand">
            <summary>
            The Invoke-RestMethod command
            This command makes an HTTP or HTTPS request to a web server and returns the results.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.InvokeWebRequestCommand.ProcessResponse(System.Net.WebResponse)">
            <summary>
            Process the web reponse and output corresponding objects. 
            </summary>
            <param name="response"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.JsonObjectTypeResolver.ResolveTypeId(System.Type)">
            <summary>
            Override abstract methods
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.RegisterObjectEventCommand">
            <summary>
            Registers for an event on an object.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RegisterObjectEventCommand.InputObject">
            <summary>
            The object on which to subscribe
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RegisterObjectEventCommand.EventName">
            <summary>
            The event name to subscribe
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RegisterObjectEventCommand.GetSourceObject">
            <summary>
            Returns the object that generates events to be monitored
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RegisterObjectEventCommand.GetSourceObjectEventName">
            <summary>
            Returns the event name to be monitored on the input object
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.RegisterEngineEventCommand">
            <summary>
            Registers for an event coming from the engine.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RegisterEngineEventCommand.SourceIdentifier">
            <summary>
            Parameter for an identifier for this event subscription
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RegisterEngineEventCommand.GetSourceObject">
            <summary>
            Returns the object that generates events to be monitored
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RegisterEngineEventCommand.GetSourceObjectEventName">
            <summary>
            Returns the event name to be monitored on the input object
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.WaitEventCommand">
            <summary>
            Waits for a given event to arrive.  
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WaitEventCommand.SourceIdentifier">
            <summary>
            An identifier for this event subscription
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WaitEventCommand.Timeout">
            <summary>
            If timeout is specified, the cmdlet will only wait for this number of seconds.
            Value of -1 means never timeout.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WaitEventCommand.ProcessRecord">
            <summary>
            Wait for the event to arrive
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WaitEventCommand.StopProcessing">
            <summary>
            Handle Control-C
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GetEventCommand">
            <summary>
            Gets events from the event queue.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetEventCommand.SourceIdentifier">
            <summary>
            An identifier for this event subscription
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetEventCommand.EventIdentifier">
            <summary>
            An identifier for this event subscription
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetEventCommand.EndProcessing">
            <summary>
            Get the requested events
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.RemoveEventCommand">
            <summary>
            Removes an event from the event queue.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemoveEventCommand.SourceIdentifier">
            <summary>
            A source identifier for this event subscription
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemoveEventCommand.EventIdentifier">
            <summary>
            An identifier for this event subscription
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RemoveEventCommand.ProcessRecord">
            <summary>
            Remove the event from the queue
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GetEventSubscriberCommand">
            <summary>
            Lists all event subscribers.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetEventSubscriberCommand.SourceIdentifier">
            <summary>
            An identifier for this event subscription
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetEventSubscriberCommand.SubscriptionId">
            <summary>
            An identifier for this event subscription
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetEventSubscriberCommand.Force">
            <summary>
            Also show supporting events
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetEventSubscriberCommand.ProcessRecord">
            <summary>
            Get the subscribers
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.UnregisterEventCommand">
            <summary>
            Unregisters from an event on an object.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.UnregisterEventCommand.SourceIdentifier">
            <summary>
            An identifier for this event subscription
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.UnregisterEventCommand.SubscriptionId">
            <summary>
            An identifier for this event subscription
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.UnregisterEventCommand.Force">
            <summary>
            Flag that determines if we should include subscriptions used to support
            other subscriptions
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.UnregisterEventCommand.ProcessRecord">
            <summary>
            Unsubscribe from the event
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.NewEventCommand">
            <summary>
            Generates a new event notification.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewEventCommand.SourceIdentifier">
            <summary>
            Adds an event to the event queue
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewEventCommand.Sender">
            <summary>
            Data relating to this event
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewEventCommand.EventArguments">
            <summary>
            Data relating to this event
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewEventCommand.MessageData">
            <summary>
            Data relating to this event
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.NewEventCommand.EndProcessing">
            <summary>
            Add the event to the event queue
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GetTraceSourceCommand">
            <summary>
            A cmdlet that gets the TraceSource instances that are instantiated in the process
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetTraceSourceCommand.Name">
            <summary>
            Gets or sets the category parameter which determines
            which trace switch to get.
            </summary>
            <value></value>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetTraceSourceCommand.ProcessRecord">
            <summary>
            Gets the PSTraceSource for the specified category
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.PSHostTraceListener">
            <summary>
            This subclass of TraceListener allows for the trace output
            coming from a System.Management.Automation.TraceSwitch
            to be passed to the Msh host's RawUI methods.
            </summary>
            
            <remarks>
            This trace listener cannot be specified in the app.config file.
            It must be added through the add-tracelistener cmdlet.
            </remarks>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PSHostTraceListener.#ctor(System.Management.Automation.PSCmdlet)">
            <summary>
            Default constructor used if no.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PSHostTraceListener.Dispose(System.Boolean)">
            <summary>
            Closes the TraceListenerDialog so that it no longer
            receives trace output.
            </summary>
            
            <param name="disposing">
            true if the TraceListener is being disposed, false
            otherwise.
            </param>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PSHostTraceListener.Close">
            <summary>
            Closes the dialog and then calls the base class Close
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PSHostTraceListener.Write(System.String)">
             <summary>
             Sends the given output string to the host for processing
             </summary>
             <param name="output">
             The trace output to be written
             </param>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PSHostTraceListener.WriteLine(System.String)">
            <summary>
            Sends the given output string to the host for processing
            </summary>
            <param name="output">
            The trace output to be written
            </param>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PSHostTraceListener.ui">
            <summary>
            The host interface to write the debug line to.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SetTraceSourceCommand">
            <summary>
            A cmdlet that sets the properties of the TraceSwitch instances that are instantiated in the process
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetTraceSourceCommand.Name">
            <summary>
            The TraceSource parameter determines which TraceSource categories the
            operation will take place on.
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetTraceSourceCommand.Option">
            <summary>
            The flags to be set on the TraceSource
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetTraceSourceCommand.ListenerOption">
            <summary>
            The parameter which determines the options for output from the
            trace listeners.
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetTraceSourceCommand.FilePath">
            <summary>
            Adds the file trace listener using the specified file
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetTraceSourceCommand.Force">
            <summary>
            Force parameter to control read-only files
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetTraceSourceCommand.Debugger">
            <summary>
            If this parameter is specified the Debugger trace listener
            will be added.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetTraceSourceCommand.PSHost">
            <summary>
            If this parameter is specified the Msh Host trace listener
            will be added.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetTraceSourceCommand.RemoveListener">
            <summary>
            If set, the specified listeners will be removed regardless
            of their type.
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetTraceSourceCommand.RemoveFileListener">
            <summary>
            If set, the specified file trace listeners will be removed.
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetTraceSourceCommand.PassThru">
            <summary>
            Determines if the modified PSTraceSource should be written out.
            Default is false.
            </summary>
            <value></value>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SetTraceSourceCommand.ProcessRecord">
            <summary>
            Sets the TraceSource properties
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.TraceCommandBase">
            <summary>
            A base class for cmdlets that has helper methods for globbing
            trace source instances
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.TraceCommandBase.GetMatchingTraceSource(System.String[],System.Boolean)">
            <summary>
            Gets the matching PSTraceSource instances for the
            specified patterns.
            </summary>
            
            <param name="patternsToMatch">
            The patterns used to match the PSTraceSource name.
            </param>
            
            <param name="writeErrorIfMatchNotFound">
            If true and the pattern does not contain wildcard patterns and no
            match is found, then WriteError will be called.
            </param>
            
            <returns>
            A collection of the matching PSTraceSource instances.
            </returns>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.TraceCommandBase.GetMatchingTraceSource(System.String[],System.Boolean,System.Collections.ObjectModel.Collection{System.String}@)">
            <summary>
            Gets the matching PSTraceSource instances for the
            specified patterns.
            </summary>
            
            <param name="patternsToMatch">
            The patterns used to match the PSTraceSource name.
            </param>
            
            <param name="writeErrorIfMatchNotFound">
            If true and the pattern does not contain wildcard patterns and no
            match is found, then WriteError will be called.
            </param>
            
            <param name="notMatched">
            The patterns for which a match was not found.
            </param>
            
            <returns>
            A collection of the matching PSTraceSource instances.
            </returns>
            
        </member>
        <member name="T:Microsoft.PowerShell.Commands.TraceCommandCommand">
            <summary>
            A cmdlet that traces the specified categories and flags for the duration of the 
            specified expression.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TraceCommandCommand.InputObject">
            <summary>
            This parameter specifies the current pipeline object 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TraceCommandCommand.Name">
            <summary>
            The TraceSource parameter determines which TraceSource categories the
            operation will take place on.
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TraceCommandCommand.Option">
            <summary>
            The flags to be set on the TraceSource
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TraceCommandCommand.Expression">
            <summary>
            The parameter for the expression that should be traced.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TraceCommandCommand.Command">
            <summary>
            The parameter for the expression that should be traced.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TraceCommandCommand.ArgumentList">
            <summary>
            When set, this parameter is the arguments to pass to the command specified by
            the -Command parameter
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TraceCommandCommand.ListenerOption">
            <summary>
            The parameter which determines the options for output from the
            trace listeners.
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TraceCommandCommand.FilePath">
            <summary>
            Adds the file trace listener using the specified file
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TraceCommandCommand.Force">
            <summary>
            Force parameter to control read-only files
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TraceCommandCommand.Debugger">
            <summary>
            If this parameter is specified the Debugger trace listener
            will be added.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TraceCommandCommand.PSHost">
            <summary>
            If this parameter is specified the Msh Host trace listener
            will be added.
            </summary>
            <value></value>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.TraceCommandCommand.BeginProcessing">
            <summary>
            Gets the PSTraceSource instances that match the names specified.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.TraceCommandCommand.ProcessRecord">
            <summary>
            Executes the expression.
            
            Note, this was taken from apply-expression
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.TraceCommandCommand.EndProcessing">
            <summary>
            Finishes running the command if specified and then sets the
            tracing options and listeners back to their original values.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.TraceCommandCommand.StopProcessing">
            <summary>
            Ensures that the sub-pipeline we created gets stopped as well.
            </summary>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.TraceCommandCommand.Dispose">
            <summary>
            Resets the TraceSource flags back to their original value and restores
            the original TraceListeners.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.TracePipelineWriter">
            <summary>
            This class acts a pipe redirector for the sub-pipeline created by the Trace-Command
            cmdlet.  It gets attached to the sub-pipelines success or error pipeline and redirects
            all objects written to these pipelines to trace-command pipeline.
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TracePipelineWriter.WaitHandle">
            <summary>
            Get the wait handle signaled when buffer space is available
            in the underlying stream.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TracePipelineWriter.IsOpen">
            <summary>
            Check if the stream is open for further writes.
            </summary>
            <value>true if the underlying stream is open, otherwise; false.</value>
            <remarks>
            Attempting to write to the underlying stream if IsOpen is false throws
            an <see cref="T:System.ObjectDisposedException"/>.
            </remarks>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TracePipelineWriter.Count">
            <summary>
            Returns the number of objects in the underlying stream
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TracePipelineWriter.MaxCapacity">
            <summary>
            Get the capacity of the stream
            </summary>
            <value>
            The capacity of the stream.
            </value>
            <remarks>
            The capacity is the number of objects that stream may contain at one time.  Once this
            limit is reached, attempts to write into the stream block until buffer space
            becomes available.
            </remarks>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.TracePipelineWriter.Close">
            <summary>
            Close the stream
            </summary>
            <remarks>
            Causes subsequent calls to IsOpen to return false and calls to
            a write operation to throw an ObjectDisposedException.
            All calls to Close() after the first call are silently ignored.
            </remarks>
            <exception cref="T:System.ObjectDisposedException">
            The stream is already disposed
            </exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.TracePipelineWriter.Flush">
            <summary>
            Flush the data from the stream.  Closed streams may be flushed,
            but disposed streams may not.
            </summary>
            <exception cref="T:System.ObjectDisposedException">
            The underlying stream is disposed
            </exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.TracePipelineWriter.Write(System.Object)">
            <summary>
            Write a single object into the underlying stream
            </summary>
            <param name="obj">The object to add to the stream</param>
            <returns>
            One, if the write was successful, otherwise;
            zero if the stream was closed before the object could be written,
            or if the object was AutomationNull.Value.
            </returns>
            <exception cref="T:System.ObjectDisposedException">
            The underlying stream is closed
            </exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.TracePipelineWriter.Write(System.Object,System.Boolean)">
            <summary>
            Write objects to the underlying stream
            </summary>
            <param name="obj">object or enumeration to read from</param>
            <param name="enumerateCollection">
            If enumerateCollection is true, and <paramref name="obj"/>
            is an enumeration according to LanguagePrimitives.GetEnumerable,
            the objects in the enumeration will be unrolled and
            written seperately.  Otherwise, <paramref name="obj"/>
            will be written as a single object.
            </param>
            <returns>The number of objects written</returns>
            <exception cref="T:System.ObjectDisposedException">
            The underlying stream is closed
            </exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="obj"/> contains AutomationNull.Value
            </exception>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.TraceListenerCommandBase">
            <summary>
            A base class for the trace cmdlets that allow you to specify
            which trace listeners to add to a TraceSource
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TraceListenerCommandBase.NameInternal">
            <summary>
            The TraceSource parameter determines which TraceSource categories the
            operation will take place on.
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TraceListenerCommandBase.OptionsInternal">
            <summary>
            The flags to be set on the TraceSource
            </summary>
            <value></value>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.TraceListenerCommandBase.optionsSpecified">
            <summary>
            True if the Options parameter has been set, or false otherwise.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TraceListenerCommandBase.ListenerOptionsInternal">
            <summary>
            The parameter which determines the options for output from the
            trace listeners.
            </summary>
            
        </member>
        <member name="F:Microsoft.PowerShell.Commands.TraceListenerCommandBase.traceOptionsSpecified">
            <summary>
            True if the TraceOptions parameter was specified, or false otherwise
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TraceListenerCommandBase.FileListener">
            <summary>
            Adds the file trace listener using the specified file
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TraceListenerCommandBase.ForceWrite">
            <summary>
            Property that sets force parameter.  This will clear the
            read-only attribute on an existing file if present.
            </summary>
            <remarks>
            Note that we do not attempt to reset the read-only attribute.
            </remarks>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TraceListenerCommandBase.DebuggerListener">
            <summary>
            If this parameter is specified the Debugger trace listener
            will be added.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TraceListenerCommandBase.PSHostListener">
            <summary>
            If this parameter is specified the Msh Host trace listener
            will be added.
            </summary>
            <value></value>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.TraceListenerCommandBase.AddTraceListenersToSources(System.Collections.ObjectModel.Collection{System.Management.Automation.PSTraceSource})">
            <summary>
            Adds the console, debugger, file, or host listener
            if requested.
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TraceListenerCommandBase.FileStreams">
            <summary>
            The file streams that were open by this command
            </summary>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.TraceListenerCommandBase.RemoveListenersByName(System.Collections.ObjectModel.Collection{System.Management.Automation.PSTraceSource},System.String[],System.Boolean)">
            <summary>
            Removes the tracelisteners from the specified trace sources
            </summary>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.TraceListenerCommandBase.SetTraceListenerOptions(System.Collections.ObjectModel.Collection{System.Management.Automation.PSTraceSource})">
            <summary>
            Sets the trace listener options based on the ListenerOptions parameter
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.TraceListenerCommandBase.SetFlags(System.Collections.ObjectModel.Collection{System.Management.Automation.PSTraceSource})">
            <summary>
            Sets the flags for all the specified TraceSources
            </summary>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.TraceListenerCommandBase.TurnOnTracing(System.Collections.ObjectModel.Collection{System.Management.Automation.PSTraceSource},System.Boolean)">
            <summary>
            Turns on tracing for the TraceSources, flags, and listeners defined by
            the parameters
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.TraceListenerCommandBase.ResetTracing(System.Collections.ObjectModel.Collection{System.Management.Automation.PSTraceSource})">
            <summary>
            Resets tracing to the previous level for the TraceSources defined by the parameters.
            Note, TurnOnTracing must be called before calling ResetTracing or else all
            TraceSources will be turned off.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.TraceListenerCommandBase.ClearStoredState">
            <summary>
            Clears the store TraceSource state.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ShowCommandCommand">
            <summary>
            Show-Command displays a GUI for a cmdlet, or for all cmdlets if no specific cmdlet is specified.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ShowCommandCommand.hasOpenedWindow">
            <summary>
            Set to true when ProcessRecord is reached, since it will allways open a window
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ShowCommandCommand.passThrough">
            <summary>
            Determines if the command should be sent to the pipeline as a string instead of run.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ShowCommandCommand.showCommandProxy">
            <summary>
            Uses ShowCommandProxy to invoke WPF GUI object. 
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ShowCommandCommand.commands">
            <summary>
            Data container for all cmdlets. This is populated when show-command is called with no command name.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ShowCommandCommand.importedModules">
            <summary>
            List of modules that have been loaded indexed by module name
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ShowCommandCommand.errors">
            <summary>
            Record the EndProcessing error.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ShowCommandCommand.commandName">
            <summary>
            Field used for the CommandName parameter.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ShowCommandCommand.height">
            <summary>
            Field used for the Height parameter.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ShowCommandCommand.width">
            <summary>
            Field used for the Width parameter.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ShowCommandCommand.noCommonParameter">
            <summary>
            Field used for the NoCommonParameter parameter.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ShowCommandCommand.errorPopup">
            <summary>
            A value indicating errors should not cause a message window to be displayed
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ShowCommandCommand.commandViewModelObj">
            <summary>
            Object used for ShowCommand with a command name that holds the view model created for the command
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ShowCommandCommand.Finalize">
            <summary>
            Finalizes an instance of the ShowCommandCommand class
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ShowCommandCommand.Name">
            <summary>
            Gets or sets the command name.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ShowCommandCommand.Height">
            <summary>
            Gets or sets the Width.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ShowCommandCommand.Width">
            <summary>
            Gets or sets the Width.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ShowCommandCommand.NoCommonParameter">
            <summary>
            Gets or sets a value indicating Common Parameters should not be displayed
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ShowCommandCommand.ErrorPopup">
            <summary>
            Gets or sets a value indicating errors should not cause a message window to be displayed
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ShowCommandCommand.PassThru">
            <summary>
            Gets or sets a value indicating the command should be sent to the pipeline as a string instead of run
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ShowCommandCommand.RunScript(System.String)">
            <summary>
            Executes a PowerShell script, writing the output objects to the pipeline.
            </summary>
            <param name="script">Script to execute</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ShowCommandCommand.Dispose">
            <summary>
            Dispose method in IDisposeable
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ShowCommandCommand.BeginProcessing">
            <summary>
            Initialize a proxy instance for show-command.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ShowCommandCommand.ProcessRecord">
            <summary>
            ProcessRecord with or without CommandName.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ShowCommandCommand.EndProcessing">
            <summary>
            Optionally displays errors in a message
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ShowCommandCommand.StopProcessing">
            <summary>
            StopProcessing is called close the window when user press Ctrl+C in the command prompt.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ShowCommandCommand.RunScriptSilentlyAndWithErrorHookup(System.String)">
            <summary>
            Runs the script in a new PowerShell instance and  hooks up error stream to pottentlially display error popup.
            This method has the inconvenience of not showing to the console user the script being executed.
            </summary>
            <param name="script">script to be run</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ShowCommandCommand.IssueErrorForNoCommand">
            <summary>
            Issues an error when this.commandName was not found
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ShowCommandCommand.IssueErrorForMoreThanOneCommand">
            <summary>
            Issues an error when there is more than one command matching this.commandName
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ShowCommandCommand.GetCommandInfoAndModules(System.Management.Automation.CommandInfo@,System.Collections.Generic.Dictionary{System.String,Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandModuleInfo}@)">
            <summary>
            Called from CommandProcessRecord to run the command that will get the CommandInfo and list of modules
            </summary>
            <param name="command">command to be retrieved</param>
            <param name="modules">list of loaded modules</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ShowCommandCommand.CanProcessRecordForOneCommand">
            <summary>
            ProcessRecord when a command name is specified.
            </summary>
            <returns>true if there was no exception processing this record</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ShowCommandCommand.CanProcessRecordForAllCommands">
            <summary>
            ProcessRecord when a command name is not specified.
            </summary>
            <returns>true if there was no exception processing this record</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ShowCommandCommand.WaitForWindowClosedOrHelpNeeded">
            <summary>
            Waits untill the window has been closed answering HelpNeeded events
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ShowCommandCommand.Output_DataAdded(System.Object,System.Management.Automation.DataAddedEventArgs)">
            <summary>
            Writes the output of a script being run into the pipeline
            </summary>
            <param name="sender">output collection</param>
            <param name="e">output event</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ShowCommandCommand.Error_DataAdded(System.Object,System.Management.Automation.DataAddedEventArgs)">
            <summary>
            Writes the errors of a script being run into the pipeline
            </summary>
            <param name="sender">error collection</param>
            <param name="e">error event</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ShowCommandCommand.Dispose(System.Boolean)">
            <summary>
            Implements IDisposable logic
            </summary>
            <param name="isDisposing">true if being called from Dispose</param>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ShowCommandCommand.ConsoleInputWithNativeMethods">
            <summary>
            Wraps interop code for console input buffer
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ShowCommandCommand.ConsoleInputWithNativeMethods.STD_INPUT_HANDLE">
            <summary>
            Constant used in calls to GetStdHandle
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ShowCommandCommand.ConsoleInputWithNativeMethods.AddToConsoleInputBuffer(System.String,System.Boolean)">
            <summary>
            Adds a string to the console input buffer
            </summary>
            <param name="str">string to add to console input buffer</param>
            <param name="newLine">true to add Enter after the string</param>
            <returns>true if it was succesfull in adding all characters to console input buffer</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ShowCommandCommand.ConsoleInputWithNativeMethods.GetStdHandle(System.Int32)">
            <summary>
            Gets the console handle
            </summary>
            <param name="nStdHandle">which console handle to get</param>
            <returns>the console handle</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ShowCommandCommand.ConsoleInputWithNativeMethods.WriteConsoleInput(System.IntPtr,Microsoft.PowerShell.Commands.ShowCommandCommand.ConsoleInputWithNativeMethods.INPUT_RECORD[],System.UInt32,System.UInt32@)">
            <summary>
            Writes to the console input buffer
            </summary>
            <param name="hConsoleInput">console handle</param>
            <param name="lpBuffer">inputs to be written</param>
            <param name="nLength">number of inputs to be written</param>
            <param name="lpNumberOfEventsWritten">returned number of inputs actually written</param>
            <returns>0 if the function fails</returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ShowCommandCommand.ConsoleInputWithNativeMethods.INPUT_RECORD">
            <summary>
            A record to be added to the console buffer
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ShowCommandCommand.ConsoleInputWithNativeMethods.INPUT_RECORD.KEY_EVENT">
            <summary>
            The proper event type for a KeyEvent KEY_EVENT_RECORD
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ShowCommandCommand.ConsoleInputWithNativeMethods.INPUT_RECORD.EventType">
            <summary>
            input buffer event type
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ShowCommandCommand.ConsoleInputWithNativeMethods.INPUT_RECORD.KeyEvent">
            <summary>
            The actual event. The original structure is a union of many others, but this is the largest of them
            And we don't need other kinds of events
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ShowCommandCommand.ConsoleInputWithNativeMethods.INPUT_RECORD.SetInputRecord(Microsoft.PowerShell.Commands.ShowCommandCommand.ConsoleInputWithNativeMethods.INPUT_RECORD@,System.Char)">
            <summary>
            Sets the necessary fields of <paramref name="inputRecord"/> for a KeyDown event for the <paramref name="character"/>
            </summary>
            <param name="inputRecord">input record to be set</param>
            <param name="character">character to set the record with</param>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ShowCommandCommand.ConsoleInputWithNativeMethods.KEY_EVENT_RECORD">
            <summary>
            Type of INPUT_RECORD which is a key
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ShowCommandCommand.ConsoleInputWithNativeMethods.KEY_EVENT_RECORD.bKeyDown">
            <summary>
            true for key down and false for key up, but only needed if wVirtualKeyCode is used
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ShowCommandCommand.ConsoleInputWithNativeMethods.KEY_EVENT_RECORD.wRepeatCount">
            <summary>
            repeat count
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ShowCommandCommand.ConsoleInputWithNativeMethods.KEY_EVENT_RECORD.wVirtualKeyCode">
            <summary>
            virtual key code
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ShowCommandCommand.ConsoleInputWithNativeMethods.KEY_EVENT_RECORD.wVirtualScanCode">
            <summary>
            virtual key scan code
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ShowCommandCommand.ConsoleInputWithNativeMethods.KEY_EVENT_RECORD.UnicodeChar">
            <summary>
            character in input. If this is specified, wVirtualKeyCode, and others don't need to be
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ShowCommandCommand.ConsoleInputWithNativeMethods.KEY_EVENT_RECORD.dwControlKeyState">
            <summary>
            State of keys like Shift and control
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ShowCommandProxy">
            <summary>
            Help show-command create WPF object and invoke WPF windows with the 
            Microsoft.PowerShell.Commands.ShowCommandInternal.ShowCommandHelperhelp type defined in Microsoft.PowerShell.GraphicalHost.dll
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandCommandInfo">
            <summary>
            Implements a facade around CommandInfo and its deserialized counterpart
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandCommandInfo.#ctor(System.Management.Automation.CommandInfo)">
            <summary>
            Creates an instance of the ShowCommandCommandInfo class based on a CommandInfo object
            </summary>
            
            <param name="other">
            The object to wrap.
            </param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandCommandInfo.#ctor(System.Management.Automation.PSObject)">
            <summary>
            Creates an instance of the ShowCommandCommandInfo class based on a PSObject object
            </summary>
            
            <param name="other">
            The object to wrap.
            </param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandCommandInfo.GetObjectEnumerable(System.Collections.IEnumerable)">
            <summary>
            Builds a strongly typed IEnumerable{object} out of an IEnumerable
            </summary>
            
            <param name="enumerable">
            The object to enumerate.
            </param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandCommandInfo.Name">
            <summary>
            A string representing the definition of the command.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandCommandInfo.ModuleName">
            <summary>
            A string representing module the command belongs to.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandCommandInfo.Module">
            <summary>
            A reference to the module the command came from.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandCommandInfo.CommandType">
            <summary>
            An enumeration of the command types this command belongs to.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandCommandInfo.Definition">
            <summary>
            A string representing the definition of the command.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandCommandInfo.ParameterSets">
            <summary>
            A string representing the definition of the command.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandModuleInfo">
            <summary>
            Implements a facade around PSModuleInfo and its deserialized counterpart
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandModuleInfo.#ctor(System.Management.Automation.PSModuleInfo)">
            <summary>
            Creates an instance of the ShowCommandModuleInfo class based on a CommandInfo object
            </summary>
            
            <param name="other">
            The object to wrap.
            </param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandModuleInfo.#ctor(System.Management.Automation.PSObject)">
            <summary>
            Creates an instance of the ShowCommandModuleInfo class based on a PSObject object
            </summary>
            
            <param name="other">
            The object to wrap.
            </param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandModuleInfo.Name">
            <summary>
            Gets the name of this module
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandParameterInfo">
            <summary>
            Implements a facade around ShowCommandParameterInfo and its deserialized counterpart
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandParameterInfo.#ctor(System.Management.Automation.CommandParameterInfo)">
            <summary>
            Creates an instance of the ShowCommandParameterInfo class based on a CommandParameterInfo object
            </summary>
            
            <param name="other">
            The object to wrap.
            </param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandParameterInfo.#ctor(System.Management.Automation.PSObject)">
            <summary>
            Creates an instance of the ShowCommandParameterInfo class based on a PSObject object
            </summary>
            
            <param name="other">
            The object to wrap.
            </param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandParameterInfo.Name">
            <summary>
            Gets the name of the parameter.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandParameterInfo.IsMandatory">
            <remarks>
            True if the parameter is dynamic, or false otherwise.
            </remarks>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandParameterInfo.ValueFromPipeline">
            <summary>
            Gets whether the parameter can take values from the incoming pipeline object.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandParameterInfo.ParameterType">
            <summary>
            Gets the type of the parameter.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandParameterInfo.ValidParamSetValues">
            <summary>
            The possible values of this parameter
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandParameterInfo.HasParameterSet">
            <summary>
            Gets whether the parameter has a parameter set.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandParameterInfo.Position">
            <summary>
            Gets the position in which the parameter can be specified on the command line
            if not named. If the returned value is int.MinValue then the parameter must be named.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandParameterSetInfo">
            <summary>
            Implements a facade around CommandParameterSetInfo and its deserialized counterpart
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandParameterSetInfo.#ctor(System.Management.Automation.CommandParameterSetInfo)">
            <summary>
            Creates an instance of the ShowCommandParameterSetInfo class based on a CommandParameterSetInfo object
            </summary>
            
            <param name="other">
            The object to wrap.
            </param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandParameterSetInfo.#ctor(System.Management.Automation.PSObject)">
            <summary>
            Creates an instance of the ShowCommandParameterSetInfo class based on a PSObject object
            </summary>
            
            <param name="other">
            The object to wrap.
            </param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandParameterSetInfo.Name">
            <summary>
            Gets the name of the parameter set
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandParameterSetInfo.IsDefault">
            <summary>
            Gets whether the parameter set is the default parameter set.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandParameterSetInfo.Parameters">
            <summary>
            Gets the parameter information for the parameters in this parameter set.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandParameterType">
            <summary>
            Implements a facade around ShowCommandParameterInfo and its deserialized counterpart
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandParameterType.#ctor(System.Type)">
            <summary>
            Creates an instance of the ShowCommandParameterType class based on a Type object
            </summary>
            
            <param name="other">
            The object to wrap.
            </param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandParameterType.#ctor(System.Management.Automation.PSObject)">
            <summary>
            Creates an instance of the ShowCommandParameterType class based on a Type object
            </summary>
            
            <param name="other">
            The object to wrap.
            </param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandParameterType.FullName">
            <summary>
            The full name of the outermost type
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandParameterType.IsEnum">
            <summary>
            Whether or not this type is an enum
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandParameterType.ImplementsDictionary">
            <summary>
            Whether or not this type is an dictionary
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandParameterType.HasFlagAttribute">
            <summary>
            Whether or not this enum has a flag attribute
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandParameterType.IsArray">
            <summary>
            Whether or not this type is an array type
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandParameterType.ElementType">
            <summary>
            Gets the inner type, if this corresponds to an array type
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandParameterType.IsString">
            <summary>
            Whether or not this type is a string
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandParameterType.IsScriptBlock">
            <summary>
            Whether or not this type is an script block
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandParameterType.IsBoolean">
            <summary>
            Whether or not this type is a bool
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandParameterType.IsSwitch">
            <summary>
            Whether or not this type is a switch parameter
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ShowCommandExtension.ShowCommandParameterType.EnumValues">
            <summary>
            If this is an enum value, return the list of potential values
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.ConvertFromStringCommand">
             <summary>
             Defines the ConvertFrom-String cmdlet.
             </summary>
             <usage>
                 /// Usage:
                 Import-Module 'D:\documents\Visual Studio Projects\ParseString\bin\debug\ConvertFrom-String.dll'
                 gc -Raw {inputFile} | ConvertFrom-String -TemplateFile {markupFile} [| sort [-desc] {propertyName}
                 gc -Raw {inputFile} | ConvertFrom-String -TemplateFile {markupFile} ParameterNames AddressStruct=Address,A=B [| sort [-desc] {propertyName}
             
                 Various formatting options...
                 ... | format-table -autosize
                 ... | format-custom -depth 3
             
                 Basic flow is simple:
                     ProcessRecord is called by PS
                         This calls WriteObject - using the override to allow PS to enumerate objects
            </usage>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.ConvertFromStringCommand.Delimiter">
            <summary>
            Gets or sets the Delimiter parameter
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.ConvertFromStringCommand.PropertyNames">
            <summary>
            Gets or sets the property name mapping (used for structs)
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.ConvertFromStringCommand.TemplateFile">
            <summary>
            The name of the file containing the template markup.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.ConvertFromStringCommand.TemplateContent">
            <summary>
            The content of the template markup
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.ConvertFromStringCommand.IncludeExtent">
            <summary>
            Set whether extract the properties' extentText 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.ConvertFromStringCommand.UpdateTemplate">
            <summary>
            Write the programs to the template file
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.ConvertFromStringCommand.InputObject">
            <summary>
            Gets or sets the InputObject parameter
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.ConvertFromStringCommand.inputLines">
            <summary>
            To support stream reading we build this up in ProcessRecord then process it in EndProcessing.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.ConvertFromStringCommand.BeginProcessing">
            <summary>
            Begin process incoming objects
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.ConvertFromStringCommand.CheckUpdateTemplatePrecondition">
            <summary>
            To use UpdateTemplate, users need t select a file
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.ConvertFromStringCommand.ProcessRecord">
            <summary>
            Process incoming objects
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.ConvertFromStringCommand.EndProcessing">
            <summary>
            Output results
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.ConvertStringCommand">
            <summary>
            Defines the ConvertString cmdlet.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.ConvertStringCommand.Example">
            <summary>
            The input output examples for Flashfill
            User can pass a single string with the pattern "input example = output example" 
            Or user can pass a list of psobjects with before and after properties
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.ConvertStringCommand.InputObject">
            <summary>
            Gets or sets the InputObject parameter
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.ConvertStringCommand.BeginProcessing">
            <summary>
            Begin processing
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.ConvertStringCommand.ProcessRecord">
            <summary>
            Process incoming objects
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.ConvertStringCommand.ParseInputOutputExample(System.String)">
            <summary>
            It parses the content of the example in the form of input=output
            </summary>
            <param name="exampleText"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.ConvertStringCommand.IsSingleStringExample(System.Management.Automation.PSObject)">
            <summary>
            Checks if the example is of the type "input value = output value" 
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.BotSchemaElement`2">
            <summary>
            This class is the highest element in the schema, representing the entire file.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.ConvertSchemaElementInterface">
            <summary>
            A generic converter interface exposing the name for retrieving it.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.ConvertSchemaElementInterface.ConverterName">
            <summary>
            The name of this converter
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.ConvertSchemaElementInterface.#ctor(System.String)">
            <summary>
            Protected constructor.
            </summary>
            <param name="converterName"></param>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.ConvertSchemaElementFactoryGeneric2`2">
            <summary>
            Generic ConvertSchemaElement factory exposing only the creation methods used in different parse methods (grammar and whole program).
            It does not refer to the child regions.
            </summary>
            <typeparam name="TExtractionProgramParent"></typeparam>
            <typeparam name="TRegionParent"></typeparam>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.ConvertSchemaElementFactory`4">
            <summary>
            Class to extend to create conversion rules between regions and extraction programs.
            It can eventually convert the same region to iself, e.g. for removing clutter in input.
            </summary>
            <typeparam name="TExtractionProgramParent">The type of extraction program visible to the parent</typeparam>
            <typeparam name="TRegionParent">The type of region that the parent sees</typeparam>
            <typeparam name="TExtractionProgramChild">The type of the extraction program of the child</typeparam>
            <typeparam name="TRegionChild">The type of region used by</typeparam>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.ConvertSchemaElementFactory`4.ConvertToChildRegion(`1)">
            <summary>
            Method to convert the parent region to the child region.
            Many converters can convert the same region to another one.
            </summary>
            <param name="regionParent"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.ConvertSchemaElementFactory`4.GetChildLearner">
            <summary>
            Returns the child program extraction learner.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.ConvertSchemaElementFactory`4.CreateInternal(System.String,Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.SchemaElement{`0,`1},System.Boolean,Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.ProgramLearner{`0,`1})">
            <summary>
            Private constructor used in Create and CreateAndParseChildInternal
            </summary>
            <param name="name"></param>
            <param name="parent"></param>
            <param name="nullable"></param>
            <param name="learner"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.ConvertSchemaElementFactory`4.ParseChid(System.Xml.Linq.XElement,Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.ConvertSchemaElementInterface[],Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Internal.ASTSerializationFormat,System.Func{System.Xml.Linq.XElement,Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.VersionSpace.ProgramSet})">
            <summary>
            Parses a child, calling the SchemaElement.Parse method.
            </summary>
            <param name="element">The element in xml</param>
            <param name="converters">The list of converters</param>
            <param name="formatPrograms">The way programs are formatted</param>
            <param name="getProgramSet">A way to retrieve the program set from the xml element, if any</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.ConvertSchemaElementFactory`4.CreateAndParseChild(System.String,Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.SchemaElement{`0,`1},System.Boolean,Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.ProgramLearner{`0,`1},System.Xml.Linq.XElement,Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.ConvertSchemaElementInterface[],Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Internal.ASTSerializationFormat)">
            <summary>
            Creates a ConvertSchemaElement and parse its provided child with its program and children in xml format.
            </summary>
            <param name="name">Name</param>
            <param name="parent">The parent of the returned element</param>
            <param name="nullable">If this element is nullable</param>
            <param name="learner">The learner of the Parent's region and Program Extraction</param>
            <param name="child">The child in xml</param>
            <param name="converters">The list of available converters</param>
            <param name="formatPrograms">The way the programs are serialized (xml or HumanReadable)</param>
            <returns>The ConvertSchemaElement</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.ConvertSchemaElementFactory`4.Create(System.String,Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.SchemaElement{`0,`1},System.Boolean,Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.ProgramLearner{`0,`1})">
            <summary>
            Creates a ConvertSchemaElement for a top-down creation.
            </summary>
            <param name="name">Name</param>
            <param name="parent">The parent of the returned element</param>
            <param name="nullable">If this element is nullable</param>
            <param name="learner">The learner of the Parent's region and Program Extraction</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.ConvertSchemaElementFactory`4.CreateAndParseChildGrammar(System.String,System.Xml.Linq.XElement,System.Boolean,Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.ProgramLearner{`0,`1},Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.ConvertSchemaElementInterface[])">
            <summary>
            Creates and element and parses its child (not programs) using the SchemaGrammar.Parse method.
            </summary>
            <param name="name">The name of the convert schema element. Can be different from the name of the converter</param>
            <param name="childMemberXml">The child in xml format</param>
            <param name="nullable">If this element is nullable</param>
            <param name="learner">The learner of the parent of the returned ConvertSchemaElement</param>
            <param name="converters">The list of converters</param>
            <returns>The ConvertSchemaElement</returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.ConvertSchemaElement`4">
            <summary>
            Allows one schema element of type Child be part of a schema element of type Parent
            </summary>
            <typeparam name="TExtractionProgramChild"></typeparam>
            <typeparam name="TRegionChild"></typeparam>
            <typeparam name="TExtractionProgramParent"></typeparam>
            <typeparam name="TRegionParent"></typeparam>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.ConvertSchemaElement`4.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.ConvertSchemaElementFactory{`0,`1,`2,`3},System.String,System.Boolean,Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.SchemaElement{`2,`3},Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.ProgramLearner{`0,`1})">
            <summary>
            Bottom-up constructor of ConvertSchemaElement.
            Used to learn programs from examples.
            </summary>
            <param name="converter">The converter</param>
            <param name="name">The name of this ConvertSchemaElement. Can be different from the converter's name</param>
            <param name="childElement">The child element already constructed</param>
            <param name="nullable">If this element is nullable</param>
            <param name="learner">The learner.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.ConvertSchemaElement`4.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.ConvertSchemaElementFactory{`0,`1,`2,`3},System.String,Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.SchemaElement{`0,`1},System.Boolean,Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.ProgramLearner{`0,`1})">
            <summary>
            Top-down constructor of StructSchemaElement
            Used to parse programs.
            </summary>
            <param name="converter"></param>
            <param name="name"></param>
            <param name="parent"></param>
            <param name="nullable"></param>
            <param name="learner"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.FieldSchemaElement`2.#ctor(System.String,Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.SchemaElement{`0,`1},System.Boolean,Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.ProgramLearner{`0,`1})">
            <summary>
            Top-down constructor of StructSchemaElement
            Used to parse programs.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.SchemaElement`2.#ctor(System.String,Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.SchemaElement{`0,`1},System.Boolean,Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.ProgramLearner{`0,`1})">
            <summary>
            Top-down constructor of SchemaElement
            Used to parse programs.
            </summary>
            <param name="name"></param>
            <param name="parent"></param>
            <param name="nullable"></param>
            <param name="learner"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.SchemaElement`2.AddChild(Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.SchemaElement{`0,`1})">
            <summary>
            Sibling method to top-down build this SchemaElement
            </summary>
            <param name="element"></param>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.SchemaElement`2.ExecutionCache">
            <summary>
            Store the execution cache of the kth program in Programs under a string
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.SchemaElement`2.ReferencedElement">
            <summary>
            The node that serves as a boundary.
            This node is not neccessarily the Parent.
            It can be any ancestor (including \bot).
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.SchemaElement`2.isSequence">
            <summary>
            If the program extracting this node is a sequence or a substring.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.SchemaElement`2.Programs">
            <summary>
            The top field extraction programs for this node.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.SchemaElement`2.AllPrograms">
            <summary>
            All field extraction programs for this node.
            </summary>
        </member>
        <member name="E:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.SchemaElement`2.OnEvaluationFinished">
            <summary>
            An even handler when this schema finishes to execute.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.SchemaElement`2.AcceptVisitor``1(Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.SchemaVisitor{``0,`0,`1})">
            <summary>
            Returns the value computed by the hierarchical application of the <paramref name="visitor"/> instance.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.SchemaElement`2.Parse(System.Xml.Linq.XElement,Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.SchemaElement{`0,`1},Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.ProgramLearner{`0,`1},Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.ConvertSchemaElementInterface[],Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Internal.ASTSerializationFormat,System.Func{System.Xml.Linq.XElement,Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.VersionSpace.ProgramSet})">
            <summary>
            Parses an xml element and returns a SchemaElement.
            </summary>
            <param name="element">The code to parse as XElement</param>
            <param name="parent"></param>
            <param name="learner"></param>
            <param name="converters"></param>
            <param name="formatPrograms">If the programs are formatted in XML or in human-readable format.</param>
            <param name="getProgramSet"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.SchemaElement`2.Parse(System.String,Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.ProgramLearner{`0,`1},Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.ConvertSchemaElementInterface[],Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Internal.ASTSerializationFormat,System.Func{System.Xml.Linq.XElement,Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.VersionSpace.ProgramSet})">
            <summary>
            Parses an xml element in a string and returns the corresponding SchemaElement.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.SchemaElement`2.ComputeReferencedElement">
            <summary>
            Computes the references node and returns it. Computes whether this element will run for a SequenceTreeElement or just a field/struct.
            </summary>
            <returns>Returns true if this node is a sequence, false otherwise</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.SchemaElement`2.RunTree(`1)">
            <summary>
            Build the execution tree for this element and its children.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.SchemaElement`2.SchemaEvaluationFinishedEventArgs`1">
            <summary>
            Returns the absolute positioning of this label.
            The boundaries of its parent can be retrieved when the parent is run.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.SchemaElement`2.TopLevelRunOfReferencedElement(`1)">
            <summary>
            Returns the top-level run of the referenced element.
            </summary>
            <param name="str">The whole string on which to run the parent.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.SchemaElement`2.TopLevelRun(`1)">
            <summary>
            Returns the absolute positions in the string of this program when all ancestor programs execute.
            </summary>
            <param name="str">The whole string</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.SchemaElement`2.TopLevelRunPlusParent(`1)">
            Returns the top level run with the dependency to the parent.
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.SchemaElement`2.Run(`1,System.Int32)">
            <summary>
            Execute the kth program of this element on the region <paramref name="s"/>.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.SchemaElementProgram`2">
            <summary>
            This class represents a kth program of all learned programs of an element in a schema.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.SchemaGrammar`2">
            <summary>
            The class that represents the schema tree. Essentially a wrapper around a SchemaElement.
            - Parsing functions to retrieve a schema from a string;
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.SchemaGrammar`2.FindElement(System.String)">
            <summary>
            Return the node in the schema whose id is <paramref name="e"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.SequenceSchemaElement`2.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.SchemaElement{`0,`1},System.String,System.Boolean,Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.ProgramLearner{`0,`1})">
            <summary>
            Top-down constructor of StructSchemaElement
            Used to parse programs.
            </summary>
            <param name="parent"></param>
            <param name="name"></param>
            <param name="nullable"></param>
            <param name="learner"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.StructSchemaElement`2.#ctor(System.String,System.Collections.Generic.List{Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.SchemaElement{`0,`1}},System.Boolean,Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.ProgramLearner{`0,`1})">
            <summary>
            Bottom-up constructor of StructSchemaElement.
            Used to learn programs from examples.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.StructSchemaElement`2.#ctor(System.String,Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.SchemaElement{`0,`1},System.Boolean,Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.ProgramLearner{`0,`1})">
            <summary>
            Top-down constructor of StructSchemaElement
            Used to parse programs.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.StructSchemaElement`2.RunTreeBoundaries(`1,System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Short-circuit so that this method can be run even without RunTree.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.StructSchemaElement`2.FindExplicitElement``1(Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.SchemaElement{`0,`1},Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.TreeElement{``0},``0)">
            <summary>
            Return the singleton object wrapped by the sequence tree inside the boundaries.
            There should be exactly one element, as this is used by implicit structs only.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.StructSchemaElement`2.IsChildDefiningImplicitBoundaries(Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.SchemaElement{`0,`1})">
            <summary>
            Returns true if the given child/member is defining implicit boundaries.
            </summary>
            <param name="member">The child to test</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.UnionSchemaElement`2.#ctor(System.String,System.Collections.Generic.List{Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.SchemaElement{`0,`1}},System.Boolean,Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.ProgramLearner{`0,`1})">
            <summary>
            Bottom-up constructor.
            </summary>
            <param name="name"></param>
            <param name="members"></param>
            <param name="nullable"></param>
            <param name="learner"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.UnionSchemaElement`2.#ctor(System.String,Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.SchemaElement{`0,`1},System.Boolean,Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.ProgramLearner{`0,`1})">
            <summary>
            Top-down constructor of StructSchemaElement
            Used to parse programs.
            </summary>
            <param name="name"></param>
            <param name="parent"></param>
            <param name="nullable"></param>
            <param name="learner"></param>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.Region`1">
            <summary>
            A Region is a data type commonly used in extraction tasks.
            It refers to the type T which should be the subclass itself.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.Region`1.UpdateInput(`0)">
            <summary>
            Put the main region of mainRegion as the main region of this region.
            In other words, update the pointer fo this region to the mainR
            </summary>
            <param name="mainRegion">The total region</param>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.InputOutputs`1">
            <summary>
            A wrapper around regions to record relation between regions (e.g. used in dependent negative examples)
            One region is the input, and other dependent regions are stored in Outputs.
            </summary>
            <typeparam name="TRegion">The type of region it wraps</typeparam>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaProgram`3">
            <summary>
             Wrapper around a SchemaElement of the given type, used to perform learning on one element
            </summary>
            <typeparam name="TExtractionProgram">The program wrapper at the field or struct level</typeparam>
            <typeparam name="TRegion">The type of regions on which this operates</typeparam>
            <typeparam name="TSelector">The type of selector used by the method Select</typeparam>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaProgram`3.Select(`2,`1)">
            <summary>
            Creates a region from the input and a selector.
            </summary>
            <param name="input"></param>
            <param name="selector"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaProgram`3.RunForTreeElement(`2)">
            <summary>
            Executes the schema program on the string <paramref name="s"/>. Returns the highlighting of the tree.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaProgram`3.Run(`2)">
            <summary>
            Execute the schema program on the string <paramref name="s"/>.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaProgram`3.LearnElement(System.String,System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.IEnumerable{`1},`2,System.Int32)">
            <summary>
            Learn an element interactively. We can repeatedly call this method (with an increasing number of 
            examples) to learn a field. Once we switch to a new field, we cannot call this method on
            previously learned fields.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaProgram`3.LearnElementField(System.String,System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.IEnumerable{`1},`2,System.Int32)">
            <summary>
            Learn an element interactively. We can repeatedly call this method (with an increasing number of 
            examples) to learn a field. Once we switch to a new field, we cannot call this method on
            previously learned fields.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaProgram`3.LearnElementField(System.String,System.Collections.Generic.IEnumerable{`2},System.Collections.Generic.IEnumerable{`2},`2,System.Int32)">
            <summary>
            Learn an element interactively. We can repeatedly call this method (with an increasing number of 
            examples) to learn a field. Once we switch to a new field, we cannot call this method on
            previously learned fields.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaProgramLearner`4">
            <summary>
            Learner for returning a sequence of schemaPrograms.
            </summary>
            <typeparam name="TSchemaProgram">The type of schema it should create</typeparam>
            <typeparam name="TExtractionProgram">The type of extraction program</typeparam>
            <typeparam name="TRegion">The type of the region used</typeparam>
            <typeparam name="TSelector">The type of the selector</typeparam>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaProgramLearner`4.Select(`3,`2)">
            <summary>
            Creates a region from the input and a selector.
            </summary>
            <param name="input"></param>
            <param name="selector"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaProgramLearner`4.LearnSchema(System.String,System.Collections.Generic.IEnumerable{Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.DocumentSpecInterface},System.Int32,System.Boolean,Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.ConvertSchemaElementInterface[])">
            <summary>
            Learn schema program from multiple examples at once
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaProgramLearnerExtensions.LearnSchema``4(Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaProgramLearner{``0,``1,``2,``3},System.String,System.String,System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.IEnumerable{``2}},System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.IEnumerable{``2}},System.Int32,System.Boolean)">
            <summary>
            Learn a schema program from a set of all examples of every field. 
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaProgramLearnerExtensions.LearnSchemaExt``4(Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaProgramLearner{``0,``1,``2,``3},System.String,System.Collections.Generic.IEnumerable{System.Tuple{``3,System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.IEnumerable{``2}},System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.IEnumerable{``2}}}},System.Int32,System.Boolean,Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.ConvertSchemaElementInterface[])">
            <summary>
            Learn schema program from multiple examples at once
            </summary>
            <param name="learner">The custom learner</param>
            <param name="schema">Schema in XML format</param>
            <param name="specs">A list of specifications, each containing an input document and dictionaries with positive 
            and negative examples for fields to learn</param>
            <param name="k">Number of programs to learn</param>
            <param name="learnAll">If true, the program set will be generated.</param>
            <param name="converters">An array of converters</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaProgramLearnerExtensions.LearnSchemaExt``4(Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaProgramLearner{``0,``1,``2,``3},System.String,System.Collections.Generic.IEnumerable{System.Tuple{``3,System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.IEnumerable{``3}},System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.IEnumerable{``3}}}},System.Int32,System.Boolean,Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.ConvertSchemaElementInterface[])">
            <summary>
            Learns a schema from one input file and positive/negative examples.
            </summary>
            <param name="learner">Custom learner provided</param>
            <param name="schema">Schema in XML format</param>
            <param name="specs">A list of specifications, each containing an input document and dictionaries with positive 
            and negative examples for fields to learn</param>
            <param name="k">Number of programs to learn</param>
            <param name="learnAll">If true, the program set will be generated.</param>
            <param name="converters">An array of converters</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaProgramLearnerExtensions.LearnSchemaExt``4(Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaProgramLearner{``0,``1,``2,``3},System.String,``3,System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.IEnumerable{``3}},System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.IEnumerable{``3}},System.Int32,System.Boolean,Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SchemaParser.ConvertSchemaElementInterface[])">
            <summary>
            
            </summary>
            <typeparam name="TSchemaProgram"></typeparam>
            <typeparam name="TExtractionProgram"></typeparam>
            <typeparam name="TSelector"></typeparam>
            <typeparam name="TRegion"></typeparam>
            <param name="learner"></param>
            <param name="schema"></param>
            <param name="doc"></param>
            <param name="positiveExamples"></param>
            <param name="negativeExamples"></param>
            <param name="k">Number of programs to learn</param>
            <param name="learnAll">If true, the program set will be generated.</param>
            <param name="converters">An array of converters</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.FlashExtractFieldProgram">
            <summary>
                This class represents a program to extract a substring or a sequence of substrings from a text file.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.FlashExtractFieldProgram._extractSequence">
            <summary>
            The flag indicates whether each region contains a substring or a sequence of substrings
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.FlashExtractFieldProgram._symbol">
            <summary>
            The grammar symbol of the program
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.FlashExtractFieldProgram.Score">
            <summary>
            The ranking score (the higher the better)
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.FlashExtractFieldProgram.ParseProgramXML(System.String)">
            <summary>
            Converts the <paramref name="code"/> to an XML element parseable to retrieve the program.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.FlashExtractFieldProgram.ToString">
            <summary>
                Return the serialized program
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.FlashExtractTextProgramLearner.MaxInputSize">
            <summary>
            When the length of the input file exceeds this number, FE takes every long time to learn.
            If that is the case, we trim the input file, do the learning on the trimmed file,
            and execute the learned program on the original file.
            Reducing this number will make the learning faster, but the disadvantage is it will 
            potentially increase the number of examples, because we can only verify the output on a
            (short) prefix of the file.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.FlashExtractTextProgramLearner.ExtraK">
            <summary>
            FlashMeta only learns k programs for each child. If all of these programs produce bad
            output (e.g., has null), the "best" program is "after" these k. We learn extra programs 
            with the hope that these extra programs contain the best program. The disadvantage is 
            learning time is larger.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.FlashExtractTextProgramLearner.LearnFieldProgram(System.Collections.Generic.IEnumerable{Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.FieldSpec{Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.StringRegion}},System.Int32)">
            <summary>
            Learn k most likely substring programs from multiple field specs <paramref name="fieldSpecs" />.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.FlashExtractTextProgramLearner.LearnFieldProgram(System.Collections.Generic.IEnumerable{Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.FieldSpec{Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.StringRegion}},System.Int32,System.Text.RegularExpressions.Regex,System.Text.RegularExpressions.Regex,System.Text.RegularExpressions.Regex)">
            <summary>
            Learn k most likely substring programs from multiple field specs <paramref name="fieldSpecs" /> and regex specs.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.FlashExtractTextProgramLearner.LearnSequenceProgram(System.Collections.Generic.IEnumerable{Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SequenceSpec{Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.StringRegion}},System.Int32)">
            <summary>
            Learn k most likely sequence programs from multiple sequence specs <paramref name="sequenceSpecs" />.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.FlashExtractTextProgramLearner.LearnSequenceProgram(System.Collections.Generic.IEnumerable{Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.SequenceSpec{Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.StringRegion}},System.Int32,System.Text.RegularExpressions.Regex,System.Text.RegularExpressions.Regex,System.Text.RegularExpressions.Regex)">
            <summary>
            Learn k most likely sequence programs from multiple sequence specs <paramref name="sequenceSpecs" /> and regex specs.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.FlashExtractTextProgramLearner.InferAdditionalNegatives(System.Collections.Generic.IEnumerable{Microsoft.PowerShell.Commands.StringManipulation.FlashExtract.Shared.FieldSpec{Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.StringRegion}})">
            <summary>
            Learn the implicit negative examples for field spec.
            If the specs contains A B C where only B has positive example, the entire input of A will become negative.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Witnesses.LearnRightMatches(Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.SynthesisContext,System.UInt32,System.UInt32,System.Int32,System.Boolean)">
            <summary>
                Learn a list of regexes that match <paramref name="pos" /> on its right. The match should not pass
                <paramref name="end" />. If <paramref name="matchExactLength" /> is set, will only return regexes that
                that will have matches of length end - pos
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Witnesses.LearnLeftMatches(Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.SynthesisContext,System.UInt32,System.UInt32,System.Int32)">
            <summary>
                Learn a list of regexes that match <paramref name="pos" /> on its left. The match should not pass
                <paramref name="start" />.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Witnesses.KInAbsPos(System.Tuple{Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Internal.State,Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.StringRegion,System.Collections.Generic.IEnumerable{System.Object}}[],System.Boolean,System.Boolean)">
            <summary>
            Learn possible absolute positions from multiple examples, each of which contains
            1. A state
            2. The learning boundary
            3. A list of position examples
            Additionally, we provide two parameters to specify whether we want forward and backward position
            (i.e., positive or negative k).
            </summary>        
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Witnesses.RRInRegPos(System.Tuple{Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Internal.State,Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.StringRegion,System.Collections.Generic.IEnumerable{System.Object}}[])">
            <summary>
            Learn possible regex pairs from multiple examples, each of which contains
            1. A state
            2. The context
            3. The learning boundary
            4. A list of position examples
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Witnesses.KInRegPos(System.Tuple{Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Internal.State,Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.StringRegion,System.Tuple{Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.RegularExpression,Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.RegularExpression},System.Collections.Generic.IEnumerable{System.Object}}[],System.Boolean,System.Boolean)">
            <summary>
            Learn possible k for regex positions from multiple examples, each of which contains
            1. A state
            2. The context
            3. The learning boundary
            4. The regex pair
            5. A list of position examples
            Additionally, we provide two parameters to specify whether we want forward and backward position
            (i.e., positive or negative k).
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.RegularExpression">
            <summary>
                A regular expression is a sequence of tokens. We limit its length to 3 for performance reason.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.RegularExpression.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token,Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token,Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.RegularExpression.Count">
            <summary>
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.RegularExpression.ExampleCount">
            <summary>
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.RegularExpression.Item(System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.RegularExpression.Run(Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.SynthesisContext)">
            <summary>
                Return all matching positions in a string
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.RegularExpression.Run(System.Tuple{Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.SynthesisContext,System.Tuple{System.UInt32,System.UInt32}})">
            <summary>
                Return all matching positions within a range in a string
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.RegularExpression.Run(Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.SynthesisContext,System.UInt32,System.UInt32)">
            <summary>
                Return all matching positions within a range in a string
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.RegularExpression.Score">
            <summary>
            The ranking score of the regular expression. The higher the better.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.RegularExpression.Regex">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.RegularExpression.MatchesAt(Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.SynthesisContext,System.UInt32)">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.RegularExpression.MatchesAt(Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.SynthesisContext,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.RegularExpression.LeftMatchesAt(Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.SynthesisContext,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.RegularExpression.Equals(System.Object)">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.RegularExpression.GetHashCode">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.RegularExpression.Render">
            <summary>
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.RegularExpression.Display">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.RegularExpression.ToString">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.RegularExpression.RenderXml">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.RegularExpression.TryParse(System.String)">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.RegularExpression.ToRegexString">
            <summary>
            Returns the associated complete regular expression.
            Use this to let the user re-match this regular expression on his text.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.RegularExpression.ToRegexJsonArray">
            <summary>
            Returns the associated complete regular expression.
            Use this to let the user re-match this regular expression on his text.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.RegularExpression.Create(System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.RegularExpression.Create(Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.RegularExpression.Create(Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token,Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.RegularExpression.Create(Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token,Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token,Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token,System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.RegularExpression.Create(Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token,Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.RegularExpression)">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.RegularExpression.Create(Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.RegularExpression,Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token)">
            <summary>
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token">
            <summary>
                A token is a sequence of characters of a particular kind.
                There are two kinds of token: static tokens (predefined) and dynamic tokens (string literal that are learned from
                the context)
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token.#ctor(System.Text.RegularExpressions.Regex,System.String,System.Int32,System.Boolean)">
            <summary>
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token.Name">
            <summary>
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token.Regex">
            <summary>
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token.Score">
            <summary>
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token.IsSymbol">
            <summary>
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token.IsDynamicToken">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token.TryParse(System.Xml.Linq.XElement)">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token.ToXml">
            <summary>
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token.MinScore">
            <summary>
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token.LineSeparatorName">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token.op_Equality(Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token,Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token)">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token.op_Inequality(Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token,Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token)">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token.Equals(Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token)">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token.Equals(System.Object)">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token.GetHashCode">
            <summary>
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token.Display">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token.ToString">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token.CompareTo(Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token)">
            <summary>
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.PositionMatch">
            <summary>
                A position match contains a matching position and a matching length (of a match of tokens or regular expressions).
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.PositionMatch.Position">
            <summary>
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.PositionMatch.Length">
            <summary>
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.PositionMatch.Right">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.PositionMatch.#ctor(System.UInt32,System.UInt32)">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.PositionMatch.Equals(Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.PositionMatch)">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.PositionMatch.Equals(System.Object)">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.PositionMatch.op_Equality(Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.PositionMatch,Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.PositionMatch)">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.PositionMatch.op_Inequality(Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.PositionMatch,Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.PositionMatch)">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.PositionMatch.GetHashCode">
            <summary>
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.TokenMatch">
            <summary>
            A token match is a token and its length.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.TokenMatch.Token">
            <summary>
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.TokenMatch.Length">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.TokenMatch.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token,System.UInt32)">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.TokenMatch.Equals(Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.TokenMatch)">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.TokenMatch.Equals(System.Object)">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.TokenMatch.GetHashCode">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.TokenMatch.op_Equality(Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.TokenMatch,Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.TokenMatch)">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.TokenMatch.op_Inequality(Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.TokenMatch,Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.TokenMatch)">
            <summary>
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.CachedList">
            <summary>
                The list that caches the values
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.CachedList.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.CachedList.#ctor(System.Collections.Generic.IEnumerable{Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.PositionMatch})">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.CachedList.GetValues(System.UInt32,System.UInt32)">
            <summary>
                Return the index span of the cached values within the range
            </summary>
            <param name="start">The beginning of the range</param>
            <param name="end">The end of the range</param>
            <returns>The index span of the cached values within the range</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.CachedList.BinarySearchForFirstGreaterOrEqual(System.UInt32)">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.CachedList.BinarySearchForFirstLessThanOrEqual(System.UInt32)">
            <summary>
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.SynthesisContext">
            <summary>
            Represent the context of tokens in extracting a particular string.
            It contains the tokens (both static and dynamics) and their matches in the string.
            Implemented as Singleton.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.SynthesisContext.Content">
            <summary>
            The (modified) string content
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.SynthesisContext.StartPosition">
            <summary>
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.SynthesisContext.EndPosition">
            <summary>
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.SynthesisContext.InputStartIsPrecise">
            <summary>
            Determine the validity of the start position of the boundary.
            True if this position is precise, which allows the program to make reference to the starting position.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.SynthesisContext.InputEndIsPrecise">
            <summary>
            Determine the validity of the end position of the boundary.
            True if this position is precise, which allows the program to make reference to the ending position.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.SynthesisContext.PrefixFieldRegex">
            <summary>
            Represent the prefix regex of the field. Serve as an additional spec.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.SynthesisContext.FieldRegex">
            <summary>
            Represent the regex of the field. Serve as an additional spec.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.SynthesisContext.SuffixFieldRegex">
            <summary>
            Represent the suffix regex of the field. Serve as an additional spec.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.SynthesisContext._tokens">
            <summary>
            All tokens in the context (both static and dynamic)
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.SynthesisContext._populatedStaticTokenCaches">
            <summary>
            The flag indicates that we have populated the caches for static tokens.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.SynthesisContext._startingTokenMatches">
            <summary>
            Store all matches that start at a position
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.SynthesisContext._startingStaticTokenMatches">
            <summary>
            Store all matches of static tokens that start at a position. We need it to reset the cache to the new context.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.SynthesisContext.TryGetAllMatchesStartingAt(System.UInt32,System.Collections.Generic.Dictionary{Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token,Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.TokenMatch}@)">
            <summary>
            Return true if there exist some tokens that match at <paramref name="pos"/>.
            Also return these token matches.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.SynthesisContext.TryGetTokenMatchStartingAt(System.UInt32,Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token,Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.TokenMatch@)">
            <summary>
            Return true if <paramref name="token"/> matches at the position <paramref name="pos"/>.
            Also return this match.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.SynthesisContext._endingTokenMatches">
            <summary>
            Store all matches that end at a position
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.SynthesisContext._endingStaticTokenMatches">
            <summary>
            Store all matches of static tokens that end at a position. We need it to reset the cache to the new context.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.SynthesisContext.TryGetAllMatchesEndingAt(System.UInt32,System.Collections.Generic.Dictionary{Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token,Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.TokenMatch}@)">
            <summary>
            Return true if there exist some tokens whose match end at <paramref name="pos"/>.
            Also return these token matches.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.SynthesisContext.TryGetTokenMatchEndingAt(System.UInt32,Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token,Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.TokenMatch@)">
            <summary>
            Return true if the match of <paramref name="token"/> ends at the position <paramref name="pos"/>.
            Also return this match.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.SynthesisContext._matchPositions">
            <summary>
            Store all matching position of all tokens
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.SynthesisContext._matchPositionsOfStaticTokens">
            <summary>
            Store all matching position of static tokens
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.SynthesisContext.TryGetMatchPositionsFor(Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token,Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.CachedList@)">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.SynthesisContext.#ctor(System.String)">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.SynthesisContext.AddStaticToken(Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.Token)">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.SynthesisContext.GetStaticTokenByName(System.String)">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.SynthesisContext.InitializeLearningContext(System.Collections.Generic.List{System.Tuple{System.UInt32,System.UInt32}},System.Boolean,System.Boolean,System.Text.RegularExpressions.Regex,System.Text.RegularExpressions.Regex,System.Text.RegularExpressions.Regex)">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.SynthesisContext.LearnAndAddDynamicTokensAt(System.Collections.Generic.List{System.UInt32})">
            <summary>
            Learn the (possible) dynamic tokens wrt the positive and negative examples.
            A dynamic token is a shared string that start/end at the beginning/end of the examples.
            In case we have only one example, we need to guess the dynamic tokens.
            Those are the words before/after the only example.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.Internal.SynthesisContext.FindAddDynamicToken(System.Collections.Generic.List{System.UInt32},System.Boolean)">
            <summary>
            If <paramref name="forwardDirection"/> is true, we find the shared string that starts from <paramref name="positions"/>.
            Otherwise, we find the shared string that ends at <paramref name="positions"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.StringRegion.CreateImplicitStructBoundaries(Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.StringRegion[],Microsoft.PowerShell.Commands.StringManipulation.FlashExtractText.Semantics.StringRegion[])">
            <summary>
            Creates implicit bounds from bounds and parent run. Should be run from the whole input file.
            </summary>
            <param name="parentRun"></param>
            <param name="childRun"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.FlashExtract.ExtractResults.RootSpan">
            <summary>
            The root of the result tree.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.FlashExtract.ExtractResults.InputText">
            <summary>
            The input text file EOL-normalized
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.FlashExtract.ExtractResults.RootProperty">
            <summary>
            The root of the property tree
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.FlashExtract.ExtractResults.UpdatedTemplates">
            <summary>
            The updated template with the learned programs
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.FlashExtract.FlashExtractCache">
            <summary>
            Class to cache programs from FlashExtractWrapper
            If the programs were already generated for some template, it reuses these programs
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.FlashExtract.FlashExtractCache.MaxCachedPrograms">
            <summary>
            Maximum number of cached program sets. A set of programs is the programs for a given template
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.FlashExtract.FlashExtractCache.FiveMinutes">
            <summary>
            Time for cleaning the caching
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.FlashExtract.FlashExtractCache._cachedPrograms">
            <summary>
            the programs are represented in a PropertyTree, each property has its respective program. 
            The dictionary key is the root property of each template file. 
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.FlashExtract.FlashExtractCache._cacheQueue">
            <summary>
            Queue for keeping the size of the dictionary up to MaxCachedPrograms
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.FlashExtract.FlashExtractCache.Programs">
            <summary>
            Only used by the unit tests. 
            </summary>
            todo: add a fxCop remove warning for production
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.FlashExtract.FlashExtractCache._timer">
            <summary>
            Timer for cleaning the cache every five minutes
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.FlashExtract.FlashExtractCache.instance">
            <summary>
            It has only one instance of the FlashExtractCache
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.FlashExtract.FlashExtractCache.AddProgram(System.Collections.Generic.List{Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.Property},Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.PropertyTree)">
            <summary>
            Adds a new program set (PropertyTree) to the cache. If the cache is full, removes the first program set.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.FlashExtract.FlashExtractCache.OnTimedEvent(System.Object,System.Timers.ElapsedEventArgs,Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.FlashExtract.FlashExtractCache)">
            <summary>
            It cleans the cached programs every 5 minutes
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.FlashExtract.FlashExtractDriver.UpdateTemplate">
            <summary>
            it defines whether FE updates the template content with the learned program 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.FlashExtract.FlashExtractDriver.MarkupTexts">
            <summary>
            original template text with markups and without the program section
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.FlashExtract.ProgramNotFoundException">
            <summary>
            Exception generated when FlashExtract cannot generate a program for
            the provided input text.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.FlashExtract.ProgramNotFoundException.#ctor">
            <summary>
            Creates a ProgramNotFoundException
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.FlashExtract.ProgramNotFoundException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a ProgramNotFoundException from a message and exception
            </summary>
            <param name="message"></param>
            <param name="exception"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.FlashExtract.ProgramNotFoundException.#ctor(System.String)">
            <summary>
            Creates a ProgramNotFoundException from a message
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.FlashExtract.ProgramNotFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Creates a ProgramNotFoundException from a serialization context
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.FlashExtract.ResultNotFoundException">
            <summary>
            Exception generated when FlashExtract cannot generate a program for
            the provided input text.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.FlashExtract.ResultNotFoundException.#ctor">
            <summary>
            Creates a ResultNotFoundException
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.FlashExtract.ResultNotFoundException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a ResultNotFoundException from a message and exception
            </summary>
            <param name="message"></param>
            <param name="exception"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.FlashExtract.ResultNotFoundException.#ctor(System.String)">
            <summary>
            Creates a ResultNotFoundException from a message
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.FlashExtract.ResultNotFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Creates a ResultNotFoundException from a serialization context
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.TemplateParsing.ParserResults.Examples">
            <summary>
            All Spans in the file, in file order by Start.
            it is using by the testing infraestructure
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.TemplateParsing.ParserResults.PropertyTree">
            <summary>
            The parsed tree of Properties.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.TemplateParsing.ParserResults.StrippedTemplateFile">
            <summary>
            The text of the template file, with markup removed.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.TemplateParsing.ParserResults.TemplateText">
            <summary>
            Original text of the template file without the program section
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.TemplateParsing.ParserSpan.MarkupStartLine">
            <summary>
            The starting line of the span in the markup file; used for error reporting.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.TemplateParsing.ParserSpan.MarkupStartChar">
            <summary>
            The starting char (on the starting line) of the span in the markup file; used for error reporting
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.TemplateParsing.ParserSpan.StrippedValueStart">
            <summary>
            The start position in the stripped template file of the value for this span.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.TemplateParsing.ParserSpan.End">
            <summary>
            Provides 'set' functionality to the otherwise immutable base Span property, as we build this up
            during parsing.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.TemplateParsing.ParserSpan.Type">
            <summary>
            The type of the Span's data.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.TemplateParsing.ParserSpan.TypeFormatString">
            <summary>
            Any format string associated with the span's type.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.TemplateParsing.ParserSpan.IsOptional">
            <summary>
            Whether the Span is optional (i.e. missing values are supported).
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.TemplateParsing.ParserSpan.IsStruct">
            <summary>
            If true, this is a structure; it contains nested Spans rather than a value.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.TemplateParsing.ParserSpan.IsSequence">
            <summary>
            If true, there are multiple occurrences of this property in the parent (or root).
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.TemplateParsing.TemplateParsingException">
            <summary>
            Exception generated when FlashExtract cannot generate a program for
            the provided input text.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.TemplateParsing.TemplateParsingException.#ctor">
            <summary>
            Creates a TemplateParsingException
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.TemplateParsing.TemplateParsingException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a TemplateParsingException from a message and exception
            </summary>
            <param name="message"></param>
            <param name="exception"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.TemplateParsing.TemplateParsingException.#ctor(System.String)">
            <summary>
            Creates a TemplateParsingException from a message
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.TemplateParsing.TemplateParsingException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Creates a TemplateParsingException from a serialization context
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.TemplateParsing.TemplateReader.TemplateText">
            <summary>
            The original text of the template file witout the learned program section
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.TemplateParsing.TemplateReader.markupLines">
            <summary>
            The array of lines of the file.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.TemplateParsing.TemplateReader.StrippedFile">
            <summary>
            The file stripped of markup (including escapes).
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.TemplateParsing.TemplateReader.markupLineIndex">
            <summary>
            Index of the current line in the markup file.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.TemplateParsing.TemplateReader.nextMarkupLineCharIndex">
            <summary>
            Index of the current char in the current markup line.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.TemplateParsing.TemplateReader.strippedFileCharIndex">
            <summary>
            Index of the current character of the current line, not including by escaped chars and brackets.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.TemplateParsing.TemplateReader.state">
            <summary>
            The current FSA state.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.TemplateParsing.TemplateReader.spanIndex">
            <summary>
            Index of the curren span.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.TemplateParsing.TemplateReader.CompletedSpans">
            <summary>
            All Spans in the file, in file order by Start.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.TemplateParsing.TemplateReader.UpdateTemplate">
            <summary>
            If it is true, it does not parse the embedded program section since it will be re-learned
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.TemplateParsing.TemplateReader.MarkupLine">
            <summary>
            The line of markup currently being processed.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.TemplateParsing.TemplateReader.currentSpans">
            <summary>
            The stack of Spans currently being processed; if there are nested spans then the stack depth is > 1.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.TemplateParsing.TemplateReader.CurrentSpan">
            <summary>
            The current span being processed, if any.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.TemplateParsing.TemplateReader.CurrentSpanDepth">
            <summary>
            The nesting level within brackets.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.TemplateParsing.TemplateReader.LineCount">
            <summary>
            The number of lines in the file.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.Property.Name">
            <summary>
            Name of the Property; set by the UI or read from one of the persisted formats.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.Property.Type">
            <summary>
            The type of the Property.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.Property.TypeFormatString">
            <summary>
            Any format string associated with the Property's type.  // TODO doc: last one wins
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.Property.IsOptional">
            <summary>
            Whether the Span is optional (i.e. missing values are supported).
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.Property.IsStruct">
            <summary>
            If true, this is a structure; it contains nested Spans rather than a value.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.Property.IsSequence">
            <summary>
            If true, there are multiple occurrences of this property in the parent (or root).
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.Property.IsImplicit">
            <summary>
            This is a structure inferred from the layout rather than an explicitly selected region
            containing nested regions.  Used only by the UI.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.Property.PositiveExamples">
            <summary>
            Positive examples, either set by the UI or read from one of the persisted formats.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.Property.NegativeExamples">
            <summary>
            Positive examples, either set by the UI or read from one of the persisted formats.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.Property.Spans">
            <summary>
            The list of Spans associated with this property.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.Property.Parent">
            <summary>
            The hierarchical parent of this Property.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.Property.IsRoot">
            <summary>
            Indicates whether this is the root (pseudo)property of the PropertyTree.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.Property.Children">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.Property.AddChild(Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.Property)">
            <summary>
            Add a child to our list of children.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.PropertyTree.CreateFromParserSpans(System.Collections.Generic.List{Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.TemplateParsing.ParserSpan},System.UInt32)">
            <summary>
            Creates a PropertyTree populated with Properties that are explicit structs and Spans.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.Span.Positions">
            <summary>
            The tuple of positions; immutable after Span creation (except for ParserSpan).
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.Span.Start">
            <summary>
            The starting position (in non-markup terms) of the Span.  Syntactic sugar.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.Span.End">
            <summary>
            The ending position (in non-markup terms) of the Span.  Syntactic sugar.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.Span.IsPositive">
            <summary>
            Whether the Span is a positive or negative example.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.Span.ExampleValue">
            <summary>
            The Span's example value, as a string.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.Span.Property">
            <summary>
            The Property for this Span (after processing the completed span hierarchy).
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.Span.Children">
            <summary>
            Children of this Span in the SpanTree
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.SpanTree.GetCurrentParentRegion(Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.Span[],Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.Span,Microsoft.PowerShell.Commands.StringManipulation.FlashExtractWrapper.Span,System.Int32@)">
            <summary>
            Determines if currentRegion contains the span and if not, increments the current parentRegionIndex
            and keeps trying.  This assumes the returned spans and parent regions are always in the same order.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashFill.Semantics.Witnesses.WitnessRegPosRR(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Rules.BlackBoxRule,System.Int32,Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Specifications.DisjunctiveExamplesSpecification)">
            <summary>
            Learns RR.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashFill.Semantics.Witnesses.WitnessRegPosK(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Rules.BlackBoxRule,System.Int32,Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Specifications.DisjunctiveExamplesSpecification,Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Specifications.ExamplesSpecification)">
            <summary>
            Learns K.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.AST.ProgramNode.GrammarRule">
            <summary>
            Returns the grammar rule associated with this node, or null otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.AST.ProgramNode.AcceptVisitor``1(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.AST.ProgramNodeVisitor{``0})">
            <summary>
            Returns the value computed by the hierarchical application of the <paramref name="visitor"/> instance.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.AST.Extensions.ProgramNodeExtensions.PreTraverse(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.AST.ProgramNode,System.Action{Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.AST.ProgramNode})">
            <summary>
             Applies a callback to each descendant, starting with itself. Returns this for chaining purposes.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.AST.Extensions.ProgramNodeExtensions.PreMap(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.AST.ProgramNode,System.Func{Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.AST.ProgramNode,System.Int32,Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.AST.ProgramNode,Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.AST.ProgramNode},Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.AST.ProgramNode,System.Int32)">
            <summary>
             Transforms a programNode to another using the given function.
             Clones the programNode if the transformation returned null.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.AST.Extensions.ProgramNodeExtensions.PostTraverse(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.AST.ProgramNode,System.Action{Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.AST.ProgramNode})">
            <summary>
             Applies a callback to each descendant, ending with itself
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Core_ReferenceNotFound">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Referenced file not found: {0}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Core_ReferenceNotFound.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Referenced file not found: {0}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Core_TypeLocationNotFound">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Type {0} is not found in any of the referenced assemblies. Check that it is internal and is in scope of all imported namespaces.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Core_TypeLocationNotFound.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Type {0} is not found in any of the referenced assemblies. Check that it is internal and is in scope of all imported namespaces.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Core_TypeIsNotStatic">
            <summary>
            Represents a diagnostic that produces a warning message similar to: &quot;Type {0} should be a internal static class.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Core_TypeIsNotStatic.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces a warning message similar to: &quot;Type {0} should be a internal static class.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Core_MemberNotFound">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Member {0} not found in the specified class {1}. Check that it is internal and static.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Core_MemberNotFound.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Member {0} not found in the specified class {1}. Check that it is internal and static.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Core_UnknownReferenceType">
            <summary>
            Represents a diagnostic that produces a warning message similar to: &quot;Cannot load a reference from the file &apos;{0}&apos;. Currently supported references are: .NET assemblies (.dll/.exe), FlashMeta compiled grammars (.grammar.xml).&quot;
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Core_UnknownReferenceType.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces a warning message similar to: &quot;Cannot load a reference from the file &apos;{0}&apos;. Currently supported references are: .NET assemblies (.dll/.exe), FlashMeta compiled grammars (.grammar.xml).&quot;
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Core_UnknownExternalGrammar">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Unknown external language: &apos;{0}&apos;.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Core_UnknownExternalGrammar.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Unknown external language: &apos;{0}&apos;.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Core_UnknownSymbol">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Symbol {0} was not found in the language {1}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Core_UnknownSymbol.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Symbol {0} was not found in the language {1}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Features_UnknownFeature">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Feature &apos;{0}&apos; was not found in the language {1}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Features_UnknownFeature.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Feature &apos;{0}&apos; was not found in the language {1}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Features_IncompatibleCalculatorReturnType">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;In the feature calculator {0}, return type {1} cannot be converted to the required feature type {2}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Features_IncompatibleCalculatorReturnType.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;In the feature calculator {0}, return type {1} cannot be converted to the required feature type {2}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Features_NoFeatureCalculator">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;No &apos;{0}&apos; feature calculator was found for the rule {1}. Please define a internal static function in the class {2} and mark it with [FeatureCalculator] attribute.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Features_NoFeatureCalculator.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;No &apos;{0}&apos; feature calculator was found for the rule {1}. Please define a internal static function in the class {2} and mark it with [FeatureCalculator] attribute.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Features_VarDefaultNotFound">
            <summary>
            Represents a diagnostic that produces a warning message similar to: &quot;No &apos;{0}&apos; member was found in the class {1} as a variable default for the feature &apos;{2}&apos;. {3} will be used instead.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Features_VarDefaultNotFound.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces a warning message similar to: &quot;No &apos;{0}&apos; member was found in the class {1} as a variable default for the feature &apos;{2}&apos;. {3} will be used instead.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Features_NoLearningInfoParameter">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Expected a learning info parameter of type IDictionary&lt;string, object&gt; as the first parameter.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Features_NoLearningInfoParameter.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Expected a learning info parameter of type IDictionary&lt;string, object&gt; as the first parameter.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Features_ExpectedNonterminalCalculator">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;In nonterminal feature calculator {0}, parameter &apos;{1}&apos; has type {2}, expected a type derived from ProgramNode.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Features_ExpectedNonterminalCalculator.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;In nonterminal feature calculator {0}, parameter &apos;{1}&apos; has type {2}, expected a type derived from ProgramNode.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Features_ExpectedLiteralCalculator">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Literal feature calculator {0} has {1} parameters, expected {2}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Features_ExpectedLiteralCalculator.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Literal feature calculator {0} has {1} parameters, expected {2}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Features_ExpectedRecursiveCalculator">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;In feature &apos;{0}&apos; calculator {1}, parameter &apos;{2}&apos; has type {3}, expected {4}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Features_ExpectedRecursiveCalculator.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;In feature &apos;{0}&apos; calculator {1}, parameter &apos;{2}&apos; has type {3}, expected {4}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Features_AmbiguousFeatureCalculator">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Ambiguous &apos;{0}&apos; feature calculator for the rule {1}: cannot choose between {2} and {3}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Features_AmbiguousFeatureCalculator.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Ambiguous &apos;{0}&apos; feature calculator for the rule {1}: cannot choose between {2} and {3}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Syntax_SymbolCircularDependency">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Circular symbol dependency detected: {0}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Syntax_SymbolCircularDependency.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Circular symbol dependency detected: {0}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Syntax_NoStartSymbols">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;No start symbols found. Please mark one of the nonterminals of the language as @start.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Syntax_NoStartSymbols.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;No start symbols found. Please mark one of the nonterminals of the language as @start.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Syntax_MoreThanOneStart">
            <summary>
            Represents a diagnostic that produces a warning message similar to: &quot;More then one start symbol detected: {0}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Syntax_MoreThanOneStart.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces a warning message similar to: &quot;More then one start symbol detected: {0}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Syntax_NoInputSymbols">
            <summary>
            Represents a diagnostic that produces a warning message similar to: &quot;No input symbols found. Please mark one of the terminals of the language as @input.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Syntax_NoInputSymbols.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces a warning message similar to: &quot;No input symbols found. Please mark one of the terminals of the language as @input.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Syntax_MoreThanOneInput">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;More then one input symbol detected: {0}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Syntax_MoreThanOneInput.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;More then one input symbol detected: {0}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Syntax_ConceptParametersShouldBeArguments">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;In concept rule {0}, the set of formal parameters {1} on the left-hand side should be equal to the set of the unbound symbols {2} on the right-hand side.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Syntax_ConceptParametersShouldBeArguments.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;In concept rule {0}, the set of formal parameters {1} on the left-hand side should be equal to the set of the unbound symbols {2} on the right-hand side.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Syntax_IncompatibleSymbolTypes">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Symbol {0} has type {1}, but is initialized with a symbol {2}, which has type {3}&quot;
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Syntax_IncompatibleSymbolTypes.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Symbol {0} has type {1}, but is initialized with a symbol {2}, which has type {3}&quot;
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Semantics_NoSemantics">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;No semantics found for the rule {0}. Expected a function with signature &apos;internal static {1} {0}({2})&apos; in any of the semantics locations.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Semantics_NoSemantics.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;No semantics found for the rule {0}. Expected a function with signature &apos;internal static {1} {0}({2})&apos; in any of the semantics locations.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Semantics_AmbiguousSemantics">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Ambiguous semantics for the rule {0}: cannot choose between {1} and {2}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Semantics_AmbiguousSemantics.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Ambiguous semantics for the rule {0}: cannot choose between {1} and {2}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Semantics_IncompatibleSemanticsReturnType">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Semantics function {0} returns {1}, expected {2}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Semantics_IncompatibleSemanticsReturnType.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Semantics function {0} returns {1}, expected {2}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Semantics_IncompatibleConceptArgumentType">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Invalid type {0} of symbol {1}: the concept &apos;{2}&apos; expects an argument of type {3} here.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Semantics_IncompatibleConceptArgumentType.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Invalid type {0} of symbol {1}: the concept &apos;{2}&apos; expects an argument of type {3} here.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Semantics_IncompatibleConceptResultType">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Invalid type {0} of symbol {1}: the concept &apos;{2}&apos; returns a type {3} here.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.Semantics_IncompatibleConceptResultType.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Invalid type {0} of symbol {1}: the concept &apos;{2}&apos; returns a type {3} here.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.TopDownLearning_WitnessHolderNotFound">
            <summary>
            Represents a diagnostic that produces a warning message similar to: &quot;Witness holder {0} is not found in any of the referenced assemblies. Check that it is a internal static class.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.TopDownLearning_WitnessHolderNotFound.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces a warning message similar to: &quot;Witness holder {0} is not found in any of the referenced assemblies. Check that it is a internal static class.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.TopDownLearning_TacticNotFound">
            <summary>
            Represents a diagnostic that produces a warning message similar to: &quot;Tactic class {0} is not found in any of the referenced assemblies. Check that it is a internal static class.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.TopDownLearning_TacticNotFound.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces a warning message similar to: &quot;Tactic class {0} is not found in any of the referenced assemblies. Check that it is a internal static class.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.TopDownLearning_IgnoredTerminalWitnesses">
            <summary>
            Represents a diagnostic that produces a warning message similar to: &quot;Illegal witness function specification for the terminal rule {0}, ignored.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.TopDownLearning_IgnoredTerminalWitnesses.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces a warning message similar to: &quot;Illegal witness function specification for the terminal rule {0}, ignored.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.TopDownLearning_IncompatibleWitnessRuleType">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Witness function {0} expects rule type {1} as its first parameter, but the rule {2} has type {3}, which cannot be converted to {1}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.TopDownLearning_IncompatibleWitnessRuleType.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Witness function {0} expects rule type {1} as its first parameter, but the rule {2} has type {3}, which cannot be converted to {1}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.TopDownLearning_IncompatibleWitnessSignature">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Expected a witness function with a signature deriving from (GrammarRule rule, int parameter, InductiveSpecification outerSpec, [, object userData] [, InductiveSpecification prereqs...]) -&gt; InductiveSpecification.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.TopDownLearning_IncompatibleWitnessSignature.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Expected a witness function with a signature deriving from (GrammarRule rule, int parameter, InductiveSpecification outerSpec, [, object userData] [, InductiveSpecification prereqs...]) -&gt; InductiveSpecification.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.TopDownLearning_IncompatibleWitnessPrereqTypes">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Expected either a last parameter of type InductiveSpecification[], or last {0} parameters of types deriving InductiveSpecification as prerequisites.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.TopDownLearning_IncompatibleWitnessPrereqTypes.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Expected either a last parameter of type InductiveSpecification[], or last {0} parameters of types deriving InductiveSpecification as prerequisites.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.TopDownLearning_IncompatibleWitnessParameter">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;In the witness function {0}, the parameter specification is out of range of valid parameters for the body of the rule {1}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Diagnostic.TopDownLearning_IncompatibleWitnessParameter.#ctor(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;In the witness function {0}, the parameter specification is out of range of valid parameters for the body of the rule {1}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Result`1">
            <summary>
            Represents a result of a computation that can fail, along with a list of diagnostics, collected during a computation.
            For a successful result, the property <see cref="P:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Diagnostics.Result`1.Value"/> contains the result of computation, null otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Rules.Concepts.ConceptRule.GetParameterPositionInConcept(System.Int32)">
            <summary>
            Given a parameter index in the DSL operator, returns the position of the corresponding child in the concept implementation 
            as a coordinate path.
            </summary>
            <param name="dslParameterIndex">The index of the requested child in the list of DSL operator parameters</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Rules.Concepts.ConceptParameterUsage">
            <summary>
            Describe usage properties of a parameter of a concept rule as an argument in its concept implementation.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Rules.Concepts.ParameterUsage">
            <summary>
            How the formal parameter corresponds to the concept argument? It can be either used directly as an argument
            symbol, or passed on to the argument symbol as a child (if the argument symbol is a lambda symbol or another
            concept).
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Rules.BlackBoxRule.BlackBoxSemantics">
            <summary>
            The semantics of a black-box rule: ?f(N1, ..., N?)? s = f(?N1? s, ..., ?N?? s).
            Such a function does not change its given state s during execution, therefore it is not given this state explicitly.
            </summary>
            <param name="args">The values of the evaluated argument nodes: [?N1? s, ..., ?N?? s].</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Rules.NonterminalRule.ValidStateFromArgumentInvocations(System.Tuple{Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Internal.State,System.Object}[])">
            <summary>
            Constructs a valid State with which this rule should have been invoked to produce the given 
            <param name="argumentInvocations">states and values</param> for its parameter invocations.
            </summary>
            <returns>Null if the given states are incompatible with the rule logic; a valid State otherwise.</returns>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Internal.Rules.GrammarRule.WitnessesHolder">
            <summary>
            Optional user-defined class that holds witness functions for the parameters of this rule.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Internal.Rules.GrammarRule.RecursionLimit">
            <summary>
            A list of recursion limits for each body parameter; "nothing" if the parameter is not recursive, or recursion is unlimited.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Internal.Rules.GrammarRule.AddWitnessFunction(System.Reflection.MethodInfo,System.Int32,Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Internal.Synthesis.WitnessFunctionAttribute)">
            <summary>
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Internal.Synthesis.WitnessFunctionAttribute">
            <summary>
            </summary>    
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Internal.Synthesis.WitnessFunctionAttribute.DependsOnSymbols">
            <summary>
            </summary>        
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Internal.Synthesis.WitnessFunctionAttribute.DependsOnParameters">
            <summary>
            </summary>       
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Internal.Synthesis.WitnessFunctionAttribute.Verify">
            <summary>
            True if the produced specification does not guarantee compositional equivalence of the learned program spaces
            for the rule parameters, and the composed programs should be verified.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Internal.ASTSerializationFormat">
            <summary>
            The format of serialization of AST into strings. Used in <see cref="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Internal.Symbol.ParseAST(System.String,Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Internal.ASTSerializationFormat)"/> and <see cref="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Grammar.ParseAST(System.String,Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Internal.ASTSerializationFormat)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Internal.Symbol.TryGetAllPrograms(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.BindingManager,System.Boolean)">
            <summary>
            Returns a set of all possible programs in the grammar that this symbol can expand to, or <see cref="F:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Utils.Optional`1.Nothing"/> if 
            the set is undefined due to unlimited recursion or unrestricted literals without explicit value generators on the leaf level.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Specifications.InductiveSpecification.TransformInputs(System.Func{Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Internal.State,Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Internal.State})">
            <summary>
            Produces a copy of this <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Specifications.InductiveSpecification"/> where the provided inputs are transformed with a given
            transformer function <paramref name="transformer"/>, and the associated constrains on the inputs remain the same.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Specifications.SubsequenceSpecification">
            <summary>
                An output of the program is a set of objects.
                A specification provides a subset of the output on a given input. An invocation of a program on the same input
                is valid if its output is a superset of the example output.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Specifications.SubsequenceWithNegativesSpecification">
            <summary>
                An output of the program is a set of objects.
                A specification provides a subset of the output on a given input an a set of elements that are not part of the
                output.
                An invocation of a program on the same input is valid if its output is a superset of the example output.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Specifications.TopSpecification">
            <summary>
            A trivial specification that stores no inputs, and is satisfied by any program.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.VersionSpace.ProgramSet.FindSetDepthFirst(System.Predicate{Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.VersionSpace.ProgramSet},System.Predicate{Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.VersionSpace.ProgramSet})">
            <summary>
            Starting at this program set, traverse the tree of program sets among the first children for which the predicate is true.
            Returns the last program set for which the predicate is true but false for all of its children.
            </summary>
            <param name="predicate">A function telling if the program set is the one we are looking for</param>
            <param name="traverseChildren">Optional: A function telling if we should traverse the set's children</param>
            <returns>The last program set for which the predicate is true but false for all of its children</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.VersionSpace.ProgramSet.Intersect(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.VersionSpace.ProgramSet)">
            <summary>
            Intersects this program set with another program set <paramref name="other" />, producing a concise
            representation of the program set that consists of all programs in both this program set 
            and the <paramref name="other" />.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.VersionSpace.ProgramSet.LeafSetSize">
            <summary>
            The minimum size of a program set that will be represented as a version space algebra.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.VersionSpace.ProgramSet.FindChildSet(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.AST.ProgramNode,System.Int32)">
            <summary>
            Returns the ProgramSet corresponding to the child; given that this ProgramSet can represent the parent.
            </summary>
            <param name="node">The parent (member of this ProgramSet)</param>
            <param name="indexInParent">The index of child in the parent's children</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.VersionSpace.ProgramSet.Contains(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.AST.ProgramNode)">
            <summary>
            Returns true iff this <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.VersionSpace.ProgramSet"/> instance contains the given program as a set.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Grammar.FreeVariableHeight">
            <summary>
            Returns the maximal number of free variables that can appear in any path from the root to leaves, 
            or <see cref="F:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Utils.Optional`1.Nothing"/> if it can be infinite.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Utils.CollectionUtils.Yield``1(``0)">
            <summary>
            Wraps this object instance into an IEnumerable&lt;T&gt;
            consisting of a single item.
            </summary>
            <typeparam name="T"> Type of the wrapped object.</typeparam>
            <param name="item"> The object to wrap.</param>
            <returns>
            An IEnumerable&lt;T&gt; consisting of a single item.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Utils.CSharpUtils.ResolveCSharpTypeName(System.String,System.Collections.Generic.IEnumerable{System.String},System.Tuple{System.String,System.Type}[],System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            Converts a C# type alias or a type name into the corresponding .NET type, using standard C# resolution rules.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Utils.MethodUtils.ToDelegateWithParams``1(System.Reflection.MethodInfo)">
            <summary>
            Creates a fast typed delegate from a runtime method information. The delegate is assumed to be of a kind
            Func&lt;T1, T2, ..., Tk, object[], object&gt;. In other words, the delegate takes several first parameters
            directly, and the rest via the residual object[] array (usually specified as a variable-length parameter on
            the calling side). The technique is explained at 
            https://msmvps.com/blogs/jon_skeet/archive/2008/08/09/making-reflection-fly-and-exploring-delegates.aspx#1644203
            </summary>
            <typeparam name="TDelegate">A delegate of a kind Func&lt;T1, T2, ..., Tk, object[], object&gt;</typeparam>
            <param name="method">MethodInfo of an external method to convert. Must be static and consistent with TDelegate.</param> 
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Utils.MethodUtils.ToInstanceDelegate``1(System.Reflection.MethodInfo)">
            <summary>
            Creates a compiled delegate similarly to <see cref="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Utils.MethodUtils.ToDelegate``1(System.Reflection.MethodInfo)"/>, but from an instance method instead of a shared
            method.
            </summary>
            <typeparam name="TDelegate">The delegate type. The first argument in its signature has to be an instance to call upon.</typeparam>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Utils.MultiValueDictionary`2">
            <summary>
            A dictionary that holds multiple items with the same key.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Utils.MultiValueDictionary`2.Add(`0,`1)">
            <summary>
            </summary>  
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Utils.MultiValueDictionary`2.AddRange(`0,`1[])">
            <summary>
            </summary>  
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Utils.StringUtils.Slice(System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Int32)">
            <summary>
            Creates a "pythonic" slice of a string. See http://stackoverflow.com/questions/509211/pythons-slice-notation
            </summary>
            <param name="str">String to slice</param>
            <param name="start">Slice start, inclusive. Negative to count from the end of the string.</param>
            <param name="end">Slice end, exclusive. Negative to count from the end of the string.</param>
            <param name="step">Slice step. Positive for forward slicing direction, negative for backward.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Utils.StringUtils.LongestCommonSubstrings(System.Collections.Generic.IEnumerable{System.String},System.Int32,System.Boolean,System.Int32)">
            <summary>
            Finds a set of longest common substrings in a set of strings
            </summary>
            <param name="strings">Input set of strings</param>
            <param name="minLength">Minimum length of the substring</param>
            <param name="splitLines">Split string beforeheand on line boundaries?</param>
            <param name="maxLength">Maximum length of the substring</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Synthesis.Strategies.ComponentBasedSynthesis.LearnerState">
            <summary>
            In a state <see cref="P:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Synthesis.Strategies.ComponentBasedSynthesis.LearnerState.State"/> the program <see cref="P:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Synthesis.Strategies.ComponentBasedSynthesis.LearnerState.Program"/> produced the value <see cref="P:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Synthesis.Strategies.ComponentBasedSynthesis.LearnerState.ValueTuple"/>.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Synthesis.Strategies.TopDownSynthesis">
            <summary>
            The TopDown strategy, in which we need to explore various Tactics for RHS rule enumeration and invocation of
            witness functions.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Synthesis.Strategies.TopDownSynthesis.LearnRuleFromWitnesses(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Synthesis.SynthesisEngine,Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Internal.Rules.GrammarRule,Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Synthesis.LearningTask{Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Specifications.InductiveSpecification},System.Threading.CancellationToken)">
            <summary>
            0. If there are any preferred tactics for the rule, launch them first. Otherwise proceed to manual learning.
            1. Given a rule/spec, collect all witness functions for rule parameters that have been defined for this
               rule/spec type. Some of them may be dependent on other witness functions.
            2. Build a dependency graph of witness functions. Any topsort of this graph is a valid computation path.
               In future, we may consider exploring multiple combinations of witness functions and doing some kind of
               local search on "whether this particular choice of parameter spec is productive for its learning".
            3. Make a topsort and calculate the parameters in order.
            4. Apply the specified combiner. By default it is the "combinatorial" combiner, but can also be
               a "learn-and-verify" combiner, or any other one, if the user has specified it.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Synthesis.LearningTask">
            <summary>
            A task that consolidates all the information required for the learning API call: the symbol, specification, and additional request parameters.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Synthesis.LearningTask.Symbol">
            <summary>
            The root symbol for which a caller wants to synthesize programs.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Synthesis.LearningTask.Specification">
            <summary>
            The specification that the synthesized programs have to satisfy.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Synthesis.LearningTask.AdditionalInputs">
            <summary>
            Optional additional representative inputs, provided during the learning process
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Synthesis.LearningTask.RecursionDepths">
            <summary>
            The number of times grammar symbols appeared in the synthesis call stack up to and including this call.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Synthesis.LearningTask.K">
            <summary>
            An optional restriction on the number of synthesized programs. 
            A caller may request only top-K programs according to the specified feature value.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Synthesis.LearningTask.Feature">
            <summary>
            An optional ranking feature for selecting top-k synthesized programs. 
            A caller may request only top-K programs according to the specified feature value.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Synthesis.LearningTask.ProvidedInputs">
            <summary>
            Returns a union of all input states provided in the task: the ones embedded in the specification and the ones provided additionally.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Synthesis.LearningTask.MakeSubtask(Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Internal.Symbol,Microsoft.PowerShell.Commands.StringManipulation.FlashMeta.Core.Specifications.Specification)">
            <summary>
            Creates a parameter learning subtask from a given learning task, and updates the tracked recursion info.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Generic.IHashKeyCollection`1">
            <summary>
            Defined on a generic collection that hashes its contents using an <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>.
            </summary>
            <typeparam name="TKey">The type of element hashed in the collection.</typeparam>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Generic.IHashKeyCollection`1.KeyComparer">
            <summary>
            Gets the comparer used to obtain hash codes for the keys and check equality.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Generic.ISortKeyCollection`1">
            <summary>
            Defined on a generic collection that sorts its contents using an <see cref="T:System.Collections.Generic.IComparer`1"/>.
            </summary>
            <typeparam name="TKey">The type of element sorted in the collection.</typeparam>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Generic.ISortKeyCollection`1.KeyComparer">
            <summary>
            Gets the comparer used to sort keys.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.DisposableEnumeratorAdapter`2">
            <summary>
            An adapter that allows a single foreach loop in C# to avoid
            boxing an enumerator when possible, but fallback to boxing when necessary.
            </summary>
            <typeparam name="T">The type of value to be enumerated.</typeparam>
            <typeparam name="TEnumerator">The type of the enumerator struct.</typeparam>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.DisposableEnumeratorAdapter`2._enumeratorObject">
            <summary>
            The enumerator object to use if not null.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.DisposableEnumeratorAdapter`2._enumeratorStruct">
            <summary>
            The enumerator struct to use if <see cref="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.DisposableEnumeratorAdapter`2._enumeratorObject"/> is <c>null</c>.
            </summary>
            <remarks>
            This field must NOT be readonly because the field's value is a struct and must be able to mutate
            in-place. A readonly keyword would cause any mutation to take place in a copy rather than the field.
            </remarks>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.DisposableEnumeratorAdapter`2.#ctor(`1)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.DisposableEnumeratorAdapter`2"/> struct
            for enumerating over a strongly typed struct enumerator.
            </summary>
            <param name="enumerator">The initialized enumerator struct.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.DisposableEnumeratorAdapter`2.#ctor(System.Collections.Generic.IEnumerator{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.DisposableEnumeratorAdapter`2"/> struct
            for enumerating over a (boxed) <see cref="T:System.Collections.Generic.IEnumerable`1"/> enumerator.
            </summary>
            <param name="enumerator">The initialized enumerator object.</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.DisposableEnumeratorAdapter`2.Current">
            <summary>
            Gets the current enumerated value.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.DisposableEnumeratorAdapter`2.MoveNext">
            <summary>
            Moves to the next value.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.DisposableEnumeratorAdapter`2.Dispose">
            <summary>
            Disposes the underlying enumerator.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.DisposableEnumeratorAdapter`2.GetEnumerator">
            <summary>
            Returns a copy of this struct. 
            </summary>
            <remarks>
            This member is here so that it can be used in C# foreach loops.
            </remarks>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IBinaryTree">
            <summary>
            An interface for binary tree nodes that allow our common enumerator to walk the graph.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IBinaryTree.Height">
            <summary>
            Gets the depth of the tree below this node.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IBinaryTree.IsEmpty">
            <summary>
            Gets a value indicating whether this node is empty.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IBinaryTree.Count">
            <summary>
            Gets the number of non-empty nodes at this node and below.
            </summary>
            <exception cref="T:System.NotSupportedException">Thrown if the implementation does not store this value at the node.</exception>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IBinaryTree.Left">
            <summary>
            Gets the left branch of this node.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IBinaryTree.Right">
            <summary>
            Gets the right branch of this node.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IBinaryTree`1">
            <summary>
            An interface for binary tree nodes that allow our common enumerator to walk the graph.
            </summary>
            <typeparam name="T">The type of value for each node.</typeparam>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IBinaryTree`1.Value">
            <summary>
            Gets the value represented by the current node.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IBinaryTree`1.Left">
            <summary>
            Gets the left branch of this node.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IBinaryTree`1.Right">
            <summary>
            Gets the right branch of this node.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableArray">
            <summary>
            An internal non-generic interface implemented by ImmutableArray{T}
            that allows for recognition of an ImmutableArray{T} instance and access
            to its underlying array, without actually knowing the type of value
            stored in it.
            </summary>
            <remarks>
            Casting to this interface requires a boxed instance of the ImmutableArray{T} struct,
            and as such should be avoided. This interface is useful, however, where the value
            is already boxed and we want to try to reuse immutable arrays instead of copying them.
            ** This interface is INTENTIONALLY INTERNAL, as it gives access to the inner array.  **
            </remarks>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableArray.Array">
            <summary>
            Gets an untyped reference to the array.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2">
            <summary>
            An immutable key-value dictionary. 
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2.Clear">
            <summary>
            Gets an empty dictionary with equivalent ordering and key/value comparison rules.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2.Add(`0,`1)">
            <summary>
            Adds the specified key and value to the dictionary.
            </summary>
            <param name="key">The key of the entry to add.</param>
            <param name="value">The value of the entry to add.</param>
            <returns>The new dictionary containing the additional key-value pair.</returns>
            <exception cref="T:System.ArgumentException">Thrown when the given key already exists in the dictionary but has a different value.</exception>
            <remarks>
            If the given key-value pair are already in the dictionary, the existing instance is returned.
            </remarks>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2.AddRange(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Adds the specified key-value pairs to the dictionary.
            </summary>
            <param name="pairs">The pairs.</param>
            <returns>The new dictionary containing the additional key-value pairs.</returns>
            <exception cref="T:System.ArgumentException">Thrown when one of the given keys already exists in the dictionary but has a different value.</exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2.SetItem(`0,`1)">
            <summary>
            Sets the specified key and value to the dictionary, possibly overwriting an existing value for the given key.
            </summary>
            <param name="key">The key of the entry to add.</param>
            <param name="value">The value of the entry to add.</param>
            <returns>The new dictionary containing the additional key-value pair.</returns>
            <remarks>
            If the given key-value pair are already in the dictionary, the existing instance is returned.
            If the key already exists but with a different value, a new instance with the overwritten value will be returned.
            </remarks>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2.SetItems(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Applies a given set of key=value pairs to an immutable dictionary, replacing any conflicting keys in the resulting dictionary.
            </summary>
            <param name="items">The key=value pairs to set on the dictionary.  Any keys that conflict with existing keys will overwrite the previous values.</param>
            <returns>An immutable dictionary.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2.RemoveRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Removes the specified keys from the dictionary with their associated values.
            </summary>
            <param name="keys">The keys to remove.</param>
            <returns>A new dictionary with those keys removed; or this instance if those keys are not in the dictionary.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2.Remove(`0)">
            <summary>
            Removes the specified key from the dictionary with its associated value.
            </summary>
            <param name="key">The key to remove.</param>
            <returns>A new dictionary with the matching entry removed; or this instance if the key is not in the dictionary.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Determines whether this dictionary contains the specified key-value pair.
            </summary>
            <param name="pair">The key value pair.</param>
            <returns>
              <c>true</c> if this dictionary contains the key-value pair; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2.TryGetKey(`0,`0@)">
            <summary>
            Searches the dictionary for a given key and returns the equal key it finds, if any.
            </summary>
            <param name="equalKey">The key to search for.</param>
            <param name="actualKey">The key from the dictionary that the search found, or <paramref name="equalKey"/> if the search yielded no match.</param>
            <returns>A value indicating whether the search was successful.</returns>
            <remarks>
            This can be useful when you want to reuse a previously stored reference instead of
            a newly constructed one (so that more sharing of references can occur) or to look up
            the canonical value, or a value that has more complete data than the value you currently have,
            although their comparer functions indicate they are equal.
            </remarks>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionaryInternal`2.ContainsValue(`1)">
            <summary>
            Determines whether the ImmutableDictionary&lt;TKey,TValue&gt;
            contains an element with the specified value.
            </summary>
            <param name="value">
            The value to locate in the ImmutableDictionary&lt;TKey,TValue&gt;.
            The value can be null for reference types.
            </param>
            <returns>
            true if the ImmutableDictionary&lt;TKey,TValue&gt; contains
            an element with the specified value; otherwise, false.
            </returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1">
            <summary>
             A list of elements that can only be modified by creating a new instance of the list.
            </summary>
            <typeparam name="T">The type of element stored in the list.</typeparam>
            <remarks>
            Mutations on this list generate new lists.  Incremental changes to a list share as much memory as possible with the prior versions of a list,
            while allowing garbage collection to clean up any unique list data that is no longer being referenced.
            </remarks>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1.Clear">
            <summary>
            Gets an empty list that retains the same sort or unordered semantics that this instance has.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1.IndexOf(`0,System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Searches for the specified object and returns the zero-based index of the
            first occurrence within the range of elements in the ImmutableList&lt;T&gt;
            that starts at the specified index and contains the specified number of elements.
            </summary>
            <param name="item">
            The object to locate in the ImmutableList&lt;T&gt;. The value
            can be null for reference types.
            </param>
            <param name="index">
            The zero-based starting index of the search. 0 (zero) is valid in an empty
            list.
            </param>
            <param name="count">
            The number of elements in the section to search.
            </param>
            <param name="equalityComparer">
            The equality comparer to use in the search.
            </param>
            <returns>
            The zero-based index of the first occurrence of item within the range of
            elements in the ImmutableList&lt;T&gt; that starts at index and
            contains count number of elements, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1.LastIndexOf(`0,System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Searches for the specified object and returns the zero-based index of the
            last occurrence within the range of elements in the ImmutableList&lt;T&gt;
            that contains the specified number of elements and ends at the specified
            index.
            </summary>
            <param name="item">
            The object to locate in the ImmutableList&lt;T&gt;. The value
            can be null for reference types.
            </param>
            <param name="index">The starting position of the search. The search proceeds from <paramref name="index"/> toward the beginning of this instance.</param>
            <param name="count">The number of elements in the section to search.</param>
            <param name="equalityComparer">
            The equality comparer to use in the search.
            </param>
            <returns>
            The zero-based index of the last occurrence of item within the range of elements
            in the ImmutableList&lt;T&gt; that contains count number of elements
            and ends at index, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1.Add(`0)">
            <summary>
            Adds the specified value to this list.
            </summary>
            <param name="value">The value to add.</param>
            <returns>A new list with the element added, or this list if the element is already in this list.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds the specified values to this list.
            </summary>
            <param name="items">The values to add.</param>
            <returns>A new list with the elements added.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1.Insert(System.Int32,`0)">
            <summary>
            Inserts the specified value at the specified index.
            </summary>
            <param name="index">The index at which to insert the value.</param>
            <param name="element">The element to insert.</param>
            <returns>The new immutable list.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Inserts the specified values at the specified index.
            </summary>
            <param name="index">The index at which to insert the value.</param>
            <param name="items">The elements to insert.</param>
            <returns>The new immutable list.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1.Remove(`0,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Removes the specified value from this list.
            </summary>
            <param name="value">The value to remove.</param>
            <param name="equalityComparer">
            The equality comparer to use in the search.
            </param>
            <returns>A new list with the element removed, or this list if the element is not in this list.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1.RemoveAll(System.Predicate{`0})">
            <summary>
            Removes all the elements that match the conditions defined by the specified
            predicate.
            </summary>
            <param name="match">
            The System.Predicate&lt;T&gt; delegate that defines the conditions of the elements
            to remove.
            </param>
            <returns>
            The new list.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1.RemoveRange(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Removes the specified values from this list.
            </summary>
            <param name="items">The items to remove if matches are found in this list.</param>
            <param name="equalityComparer">
            The equality comparer to use in the search.
            </param>
            <returns>
            A new list with the elements removed.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1.RemoveRange(System.Int32,System.Int32)">
            <summary>
            Removes the specified values from this list.
            </summary>
            <param name="index">The starting index to begin removal.</param>
            <param name="count">The number of elements to remove.</param>
            <returns>
            A new list with the elements removed.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1.RemoveAt(System.Int32)">
            <summary>
            Removes the element at the specified index.
            </summary>
            <param name="index">The index.</param>
            <returns>A new list with the elements removed.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1.SetItem(System.Int32,`0)">
            <summary>
            Replaces an element in the list at a given position with the specified element.
            </summary>
            <param name="index">The position in the list of the element to replace.</param>
            <param name="value">The element to replace the old element with.</param>
            <returns>The new list -- even if the value being replaced is equal to the new value for that position.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1.Replace(`0,`0,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Replaces the first equal element in the list with the specified element.
            </summary>
            <param name="oldValue">The element to replace.</param>
            <param name="newValue">The element to replace the old element with.</param>
            <param name="equalityComparer">
            The equality comparer to use in the search.
            </param>
            <returns>The new list -- even if the value being replaced is equal to the new value for that position.</returns>
            <exception cref="T:System.ArgumentException">Thrown when the old value does not exist in the list.</exception>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableListQueries`1">
            <summary>
            An interface that describes the methods that the ImmutableList and ImmutableList+Builder types have in common.
            </summary>
            <typeparam name="T">The type of element in the collection.</typeparam>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableListQueries`1.ConvertAll``1(System.Func{`0,``0})">
            <summary>
            Converts the elements in the current ImmutableList&lt;T&gt; to
            another type, and returns a list containing the converted elements.
            </summary>
            <param name="converter">
            A System.Converter&lt;TInput,TOutput&gt; delegate that converts each element from
            one type to another type.
            </param>
            <typeparam name="TOutput">
            The type of the elements of the target array.
            </typeparam>
            <returns>
            A ImmutableList&lt;T&gt; of the target type containing the converted
            elements from the current ImmutableList&lt;T&gt;.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableListQueries`1.ForEach(System.Action{`0})">
            <summary>
            Performs the specified action on each element of the list.
            </summary>
            <param name="action">The System.Action&lt;T&gt; delegate to perform on each element of the list.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableListQueries`1.GetRange(System.Int32,System.Int32)">
            <summary>
            Creates a shallow copy of a range of elements in the source ImmutableList&lt;T&gt;.
            </summary>
            <param name="index">
            The zero-based ImmutableList&lt;T&gt; index at which the range
            starts.
            </param>
            <param name="count">
            The number of elements in the range.
            </param>
            <returns>
            A shallow copy of a range of elements in the source ImmutableList&lt;T&gt;.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableListQueries`1.CopyTo(`0[])">
            <summary>
            Copies the entire ImmutableList&lt;T&gt; to a compatible one-dimensional
            array, starting at the beginning of the target array.
            </summary>
            <param name="array">
            The one-dimensional System.Array that is the destination of the elements
            copied from ImmutableList&lt;T&gt;. The System.Array must have
            zero-based indexing.
            </param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableListQueries`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the entire ImmutableList&lt;T&gt; to a compatible one-dimensional
            array, starting at the specified index of the target array.
            </summary>
            <param name="array">
            The one-dimensional System.Array that is the destination of the elements
            copied from ImmutableList&lt;T&gt;. The System.Array must have
            zero-based indexing.
            </param>
            <param name="arrayIndex">
            The zero-based index in array at which copying begins.
            </param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableListQueries`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
            <summary>
            Copies a range of elements from the ImmutableList&lt;T&gt; to
            a compatible one-dimensional array, starting at the specified index of the
            target array.
            </summary>
            <param name="index">
            The zero-based index in the source ImmutableList&lt;T&gt; at
            which copying begins.
            </param>
            <param name="array">
            The one-dimensional System.Array that is the destination of the elements
            copied from ImmutableList&lt;T&gt;. The System.Array must have
            zero-based indexing.
            </param>
            <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
            <param name="count">The number of elements to copy.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableListQueries`1.Exists(System.Predicate{`0})">
            <summary>
            Determines whether the ImmutableList&lt;T&gt; contains elements
            that match the conditions defined by the specified predicate.
            </summary>
            <param name="match">
            The System.Predicate&lt;T&gt; delegate that defines the conditions of the elements
            to search for.
            </param>
            <returns>
            true if the ImmutableList&lt;T&gt; contains one or more elements
            that match the conditions defined by the specified predicate; otherwise,
            false.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableListQueries`1.Find(System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified
            predicate, and returns the first occurrence within the entire ImmutableList&lt;T&gt;.
            </summary>
            <param name="match">
            The System.Predicate&lt;T&gt; delegate that defines the conditions of the element
            to search for.
            </param>
            <returns>
            The first element that matches the conditions defined by the specified predicate,
            if found; otherwise, the default value for type T.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableListQueries`1.FindAll(System.Predicate{`0})">
            <summary>
            Retrieves all the elements that match the conditions defined by the specified
            predicate.
            </summary>
            <param name="match">
            The System.Predicate&lt;T&gt; delegate that defines the conditions of the elements
            to search for.
            </param>
            <returns>
            A ImmutableList&lt;T&gt; containing all the elements that match
            the conditions defined by the specified predicate, if found; otherwise, an
            empty ImmutableList&lt;T&gt;.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableListQueries`1.FindIndex(System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified
            predicate, and returns the zero-based index of the first occurrence within
            the entire ImmutableList&lt;T&gt;.
            </summary>
            <param name="match">
            The System.Predicate&lt;T&gt; delegate that defines the conditions of the element
            to search for.
            </param>
            <returns>
            The zero-based index of the first occurrence of an element that matches the
            conditions defined by match, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableListQueries`1.FindIndex(System.Int32,System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified
            predicate, and returns the zero-based index of the first occurrence within
            the range of elements in the ImmutableList&lt;T&gt; that extends
            from the specified index to the last element.
            </summary>
            <param name="startIndex">The zero-based starting index of the search.</param>
            <param name="match">The System.Predicate&lt;T&gt; delegate that defines the conditions of the element to search for.</param>
            <returns>
            The zero-based index of the first occurrence of an element that matches the
            conditions defined by match, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableListQueries`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified
            predicate, and returns the zero-based index of the first occurrence within
            the range of elements in the ImmutableList&lt;T&gt; that starts
            at the specified index and contains the specified number of elements.
            </summary>
            <param name="startIndex">The zero-based starting index of the search.</param>
            <param name="count">The number of elements in the section to search.</param>
            <param name="match">The System.Predicate&lt;T&gt; delegate that defines the conditions of the element to search for.</param>
            <returns>
            The zero-based index of the first occurrence of an element that matches the
            conditions defined by match, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableListQueries`1.FindLast(System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified
            predicate, and returns the last occurrence within the entire ImmutableList&lt;T&gt;.
            </summary>
            <param name="match">
            The System.Predicate&lt;T&gt; delegate that defines the conditions of the element
            to search for.
            </param>
            <returns>
            The last element that matches the conditions defined by the specified predicate,
            if found; otherwise, the default value for type T.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableListQueries`1.FindLastIndex(System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified
            predicate, and returns the zero-based index of the last occurrence within
            the entire ImmutableList&lt;T&gt;.
            </summary>
            <param name="match">
            The System.Predicate&lt;T&gt; delegate that defines the conditions of the element
            to search for.
            </param>
            <returns>
            The zero-based index of the last occurrence of an element that matches the
            conditions defined by match, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableListQueries`1.FindLastIndex(System.Int32,System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified
            predicate, and returns the zero-based index of the last occurrence within
            the range of elements in the ImmutableList&lt;T&gt; that extends
            from the first element to the specified index.
            </summary>
            <param name="startIndex">The zero-based starting index of the backward search.</param>
            <param name="match">The System.Predicate&lt;T&gt; delegate that defines the conditions of the element
            to search for.</param>
            <returns>
            The zero-based index of the last occurrence of an element that matches the
            conditions defined by match, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableListQueries`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified
            predicate, and returns the zero-based index of the last occurrence within
            the range of elements in the ImmutableList&lt;T&gt; that contains
            the specified number of elements and ends at the specified index.
            </summary>
            <param name="startIndex">The zero-based starting index of the backward search.</param>
            <param name="count">The number of elements in the section to search.</param>
            <param name="match">
            The System.Predicate&lt;T&gt; delegate that defines the conditions of the element
            to search for.
            </param>
            <returns>
            The zero-based index of the last occurrence of an element that matches the
            conditions defined by match, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableListQueries`1.TrueForAll(System.Predicate{`0})">
            <summary>
            Determines whether every element in the ImmutableList&lt;T&gt;
            matches the conditions defined by the specified predicate.
            </summary>
            <param name="match">
            The System.Predicate&lt;T&gt; delegate that defines the conditions to check against
            the elements.
            </param>
            <returns>
            true if every element in the ImmutableList&lt;T&gt; matches the
            conditions defined by the specified predicate; otherwise, false. If the list
            has no elements, the return value is true.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableListQueries`1.BinarySearch(`0)">
            <summary>
            Searches the entire sorted System.Collections.Generic.List&lt;T&gt; for an element
            using the default comparer and returns the zero-based index of the element.
            </summary>
            <param name="item">The object to locate. The value can be null for reference types.</param>
            <returns>
            The zero-based index of item in the sorted System.Collections.Generic.List&lt;T&gt;,
            if item is found; otherwise, a negative number that is the bitwise complement
            of the index of the next element that is larger than item or, if there is
            no larger element, the bitwise complement of System.Collections.Generic.List&lt;T&gt;.Count.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            The default comparer System.Collections.Generic.Comparer&lt;T&gt;.Default cannot
            find an implementation of the System.IComparable&lt;T&gt; generic interface or
            the System.IComparable interface for type T.
            </exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableListQueries`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
            <summary>
             Searches the entire sorted System.Collections.Generic.List&lt;T&gt; for an element
             using the specified comparer and returns the zero-based index of the element.
            </summary>
            <param name="item">The object to locate. The value can be null for reference types.</param>
            <param name="comparer">
            The System.Collections.Generic.IComparer&lt;T&gt; implementation to use when comparing
            elements.-or-null to use the default comparer System.Collections.Generic.Comparer&lt;T&gt;.Default.
            </param>
            <returns>
            The zero-based index of item in the sorted System.Collections.Generic.List&lt;T&gt;,
            if item is found; otherwise, a negative number that is the bitwise complement
            of the index of the next element that is larger than item or, if there is
            no larger element, the bitwise complement of System.Collections.Generic.List&lt;T&gt;.Count.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            comparer is null, and the default comparer System.Collections.Generic.Comparer&lt;T&gt;.Default
            cannot find an implementation of the System.IComparable&lt;T&gt; generic interface
            or the System.IComparable interface for type T.
            </exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableListQueries`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
            <summary>
            Searches a range of elements in the sorted System.Collections.Generic.List&lt;T&gt;
            for an element using the specified comparer and returns the zero-based index
            of the element.
            </summary>
            <param name="index">The zero-based starting index of the range to search.</param>
            <param name="count"> The length of the range to search.</param>
            <param name="item">The object to locate. The value can be null for reference types.</param>
            <param name="comparer">
            The System.Collections.Generic.IComparer&lt;T&gt; implementation to use when comparing
            elements, or null to use the default comparer System.Collections.Generic.Comparer&lt;T&gt;.Default.
            </param>
            <returns>
            The zero-based index of item in the sorted System.Collections.Generic.List&lt;T&gt;,
            if item is found; otherwise, a negative number that is the bitwise complement
            of the index of the next element that is larger than item or, if there is
            no larger element, the bitwise complement of System.Collections.Generic.List&lt;T&gt;.Count.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            index is less than 0.-or-count is less than 0.
            </exception>
            <exception cref="T:System.ArgumentException">
            index and count do not denote a valid range in the System.Collections.Generic.List&lt;T&gt;.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            comparer is null, and the default comparer System.Collections.Generic.Comparer&lt;T&gt;.Default
            cannot find an implementation of the System.IComparable&lt;T&gt; generic interface
            or the System.IComparable interface for type T.
            </exception>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableQueue`1">
            <summary>
            An immutable queue.
            </summary>
            <typeparam name="T">The type of elements in the queue.</typeparam>    
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableQueue`1.IsEmpty">
            <summary>
            Gets a value indicating whether this is the empty queue.
            </summary>
            <value>
              <c>true</c> if this queue is empty; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableQueue`1.Clear">
            <summary>
            Gets an empty queue.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableQueue`1.Peek">
            <summary>
            Gets the element at the front of the queue.
            </summary>
            <returns>
            The element on the top of the stack. 
            </returns>
            <exception cref="T:System.InvalidOperationException">Thrown when the stack is empty.</exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableQueue`1.Enqueue(`0)">
            <summary>
            Adds an element to the back of the queue.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The new queue.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableQueue`1.Dequeue">
            <summary>
            Returns a queue that is missing the front element.
            </summary>
            <returns>A queue; never <c>null</c>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when the stack is empty.</exception>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableStack`1">
            <summary>
            An immutable stack.
            </summary>
            <typeparam name="T">The type of elements stored in the stack.</typeparam>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableStack`1.IsEmpty">
            <summary>
            Gets a value indicating whether this is the empty stack.
            </summary>
            <value>
              <c>true</c> if this stack is empty; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableStack`1.Clear">
            <summary>
            Gets an empty stack.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableStack`1.Push(`0)">
            <summary>
            Pushes an element onto a stack and returns the new stack.
            </summary>
            <param name="value">The element to push onto the stack.</param>
            <returns>The new stack.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableStack`1.Pop">
            <summary>
            Pops the top element off the stack.
            </summary>
            <returns>The new stack; never <c>null</c></returns>
            <exception cref="T:System.InvalidOperationException">Thrown when the stack is empty.</exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableStack`1.Peek">
            <summary>
            Gets the element on the top of the stack.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown when the stack is empty.</exception>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray">
            <summary>
            A set of initialization methods for instances of <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1" />.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray.TwoElementArray">
            <summary>
            A two element array useful for throwing exceptions the way LINQ does.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray.Create``1">
            <summary>
            Creates an empty ImmutableArray{T}.
            </summary>
            <typeparam name="T">The type of element stored in the array.</typeparam>
            <returns>An empty array.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray.Create``1(``0)">
            <summary>
            Creates an ImmutableArray{T} with the specified element as its only member.
            </summary>
            <typeparam name="T">The type of element stored in the array.</typeparam>
            <param name="item">The element to store in the array.</param>
            <returns>A 1-element array.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray.CreateRange``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates an ImmutableArray{T} populated with the contents of the specified sequence.
            </summary>
            <typeparam name="T">The type of element stored in the array.</typeparam>
            <param name="items">The elements to store in the array.</param>
            <returns>An immutable array.</returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1">
            <summary>
            A readonly array with O(1) indexable lookup time.
            </summary>
            <typeparam name="T">The type of element stored by the array.</typeparam>
            <devremarks>
            This type has a documented contract of being exactly one reference-type field in size.
            Our own ImmutableInterlocked class depends on it, as well as others externally.
            IMPORTANT NOTICE FOR MAINTAINERS AND REVIEWERS:
            This type should be thread-safe. As a struct, it cannot protect its own fields
            from being changed from one thread while its members are executing on other threads
            because structs can change *in place* simply by reassigning the field containing
            this struct. Therefore it is extremely important that
            ** Every member should only dereference <c>this</c> ONCE. **
            If a member needs to reference the array field, that counts as a dereference of <c>this</c>.
            Calling other instance members (properties or methods) also counts as dereferencing <c>this</c>.
            Any member that needs to use <c>this</c> more than once must instead
            assign <c>this</c> to a local variable and use that for the rest of the code instead.
            This effectively copies the one field in the struct to a local variable so that
            it is insulated from other threads.
            </devremarks>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder">
            <summary>
            A writable array accessor that can be converted into an <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1"/>
            instance without allocating memory.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder._elements">
            <summary>
            The backing array for the builder.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder._count">
            <summary>
            The number of initialized elements in the array.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder"/> class.
            </summary>
            <param name="capacity">The initial capacity of the internal array.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder"/> class.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.Capacity">
            <summary>
            Get and sets the length of the internal array.  When set the internal array is
            reallocated to the given capacity if it is not already the specified length.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.Count">
            <summary>
            Gets or sets the length of the builder.
            </summary>
            <remarks>
            If the value is decreased, the array contents are truncated.
            If the value is increased, the added elements are initialized to <c>default(T)</c>.
            </remarks>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index.
            </summary>
            <param name="index">The index.</param>
            <returns></returns>
            <exception cref="T:System.IndexOutOfRangeException">
            </exception>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.
            </summary>
            <returns>true if the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only; otherwise, false.
              </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.ToImmutable">
            <summary>
            Returns an immutable copy of the current contents of this collection.
            </summary>
            <returns>An immutable array.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.MoveToImmutable">
            <summary>
            Extracts the internal array as an <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1"/> and replaces it 
            with a zero length array.
            </summary>
            <exception cref="T:System.InvalidOperationException">When <see cref="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.Count"/> doesn't 
            equal <see cref="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.Capacity"/>.</exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.Clear">
            <summary>
            Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.Insert(System.Int32,`0)">
            <summary>
            Inserts an item to the <see cref="T:System.Collections.Generic.IList`1" /> at the specified index.
            </summary>
            <param name="index">The zero-based index at which <paramref name="item" /> should be inserted.</param>
            <param name="item">The object to insert into the <see cref="T:System.Collections.Generic.IList`1" />.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.Add(`0)">
            <summary>
            Adds an item to the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
            <param name="item">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds the specified items to the end of the array.
            </summary>
            <param name="items">The items.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.AddRange(`0[])">
            <summary>
            Adds the specified items to the end of the array.
            </summary>
            <param name="items">The items.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.AddRange``1(``0[])">
            <summary>
            Adds the specified items to the end of the array.
            </summary>
            <param name="items">The items.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.AddRange(`0[],System.Int32)">
            <summary>
            Adds the specified items to the end of the array.
            </summary>
            <param name="items">The items.</param>
            <param name="length">The number of elements from the source array to add.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.AddRange(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray{`0})">
            <summary>
            Adds the specified items to the end of the array.
            </summary>
            <param name="items">The items.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.AddRange(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray{`0},System.Int32)">
            <summary>
            Adds the specified items to the end of the array.
            </summary>
            <param name="items">The items.</param>
            <param name="length">The number of elements from the source array to add.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.AddRange``1(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray{``0})">
            <summary>
            Adds the specified items to the end of the array.
            </summary>
            <param name="items">The items.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.AddRange(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray{`0}.Builder)">
            <summary>
            Adds the specified items to the end of the array.
            </summary>
            <param name="items">The items.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.AddRange``1(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray{``0}.Builder)">
            <summary>
            Adds the specified items to the end of the array.
            </summary>
            <param name="items">The items.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.Remove(`0)">
            <summary>
            Removes the specified element.
            </summary>
            <param name="element">The element.</param>
            <returns>A value indicating whether the specified element was found and removed from the collection.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.RemoveAt(System.Int32)">
            <summary>
            Removes the <see cref="T:System.Collections.Generic.IList`1" /> item at the specified index.
            </summary>
            <param name="index">The zero-based index of the item to remove.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.Contains(`0)">
            <summary>
            Determines whether the <see cref="T:System.Collections.Generic.ICollection`1" /> contains a specific value.
            </summary>
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
            <returns>
            true if <paramref name="item" /> is found in the <see cref="T:System.Collections.Generic.ICollection`1" />; otherwise, false.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.ToArray">
            <summary>
            Creates a new array with the current contents of this Builder.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the current contents to the specified array.
            </summary>
            <param name="array">The array to copy to.</param>
            <param name="index">The starting index of the target array.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.EnsureCapacity(System.Int32)">
            <summary>
            Resizes the array to accommodate the specified capacity requirement.
            </summary>
            <param name="capacity">The required capacity.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.IndexOf(`0)">
            <summary>
            Determines the index of a specific item in the <see cref="T:System.Collections.Generic.IList`1" />.
            </summary>
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.IList`1" />.</param>
            <returns>
            The index of <paramref name="item" /> if found in the list; otherwise, -1.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.IndexOf(`0,System.Int32)">
            <summary>
            Searches the array for the specified item.
            </summary>
            <param name="item">The item to search for.</param>
            <param name="startIndex">The index at which to begin the search.</param>
            <returns>The 0-based index into the array where the item was found; or -1 if it could not be found.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.IndexOf(`0,System.Int32,System.Int32)">
            <summary>
            Searches the array for the specified item.
            </summary>
            <param name="item">The item to search for.</param>
            <param name="startIndex">The index at which to begin the search.</param>
            <param name="count">The number of elements to search.</param>
            <returns>The 0-based index into the array where the item was found; or -1 if it could not be found.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.IndexOf(`0,System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Searches the array for the specified item.
            </summary>
            <param name="item">The item to search for.</param>
            <param name="startIndex">The index at which to begin the search.</param>
            <param name="count">The number of elements to search.</param>
            <param name="equalityComparer">The equality comparer to use in the search.</param>
            <returns>The 0-based index into the array where the item was found; or -1 if it could not be found.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.LastIndexOf(`0)">
            <summary>
            Searches the array for the specified item in reverse.
            </summary>
            <param name="item">The item to search for.</param>
            <returns>The 0-based index into the array where the item was found; or -1 if it could not be found.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.LastIndexOf(`0,System.Int32,System.Int32)">
            <summary>
            Searches the array for the specified item in reverse.
            </summary>
            <param name="item">The item to search for.</param>
            <param name="startIndex">The index at which to begin the search.</param>
            <param name="count">The number of elements to search.</param>
            <returns>The 0-based index into the array where the item was found; or -1 if it could not be found.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.LastIndexOf(`0,System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Searches the array for the specified item in reverse.
            </summary>
            <param name="item">The item to search for.</param>
            <param name="startIndex">The index at which to begin the search.</param>
            <param name="count">The number of elements to search.</param>
            <param name="equalityComparer">The equality comparer to use in the search.</param>
            <returns>The 0-based index into the array where the item was found; or -1 if it could not be found.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.Reverse">
            <summary>
            Reverses the order of elements in the collection.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.Sort">
            <summary>
            Sorts the array.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.Sort(System.Collections.Generic.IComparer{`0})">
            <summary>
            Sorts the array.
            </summary>
            <param name="comparer">The comparer to use in sorting. If <c>null</c>, the default comparer is used.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Sorts the array.
            </summary>
            <param name="index">The index of the first element to consider in the sort.</param>
            <param name="count">The number of elements to include in the sort.</param>
            <param name="comparer">The comparer to use in sorting. If <c>null</c>, the default comparer is used.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.GetEnumerator">
            <summary>
            Returns an enumerator for the contents of the array.
            </summary>
            <returns>An enumerator.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <summary>
            Returns an enumerator for the contents of the array.
            </summary>
            <returns>An enumerator.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator for the contents of the array.
            </summary>
            <returns>An enumerator.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Builder.AddRange``1(``0[],System.Int32)">
            <summary>
            Adds items to this collection.
            </summary>
            <typeparam name="TDerived">The type of source elements.</typeparam>
            <param name="items">The source array.</param>
            <param name="length">The number of elements to add to this array.</param>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Enumerator">
            <summary>
            An array enumerator.
            </summary>
            <remarks>
            It is important that this enumerator does NOT implement IDisposable.
            We want the iterator to inline when we do foreach and to not result in
            a try/finally frame in the client.
            </remarks>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Enumerator._array">
            <summary> 
            The array being enumerated.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Enumerator._index">
            <summary>
            The currently enumerated position.
            </summary>
            <value>
            -1 before the first call to <see cref="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Enumerator.MoveNext"/>.
            >= this.array.Length after MoveNext returns false.
            </value>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Enumerator.#ctor(`0[])">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Enumerator"/> struct.
            </summary>
            <param name="array">The array to enumerate.</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Enumerator.Current">
            <summary>
            Gets the currently enumerated value.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Enumerator.MoveNext">
            <summary>
            Advances to the next value to be enumerated.
            </summary>
            <returns><c>true</c> if another item exists in the array; <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.EnumeratorObject">
            <summary>
            An array enumerator that implements IEnumerator pattern (including IDisposable).
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.EnumeratorObject.s_EmptyEnumerator">
            <summary>
            A shareable singleton for enumerating empty arrays.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.EnumeratorObject._array">
            <summary>
            The array being enumerated.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.EnumeratorObject._index">
            <summary>
            The currently enumerated position.
            </summary>
            <value>
            -1 before the first call to <see cref="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.EnumeratorObject.MoveNext"/>.
            this.array.Length - 1 after MoveNext returns false.
            </value>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.EnumeratorObject.#ctor(`0[])">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Enumerator"/> class.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.EnumeratorObject.Current">
            <summary>
            Gets the currently enumerated value.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.EnumeratorObject.System#Collections#IEnumerator#Current">
            <summary>
            Gets the currently enumerated value.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.EnumeratorObject.MoveNext">
            <summary>
            If another item exists in the array, advances to the next value to be enumerated.
            </summary>
            <returns><c>true</c> if another item exists in the array; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.EnumeratorObject.System#Collections#IEnumerator#Reset">
            <summary>
            Resets enumeration to the start of the array.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.EnumeratorObject.Dispose">
            <summary>
            Disposes this enumerator.
            </summary>
            <remarks>
            Currently has no action.
            </remarks>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.EnumeratorObject.Create(`0[])">
            <summary>
            Creates an enumerator for the specified array.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Empty">
            <summary>
            An empty (initialized) instance of ImmutableArray{T}.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.array">
            <summary>
            The backing field for this instance. References to this value should never be shared with outside code. 
            </summary>
            <remarks>
            This would be private, but we make it internal so that our own extension methods can access it.
            </remarks>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.#ctor(`0[])">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray"/> struct
            *without making a defensive copy*.
            </summary>
            <param name="items">The array to use. May be null for "default" arrays.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.op_Equality(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray{`0},Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray{`0})">
            <summary>
            Checks equality between two instances.
            </summary>
            <param name="left">The instance to the left of the operator.</param>
            <param name="right">The instance to the right of the operator.</param>
            <returns><c>true</c> if the values' underlying arrays are reference equal; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.op_Inequality(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray{`0},Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray{`0})">
            <summary>
            Checks inequality between two instances.
            </summary>
            <param name="left">The instance to the left of the operator.</param>
            <param name="right">The instance to the right of the operator.</param>
            <returns><c>true</c> if the values' underlying arrays are reference not equal; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.op_Equality(System.Nullable{Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray{`0}},System.Nullable{Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray{`0}})">
            <summary>
            Checks equality between two instances.
            </summary>
            <param name="left">The instance to the left of the operator.</param>
            <param name="right">The instance to the right of the operator.</param>
            <returns><c>true</c> if the values' underlying arrays are reference equal; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.op_Inequality(System.Nullable{Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray{`0}},System.Nullable{Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray{`0}})">
            <summary>
            Checks inequality between two instances.
            </summary>
            <param name="left">The instance to the left of the operator.</param>
            <param name="right">The instance to the right of the operator.</param>
            <returns><c>true</c> if the values' underlying arrays are reference not equal; <c>false</c> otherwise.</returns>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Item(System.Int32)">
            <summary>
            Gets the element at the specified index in the read-only list.
            </summary>
            <param name="index">The zero-based index of the element to get.</param>
            <returns>The element at the specified index in the read-only list.</returns>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.System#Collections#Generic#IList{T}#Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index in the read-only list.
            </summary>
            <param name="index">The zero-based index of the element to get.</param>
            <returns>The element at the specified index in the read-only list.</returns>
            <exception cref="T:System.NotSupportedException">Always thrown from the setter.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown if the <see cref="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.IsDefault" /> property returns true.</exception>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <summary>
            Gets a value indicating whether this instance is read only.
            </summary>
            <value>
            <c>true</c> if this instance is read only; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.IsEmpty">
            <summary>
            Gets a value indicating whether this collection is empty.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Length">
            <summary>
            Gets the number of array in the collection.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.System#Collections#Generic#ICollection{T}#Count">
            <summary>
            Gets the number of array in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if the <see cref="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.IsDefault" /> property returns true.</exception>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.System#Collections#Generic#IReadOnlyCollection{T}#Count">
            <summary>
            Gets the number of array in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if the <see cref="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.IsDefault" /> property returns true.</exception>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.System#Collections#Generic#IReadOnlyList{T}#Item(System.Int32)">
            <summary>
            Gets the element at the specified index.
            </summary>
            <param name="index">The index.</param>
            <returns>
            The element.
            </returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the <see cref="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.IsDefault" /> property returns true.</exception>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.IsDefault">
            <summary>
            Gets a value indicating whether this struct was initialized without an actual array instance.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.IsDefaultOrEmpty">
            <summary>
            Gets a value indicating whether this struct is empty or uninitialized.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableArray#Array">
            <summary>
            Gets an untyped reference to the array.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.DebuggerDisplay">
            <summary>
            Gets the string to display in the debugger watches window for this instance.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.IndexOf(`0)">
            <summary>
            Searches the array for the specified item.
            </summary>
            <param name="item">The item to search for.</param>
            <returns>The 0-based index into the array where the item was found; or -1 if it could not be found.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.IndexOf(`0,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Searches the array for the specified item.
            </summary>
            <param name="item">The item to search for.</param>
            <param name="startIndex">The index at which to begin the search.</param>
            <param name="equalityComparer">The equality comparer to use in the search.</param>
            <returns>The 0-based index into the array where the item was found; or -1 if it could not be found.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.IndexOf(`0,System.Int32)">
            <summary>
            Searches the array for the specified item.
            </summary>
            <param name="item">The item to search for.</param>
            <param name="startIndex">The index at which to begin the search.</param>
            <returns>The 0-based index into the array where the item was found; or -1 if it could not be found.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.IndexOf(`0,System.Int32,System.Int32)">
            <summary>
            Searches the array for the specified item.
            </summary>
            <param name="item">The item to search for.</param>
            <param name="startIndex">The index at which to begin the search.</param>
            <param name="count">The number of elements to search.</param>
            <returns>The 0-based index into the array where the item was found; or -1 if it could not be found.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.IndexOf(`0,System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Searches the array for the specified item.
            </summary>
            <param name="item">The item to search for.</param>
            <param name="startIndex">The index at which to begin the search.</param>
            <param name="count">The number of elements to search.</param>
            <param name="equalityComparer">The equality comparer to use in the search.</param>
            <returns>The 0-based index into the array where the item was found; or -1 if it could not be found.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.LastIndexOf(`0)">
            <summary>
            Searches the array for the specified item in reverse.
            </summary>
            <param name="item">The item to search for.</param>
            <returns>The 0-based index into the array where the item was found; or -1 if it could not be found.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.LastIndexOf(`0,System.Int32,System.Int32)">
            <summary>
            Searches the array for the specified item in reverse.
            </summary>
            <param name="item">The item to search for.</param>
            <param name="startIndex">The index at which to begin the search.</param>
            <param name="count">The number of elements to search.</param>
            <returns>The 0-based index into the array where the item was found; or -1 if it could not be found.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.LastIndexOf(`0,System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Searches the array for the specified item in reverse.
            </summary>
            <param name="item">The item to search for.</param>
            <param name="startIndex">The index at which to begin the search.</param>
            <param name="count">The number of elements to search.</param>
            <param name="equalityComparer">The equality comparer to use in the search.</param>
            <returns>The 0-based index into the array where the item was found; or -1 if it could not be found.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Contains(`0)">
            <summary>
            Determines whether the specified item exists in the array.
            </summary>
            <param name="item">The item to search for.</param>
            <returns><c>true</c> if an equal value was found in the array; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.CopyTo(`0[])">
            <summary>
            Copies the contents of this array to the specified array.
            </summary>
            <param name="destination">The array to copy to.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the contents of this array to the specified array.
            </summary>
            <param name="destination">The array to copy to.</param>
            <param name="destinationIndex">The index into the destination array to which the first copied element is written.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
            <summary>
            Copies the contents of this array to the specified array.
            </summary>
            <param name="sourceIndex">The index into this collection of the first element to copy.</param>
            <param name="destination">The array to copy to.</param>
            <param name="destinationIndex">The index into the destination array to which the first copied element is written.</param>
            <param name="length">The number of elements to copy.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Insert(System.Int32,`0)">
            <summary>
            Returns a new array with the specified value inserted at the specified position.
            </summary>
            <param name="index">The 0-based index into the array at which the new item should be added.</param>
            <param name="item">The item to insert at the start of the array.</param>
            <returns>A new array.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Inserts the specified values at the specified index.
            </summary>
            <param name="index">The index at which to insert the value.</param>
            <param name="items">The elements to insert.</param>
            <returns>The new immutable collection.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.InsertRange(System.Int32,Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray{`0})">
            <summary>
            Inserts the specified values at the specified index.
            </summary>
            <param name="index">The index at which to insert the value.</param>
            <param name="items">The elements to insert.</param>
            <returns>The new immutable collection.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Add(`0)">
            <summary>
            Returns a new array with the specified value inserted at the end.
            </summary>
            <param name="item">The item to insert at the end of the array.</param>
            <returns>A new array.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds the specified values to this list.
            </summary>
            <param name="items">The values to add.</param>
            <returns>A new list with the elements added.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.AddRange(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray{`0})">
            <summary>
            Adds the specified values to this list.
            </summary>
            <param name="items">The values to add.</param>
            <returns>A new list with the elements added.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.SetItem(System.Int32,`0)">
            <summary>
            Returns an array with the item at the specified position replaced.
            </summary>
            <param name="index">The index of the item to replace.</param>
            <param name="item">The new item.</param>
            <returns>The new array.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Replace(`0,`0)">
            <summary>
            Replaces the first equal element in the list with the specified element.
            </summary>
            <param name="oldValue">The element to replace.</param>
            <param name="newValue">The element to replace the old element with.</param>
            <returns>The new list -- even if the value being replaced is equal to the new value for that position.</returns>
            <exception cref="T:System.ArgumentException">Thrown when the old value does not exist in the list.</exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Replace(`0,`0,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Replaces the first equal element in the list with the specified element.
            </summary>
            <param name="oldValue">The element to replace.</param>
            <param name="newValue">The element to replace the old element with.</param>
            <param name="equalityComparer">
            The equality comparer to use in the search.
            </param>
            <returns>The new list -- even if the value being replaced is equal to the new value for that position.</returns>
            <exception cref="T:System.ArgumentException">Thrown when the old value does not exist in the list.</exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Remove(`0)">
            <summary>
            Returns an array with the first occurrence of the specified element removed from the array.
            If no match is found, the current array is returned.
            </summary>
            <param name="item">The item to remove.</param>
            <returns>The new array.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Remove(`0,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Returns an array with the first occurrence of the specified element removed from the array.
            If no match is found, the current array is returned.
            </summary>
            <param name="item">The item to remove.</param>
            <param name="equalityComparer">
            The equality comparer to use in the search.
            </param>
            <returns>The new array.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.RemoveAt(System.Int32)">
            <summary>
            Returns an array with the element at the specified position removed.
            </summary>
            <param name="index">The 0-based index into the array for the element to omit from the returned array.</param>
            <returns>The new array.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.RemoveRange(System.Int32,System.Int32)">
            <summary>
            Returns an array with the elements at the specified position removed.
            </summary>
            <param name="index">The 0-based index into the array for the element to omit from the returned array.</param>
            <param name="length">The number of elements to remove.</param>
            <returns>The new array.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.RemoveRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Removes the specified values from this list.
            </summary>
            <param name="items">The items to remove if matches are found in this list.</param>
            <returns>
            A new list with the elements removed.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.RemoveRange(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Removes the specified values from this list.
            </summary>
            <param name="items">The items to remove if matches are found in this list.</param>
            <param name="equalityComparer">
            The equality comparer to use in the search.
            </param>
            <returns>
            A new list with the elements removed.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.RemoveRange(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray{`0})">
            <summary>
            Removes the specified values from this list.
            </summary>
            <param name="items">The items to remove if matches are found in this list.</param>
            <returns>
            A new list with the elements removed.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.RemoveRange(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Removes the specified values from this list.
            </summary>
            <param name="items">The items to remove if matches are found in this list.</param>
            <param name="equalityComparer">
            The equality comparer to use in the search.
            </param>
            <returns>
            A new list with the elements removed.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.RemoveAll(System.Predicate{`0})">
            <summary>
            Removes all the elements that match the conditions defined by the specified
            predicate.
            </summary>
            <param name="match">
            The System.Predicate&lt;T&gt; delegate that defines the conditions of the elements
            to remove.
            </param>
            <returns>
            The new list.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Clear">
            <summary>
            Returns an empty array.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Sort">
            <summary>
            Returns a sorted instance of this array.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Sort(System.Collections.Generic.IComparer{`0})">
            <summary>
            Returns a sorted instance of this array.
            </summary>
            <param name="comparer">The comparer to use in sorting. If <c>null</c>, the default comparer is used.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Returns a sorted instance of this array.
            </summary>
            <param name="index">The index of the first element to consider in the sort.</param>
            <param name="count">The number of elements to include in the sort.</param>
            <param name="comparer">The comparer to use in sorting. If <c>null</c>, the default comparer is used.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.ToBuilder">
            <summary>
            Returns a builder that is populated with the same contents as this array.
            </summary>
            <returns>The new builder.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.GetEnumerator">
            <summary>
            Returns an enumerator for the contents of the array.
            </summary>
            <returns>An enumerator.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Equals(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray{`0})">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.CastUp``1(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray{``0})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1"/> struct based on the contents
            of an existing instance, allowing a covariant static cast to efficiently reuse the existing array.
            </summary>
            <param name="items">The array to initialize the array with. No copy is made.</param>
            <remarks>
            Covariant upcasts from this method may be reversed by calling the
            <see cref="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.As``1"/>  or <see cref="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.CastArray``1"/>method.
            </remarks>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.CastArray``1">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1"/> struct by casting the underlying
            array to an array of type <typeparam name="TOther"/>.
            </summary>
            <exception cref="T:System.InvalidCastException">Thrown if the cast is illegal.</exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.As``1">
            <summary>
            Creates an immutable array for this array, cast to a different element type.
            </summary>
            <typeparam name="TOther">The type of array element to return.</typeparam>
            <returns>
            A struct typed for the base element type. If the cast fails, an instance
            is returned whose <see cref="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.IsDefault"/> property returns <c>true</c>.
            </returns>
            <remarks>
            Arrays of derived elements types can be cast to arrays of base element types
            without reallocating the array.
            These upcasts can be reversed via this same method, casting an array of base
            element types to their derived types. However, downcasting is only successful
            when it reverses a prior upcasting operation.
            </remarks>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.OfType``1">
            <summary>
            Filters the elements of this array to those assignable to the specified type.
            </summary>
            <typeparam name="TResult">The type to filter the elements of the sequence on.</typeparam>
            <returns>
            An System.Collections.Generic.IEnumerable&lt;T&gt; that contains elements from
            the input sequence of type TResult.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <summary>
            Returns an enumerator for the contents of the array.
            </summary>
            <returns>An enumerator.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the <see cref="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.IsDefault" /> property returns true.</exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator for the contents of the array.
            </summary>
            <returns>An enumerator.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the <see cref="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.IsDefault" /> property returns true.</exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableList{T}#Clear">
            <summary>
            See <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableList{T}#Add(`0)">
            <summary>
            See <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableList{T}#AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            See <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableList{T}#Insert(System.Int32,`0)">
            <summary>
            See <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableList{T}#InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            See <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableList{T}#Remove(`0,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            See <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableList{T}#RemoveAll(System.Predicate{`0})">
            <summary>
            See <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableList{T}#RemoveRange(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            See <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableList{T}#RemoveRange(System.Int32,System.Int32)">
            <summary>
            See <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableList{T}#RemoveAt(System.Int32)">
            <summary>
            See <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableList{T}#SetItem(System.Int32,`0)">
            <summary>
            See <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableList{T}#Replace(`0,`0,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            See <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.System#Collections#IList#Add(System.Object)">
            <summary>
            Adds an item to the <see cref="T:System.Collections.IList" />.
            </summary>
            <param name="value">The object to add to the <see cref="T:System.Collections.IList" />.</param>
            <returns>
            The position into which the new element was inserted, or -1 to indicate that the item was not inserted into the collection,
            </returns>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.System#Collections#IList#Clear">
            <summary>
            Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.System#Collections#IList#Contains(System.Object)">
            <summary>
            Determines whether the <see cref="T:System.Collections.IList" /> contains a specific value.
            </summary>
            <param name="value">The object to locate in the <see cref="T:System.Collections.IList" />.</param>
            <returns>
            true if the <see cref="T:System.Object" /> is found in the <see cref="T:System.Collections.IList" />; otherwise, false.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.System#Collections#IList#IndexOf(System.Object)">
            <summary>
            Determines the index of a specific item in the <see cref="T:System.Collections.IList" />.
            </summary>
            <param name="value">The object to locate in the <see cref="T:System.Collections.IList" />.</param>
            <returns>
            The index of <paramref name="value" /> if found in the list; otherwise, -1.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.System#Collections#IList#Insert(System.Int32,System.Object)">
            <summary>
            Inserts an item to the <see cref="T:System.Collections.IList" /> at the specified index.
            </summary>
            <param name="index">The zero-based index at which <paramref name="value" /> should be inserted.</param>
            <param name="value">The object to insert into the <see cref="T:System.Collections.IList" />.</param>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.System#Collections#IList#IsFixedSize">
            <summary>
            Gets a value indicating whether this instance is fixed size.
            </summary>
            <value>
            <c>true</c> if this instance is fixed size; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.System#Collections#IList#IsReadOnly">
            <summary>
            Gets a value indicating whether this instance is read only.
            </summary>
            <value>
            <c>true</c> if this instance is read only; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.System#Collections#ICollection#Count">
            <summary>
            Gets the size of the array.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if the <see cref="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.IsDefault" /> property returns true.</exception>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.System#Collections#ICollection#IsSynchronized">
            <summary>
            See the ICollection interface.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.System#Collections#ICollection#SyncRoot">
            <summary>
            Gets the sync root.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.System#Collections#IList#Remove(System.Object)">
            <summary>
            Removes the first occurrence of a specific object from the <see cref="T:System.Collections.IList" />.
            </summary>
            <param name="value">The object to remove from the <see cref="T:System.Collections.IList" />.</param>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.System#Collections#IList#RemoveAt(System.Int32)">
            <summary>
            Removes the <see cref="T:System.Collections.Generic.IList`1" /> item at the specified index.
            </summary>
            <param name="index">The zero-based index of the item to remove.</param>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.System#Collections#IList#Item(System.Int32)">
            <summary>
            Gets or sets the <see cref="T:System.Object"/> at the specified index.
            </summary>
            <value>
            The <see cref="T:System.Object"/>.
            </value>
            <param name="index">The index.</param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">Always thrown from the setter.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown if the <see cref="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.IsDefault" /> property returns true.</exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.ICollection" /> to an <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:System.Collections.ICollection" />. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
            <param name="index">The zero-based index in <paramref name="array" /> at which copying begins.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)">
            <summary>
            Determines whether an object is structurally equal to the current instance.
            </summary>
            <param name="other">The object to compare with the current instance.</param>
            <param name="comparer">An object that determines whether the current instance and other are equal.</param>
            <returns>true if the two objects are equal; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)">
            <summary>
            Returns a hash code for the current instance.
            </summary>
            <param name="comparer">An object that computes the hash code of the current object.</param>
            <returns>The hash code for the current instance.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
            <summary>
            Determines whether the current collection object precedes, occurs in the
            same position as, or follows another object in the sort order.
            </summary>
            <param name="other">The object to compare with the current instance.</param>
            <param name="comparer">
            An object that compares members of the current collection object with the
            corresponding members of other.
            </param>
            <returns>
            An integer that indicates the relationship of the current collection object
            to other.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.ThrowNullRefIfNotInitialized">
            <summary>
            Throws a null reference exception if the array field is null.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.ThrowInvalidOperationIfNotInitialized">
            <summary>
            Throws an <see cref="T:System.InvalidOperationException"/> if the array field is null, ie. the
            <see cref="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.IsDefault"/> property returns true.  The
            InvalidOperationException message specifies that the operation cannot be performed
            on a default instance of ImmutableArray.
            
            This is intended for explicitly implemented interface method and property implementations.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.RemoveAtRange(System.Collections.Generic.ICollection{System.Int32})">
            <summary>
            Returns an array with items at the specified indexes removed.
            </summary>
            <param name="indexesToRemove">A **sorted set** of indexes to elements that should be omitted from the returned array.</param>
            <returns>The new array.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray`1.ThrowNullRefIfNotInitialized(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray{`0})">
            <summary>
            Throws a NullReferenceException if the specified array is uninitialized.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArrayBuilderDebuggerProxy`1">
            <summary>
            A simple view of the immutable collection that the debugger can show to the developer.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArrayBuilderDebuggerProxy`1._builder">
            <summary>
            The collection to be enumerated.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArrayBuilderDebuggerProxy`1.#ctor(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArray{`0}.Builder)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArrayBuilderDebuggerProxy`1"/> class.
            </summary>
            <param name="builder">The collection to display in the debugger</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableArrayBuilderDebuggerProxy`1.A">
            <summary>
            Gets a simple debugger-viewable collection.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary">
            <summary>
            A set of initialization methods for instances of <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2" />.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary.Create``2">
            <summary>
            Returns an empty collection.
            </summary>
            <typeparam name="TKey">The type of keys stored by the dictionary.</typeparam>
            <typeparam name="TValue">The type of values stored by the dictionary.</typeparam>
            <returns>The immutable collection.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary.CreateRange``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>
            Creates a new immutable collection prefilled with the specified items.
            </summary>
            <typeparam name="TKey">The type of keys stored by the dictionary.</typeparam>
            <typeparam name="TValue">The type of values stored by the dictionary.</typeparam>
            <param name="items">The items to prepopulate.</param>
            <returns>The new immutable collection.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary.ToImmutableDictionary``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}},System.Collections.Generic.IEqualityComparer{``0},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates an immutable dictionary given a sequence of key=value pairs.
            </summary>
            <typeparam name="TKey">The type of key in the map.</typeparam>
            <typeparam name="TValue">The type of value in the map.</typeparam>
            <param name="source">The sequence of key=value pairs.</param>
            <param name="keyComparer">The key comparer to use when building the immutable map.</param>
            <param name="valueComparer">The value comparer to use for the immutable map.</param>
            <returns>An immutable map.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary.ToImmutableDictionary``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>
            Creates an immutable dictionary given a sequence of key=value pairs.
            </summary>
            <typeparam name="TKey">The type of key in the map.</typeparam>
            <typeparam name="TValue">The type of value in the map.</typeparam>
            <param name="source">The sequence of key=value pairs.</param>
            <returns>An immutable map.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary.GetValueOrDefault``2(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary{``0,``1},``0,``1)">
            <summary>
            Gets the value for a given key if a matching key exists in the dictionary.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="dictionary">The dictionary to retrieve the value from.</param>
            <param name="key">The key to search for.</param>
            <param name="defaultValue">The default value to return if no matching key is found in the dictionary.</param>
            <returns>
            The value for the key, or <paramref name="defaultValue"/> if no matching key was found.
            </returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2">
            <content>
            Contains the inner Builder class.
            </content>
            <content>
            Contains the inner HashBucketComparer class.
            </content>
            <content>
            Contains the inner Enumerator struct.
            </content>
            <content>
            Contains the inner HashBucket struct.
            </content>
            <content>
            Contains the inner MutationInput class.
            </content>
            <content>
            Contains the inner MutationResult class.
            </content>
            <summary>
            An immutable unordered dictionary implementation.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder">
            <summary>
            A dictionary that mutates with little or no memory allocations,
            can produce and/or build on immutable dictionary instances very efficiently.
            </summary>
            <remarks>
            <para>
            While <see cref="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.AddRange(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})"/>
            and other bulk change methods already provide fast bulk change operations on the collection, this class allows
            multiple combinations of changes to be made to a set with equal efficiency.
            </para>
            <para>
            Instance members of this class are <em>not</em> thread-safe.
            </para>
            </remarks>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder._root">
            <summary>
            The root of the binary tree that stores the collection.  Contents are typically not entirely frozen.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder._comparers">
            <summary>
            The comparers.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder._count">
            <summary>
            The number of elements in this collection.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder._immutable">
            <summary>
            Caches an immutable instance that represents the current state of the collection.
            </summary>
            <value>Null if no immutable view has been created for the current version.</value>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder._version">
            <summary>
            A number that increments every time the builder changes its contents.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder._syncRoot">
            <summary>
            The object callers may use to synchronize access to this collection.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.#ctor(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder"/> class.
            </summary>
            <param name="map">The map that serves as the basis for this Builder.</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.KeyComparer">
            <summary>
            Gets or sets the key comparer.
            </summary>
            <value>
            The key comparer.
            </value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.ValueComparer">
            <summary>
            Gets or sets the value comparer.
            </summary>
            <value>
            The value comparer.
            </value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <returns>The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.</returns>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.
            </summary>
            <returns>true if the <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only; otherwise, false.</returns>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.Keys">
            <summary>
            See <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/>
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.System#Collections#Generic#IDictionary{TKey,TValue}#Keys">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.ICollection`1"/> containing the keys of the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <returns>An <see cref="T:System.Collections.Generic.ICollection`1"/> containing the keys of the object that implements <see cref="T:System.Collections.Generic.IDictionary`2"/>.</returns>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.Values">
            <summary>
            See <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/>
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.System#Collections#Generic#IDictionary{TKey,TValue}#Values">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.ICollection`1"/> containing the values in the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <returns>An <see cref="T:System.Collections.Generic.ICollection`1"/> containing the values in the object that implements <see cref="T:System.Collections.Generic.IDictionary`2"/>.</returns>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.System#Collections#IDictionary#IsFixedSize">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.IDictionary" /> object has a fixed size.
            </summary>
            <returns>true if the <see cref="T:System.Collections.IDictionary" /> object has a fixed size; otherwise, false.</returns>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.System#Collections#IDictionary#IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.
            </summary>
            <returns>true if the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only; otherwise, false.
              </returns>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.System#Collections#IDictionary#Keys">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.ICollection`1" /> containing the keys of the <see cref="T:System.Collections.Generic.IDictionary`2" />.
            </summary>
            <returns>
            An <see cref="T:System.Collections.Generic.ICollection`1" /> containing the keys of the object that implements <see cref="T:System.Collections.Generic.IDictionary`2" />.
            </returns>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.System#Collections#IDictionary#Values">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.ICollection`1" /> containing the values in the <see cref="T:System.Collections.Generic.IDictionary`2" />.
            </summary>
            <returns>
            An <see cref="T:System.Collections.Generic.ICollection`1" /> containing the values in the object that implements <see cref="T:System.Collections.Generic.IDictionary`2" />.
            </returns>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.System#Collections#ICollection#SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.
            </summary>
            <returns>An object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.</returns>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.System#Collections#ICollection#IsSynchronized">
            <summary>
            Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread safe).
            </summary>
            <returns>true if access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread safe); otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.System#Collections#IDictionary#Add(System.Object,System.Object)">
            <summary>
            Adds an element with the provided key and value to the <see cref="T:System.Collections.IDictionary" /> object.
            </summary>
            <param name="key">The <see cref="T:System.Object" /> to use as the key of the element to add.</param>
            <param name="value">The <see cref="T:System.Object" /> to use as the value of the element to add.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.System#Collections#IDictionary#Contains(System.Object)">
            <summary>
            Determines whether the <see cref="T:System.Collections.IDictionary" /> object contains an element with the specified key.
            </summary>
            <param name="key">The key to locate in the <see cref="T:System.Collections.IDictionary" /> object.</param>
            <returns>
            true if the <see cref="T:System.Collections.IDictionary" /> contains an element with the key; otherwise, false.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.System#Collections#IDictionary#GetEnumerator">
            <summary>
            Returns an <see cref="T:System.Collections.IDictionaryEnumerator" /> object for the <see cref="T:System.Collections.IDictionary" /> object.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IDictionaryEnumerator" /> object for the <see cref="T:System.Collections.IDictionary" /> object.
            </returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.System#Collections#IDictionary#Remove(System.Object)">
            <summary>
            Removes the element with the specified key from the <see cref="T:System.Collections.IDictionary" /> object.
            </summary>
            <param name="key">The key of the element to remove.</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.System#Collections#IDictionary#Item(System.Object)">
            <summary>
            Gets or sets the element with the specified key.
            </summary>
            <param name="key">The key.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.ICollection" /> to an <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:System.Collections.ICollection" />. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
            <param name="arrayIndex">The zero-based index in <paramref name="array" /> at which copying begins.</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.Version">
            <summary>
            Gets the current version of the contents of this builder.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.Origin">
            <summary>
            Gets the initial data to pass to a query or mutation method.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.Root">
            <summary>
            Gets or sets the root of this data structure.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.Item(`0)">
            <summary>
            Gets or sets the element with the specified key.
            </summary>
            <returns>The element with the specified key.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The property is retrieved and <paramref name="key"/> is not found.</exception>
            <exception cref="T:System.NotSupportedException">The property is set and the <see cref="T:System.Collections.Generic.IDictionary`2"/> is read-only.</exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.AddRange(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Adds a sequence of values to this collection.
            </summary>
            <param name="items">The items.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.RemoveRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Removes any entries from the dictionaries with keys that match those found in the specified sequence.
            </summary>
            <param name="keys">The keys for entries to remove from the dictionary.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.GetValueOrDefault(`0)">
            <summary>
            Gets the value for a given key if a matching key exists in the dictionary.
            </summary>
            <param name="key">The key to search for.</param>
            <returns>The value for the key, or <c>default(TValue)</c> if no matching key was found.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.GetValueOrDefault(`0,`1)">
            <summary>
            Gets the value for a given key if a matching key exists in the dictionary.
            </summary>
            <param name="key">The key to search for.</param>
            <param name="defaultValue">The default value to return if no matching key is found in the dictionary.</param>
            <returns>
            The value for the key, or <paramref name="defaultValue"/> if no matching key was found.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.ToImmutable">
            <summary>
            Creates an immutable dictionary based on the contents of this instance.
            </summary>
            <returns>An immutable map.</returns>
            <remarks>
            This method is an O(n) operation, and approaches O(1) time as the number of
            actual mutations to the set since the last call to this method approaches 0.
            </remarks>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.Add(`0,`1)">
            <summary>
            Adds an element with the provided key and value to the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <param name="key">The object to use as the key of the element to add.</param>
            <param name="value">The object to use as the value of the element to add.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.</exception>
            <exception cref="T:System.ArgumentException">An element with the same key already exists in the <see cref="T:System.Collections.Generic.IDictionary`2"/>.</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IDictionary`2"/> is read-only.</exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.ContainsKey(`0)">
            <summary>
            Determines whether the <see cref="T:System.Collections.Generic.IDictionary`2"/> contains an element with the specified key.
            </summary>
            <param name="key">The key to locate in the <see cref="T:System.Collections.Generic.IDictionary`2"/>.</param>
            <returns>
            true if the <see cref="T:System.Collections.Generic.IDictionary`2"/> contains an element with the key; otherwise, false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.</exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.ContainsValue(`1)">
            <summary>
            Determines whether the ImmutableSortedMap&lt;TKey,TValue&gt;
            contains an element with the specified value.
            </summary>
            <param name="value">
            The value to locate in the ImmutableSortedMap&lt;TKey,TValue&gt;.
            The value can be null for reference types.
            </param>
            <returns>
            true if the ImmutableSortedMap&lt;TKey,TValue&gt; contains
            an element with the specified value; otherwise, false.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.Remove(`0)">
            <summary>
            Removes the element with the specified key from the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <returns>
            true if the element is successfully removed; otherwise, false.  This method also returns false if <paramref name="key"/> was not found in the original <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.</exception>
              
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IDictionary`2"/> is read-only.</exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.TryGetValue(`0,`1@)">
            <summary>
            Gets the value associated with the specified key.
            </summary>
            <param name="key">The key whose value to get.</param>
            <param name="value">When this method returns, the value associated with the specified key, if the key is found; otherwise, the default value for the type of the <paramref name="value"/> parameter. This parameter is passed uninitialized.</param>
            <returns>
            true if the object that implements <see cref="T:System.Collections.Generic.IDictionary`2"/> contains an element with the specified key; otherwise, false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.</exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.TryGetKey(`0,`0@)">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Adds an item to the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <param name="item">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.</exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.Clear">
            <summary>
            Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only. </exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Determines whether the <see cref="T:System.Collections.Generic.ICollection`1"/> contains a specific value.
            </summary>
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
            <returns>
            true if <paramref name="item"/> is found in the <see cref="T:System.Collections.Generic.ICollection`1"/>; otherwise, false.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            See the <see cref="T:System.Collections.Generic.ICollection`1"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Removes the first occurrence of a specific object from the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <param name="item">The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
            <returns>
            true if <paramref name="item"/> was successfully removed from the <see cref="T:System.Collections.Generic.ICollection`1"/>; otherwise, false. This method also returns false if <paramref name="item"/> is not found in the original <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.</exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.System#Collections#Generic#IEnumerable{System#Collections#Generic#KeyValuePair{TKey,TValue}}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Builder.Apply(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1}.MutationResult)">
            <summary>
            Applies the result of some mutation operation to this instance.
            </summary>
            <param name="result">The result.</param>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Comparers">
            <summary>
            A shareable container for the comparers used by an immutable dictionary.
            </summary>
            <remarks>
            To reduce allocations, we directly implement the HashBucket and Key-Only comparers,
            but we try to keep this an implementation detail by exposing properties that return
            references for these particular facilities, that are implemented as returning "this".
            </remarks>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Comparers.Default">
            <summary>
            The default instance to use when all the comparers used are their default values.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Comparers._keyComparer">
            <summary>
            The equality comparer to use for the key.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Comparers._valueComparer">
            <summary>
            The value comparer.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Comparers.#ctor(System.Collections.Generic.IEqualityComparer{`0},System.Collections.Generic.IEqualityComparer{`1})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Comparers"/> class.
            </summary>
            <param name="keyComparer">The key only comparer.</param>
            <param name="valueComparer">The value comparer.</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Comparers.KeyComparer">
            <summary>
            Gets the key comparer.
            </summary>
            <value>
            The key comparer.
            </value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Comparers.KeyOnlyComparer">
            <summary>
            Gets the key only comparer.
            </summary>
            <value>
            The key only comparer.
            </value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Comparers.ValueComparer">
            <summary>
            Gets the value comparer.
            </summary>
            <value>
            The value comparer.
            </value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Comparers.HashBucketEqualityComparer">
            <summary>
            Gets the equality comparer to use with hash buckets.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Comparers.Equals(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1}.HashBucket,Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1}.HashBucket)">
            <summary>
            Determines whether the specified objects are equal.
            </summary>
            <param name="x">The first object to compare.</param>
            <param name="y">The second object to compare.</param>
            <returns>
            true if the specified objects are equal; otherwise, false.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Comparers.GetHashCode(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1}.HashBucket)">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <param name="obj">The obj.</param>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Comparers.System#Collections#Generic#IEqualityComparer{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Equals(System.Collections.Generic.KeyValuePair{`0,`1},System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Determines whether the specified objects are equal.
            </summary>
            <param name="x">The first object to compare.</param>
            <param name="y">The second object to compare.</param>
            <returns>
            true if the specified objects are equal; otherwise, false.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Comparers.System#Collections#Generic#IEqualityComparer{System#Collections#Generic#KeyValuePair{TKey,TValue}}#GetHashCode(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <param name="obj">The obj.</param>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Comparers.Get(System.Collections.Generic.IEqualityComparer{`0},System.Collections.Generic.IEqualityComparer{`1})">
            <summary>
            Gets an instance that refers to the specified combination of comparers.
            </summary>
            <param name="keyComparer">The key comparer.</param>
            <param name="valueComparer">The value comparer.</param>
            <returns>An instance of <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Comparers"/></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Comparers.WithValueComparer(System.Collections.Generic.IEqualityComparer{`1})">
            <summary>
            Returns an instance of <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Comparers"/> that shares the same key comparers
            with this instance, but uses the specified value comparer.
            </summary>
            <param name="valueComparer">The new value comparer to use.</param>
            <returns>A new instance of <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Comparers"/></returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Enumerator">
            <summary>
            Enumerates the contents of the collection in an allocation-free manner.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Enumerator._builder">
            <summary>
            The builder being enumerated, if applicable.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Enumerator._mapEnumerator">
            <summary>
            The enumerator over the sorted dictionary whose keys are hash values.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Enumerator._bucketEnumerator">
            <summary>
            The enumerator in use within an individual HashBucket.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Enumerator._enumeratingBuilderVersion">
            <summary>
            The version of the builder (when applicable) that is being enumerated.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Enumerator.#ctor(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode{Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1}.HashBucket},Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1}.Builder)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Enumerator"/> struct.
            </summary>
            <param name="root">The root.</param>
            <param name="builder">The builder, if applicable.</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Enumerator.Current">
            <summary>
            Gets the current element.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Enumerator.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current element.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Enumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Enumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Enumerator.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Enumerator.ThrowIfChanged">
            <summary>
            Throws an exception if the underlying builder's contents have been changed since enumeration started.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if the collection has changed.</exception>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.HashBucket">
            <summary>
            Contains all the key/values in the collection that hash to the same value.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.HashBucket._firstValue">
            <summary>
            One of the values in this bucket.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.HashBucket._additionalElements">
            <summary>
            Any other elements that hash to the same value.
            </summary>
            <value>
            This is null if and only if the entire bucket is empty (including <see cref="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.HashBucket._firstValue"/>).  
            It's empty if <see cref="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.HashBucket._firstValue"/> has an element but no additional elements.
            </value>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.HashBucket.#ctor(System.Collections.Generic.KeyValuePair{`0,`1},Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList{System.Collections.Generic.KeyValuePair{`0,`1}}.Node)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.HashBucket"/> struct.
            </summary>
            <param name="firstElement">The first element.</param>
            <param name="additionalElements">The additional elements.</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.HashBucket.IsEmpty">
            <summary>
            Gets a value indicating whether this instance is empty.
            </summary>
            <value>
              <c>true</c> if this instance is empty; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.HashBucket.FirstValue">
            <summary>
            Gets the first value in this bucket.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.HashBucket.AdditionalElements">
            <summary>
            Gets the list of additional (hash collision) elements.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.HashBucket.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.HashBucket.System#Collections#Generic#IEnumerable{System#Collections#Generic#KeyValuePair{TKey,TValue}}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.HashBucket.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.HashBucket.System#IEquatable{Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#ImmutableDictionary{TKey,TValue}#HashBucket}#Equals(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1}.HashBucket)">
            <summary>
            Throws an exception to catch any errors in comparing HashBucket instances.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.HashBucket.Add(`0,`1,System.Collections.Generic.IEqualityComparer{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`1},Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1}.KeyCollisionBehavior,Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1}.OperationResult@)">
            <summary>
            Adds the specified key.
            </summary>
            <param name="key">The key to add.</param>
            <param name="value">The value to add.</param>
            <param name="keyOnlyComparer">The key comparer.</param>
            <param name="valueComparer">The value comparer.</param>
            <param name="behavior">The intended behavior for certain cases that may come up during the operation.</param>
            <param name="result">A description of the effect was on adding an element to this HashBucket.</param>
            <returns>A new HashBucket that contains the added value and any values already held by this hashbucket.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.HashBucket.Remove(`0,System.Collections.Generic.IEqualityComparer{System.Collections.Generic.KeyValuePair{`0,`1}},Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1}.OperationResult@)">
            <summary>
            Removes the specified value if it exists in the collection.
            </summary>
            <param name="key">The key to remove.</param>
            <param name="keyOnlyComparer">The equality comparer.</param>
            <param name="result">A description of the effect was on adding an element to this HashBucket.</param>
            <returns>A new HashBucket that does not contain the removed value and any values already held by this hashbucket.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.HashBucket.TryGetValue(`0,System.Collections.Generic.IEqualityComparer{System.Collections.Generic.KeyValuePair{`0,`1}},`1@)">
            <summary>
            Gets the value for the given key in the collection if one exists..
            </summary>
            <param name="key">The key to search for.</param>
            <param name="keyOnlyComparer">The key comparer.</param>
            <param name="value">The value for the given key.</param>
            <returns>A value indicating whether the key was found.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.HashBucket.TryGetKey(`0,System.Collections.Generic.IEqualityComparer{System.Collections.Generic.KeyValuePair{`0,`1}},`0@)">
            <summary>
            Searches the dictionary for a given key and returns the equal key it finds, if any.
            </summary>
            <param name="equalKey">The key to search for.</param>
            <param name="keyOnlyComparer">The key comparer.</param>
            <param name="actualKey">The key from the dictionary that the search found, or <paramref name="equalKey"/> if the search yielded no match.</param>
            <returns>A value indicating whether the search was successful.</returns>
            <remarks>
            This can be useful when you want to reuse a previously stored reference instead of
            a newly constructed one (so that more sharing of references can occur) or to look up
            the canonical value, or a value that has more complete data than the value you currently have,
            although their comparer functions indicate they are equal.
            </remarks>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.HashBucket.Freeze">
            <summary>
            Freezes this instance so that any further mutations require new memory allocations.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.HashBucket.Enumerator">
            <summary>
            Enumerates all the elements in this instance.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.HashBucket.Enumerator._bucket">
            <summary>
            The bucket being enumerated.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.HashBucket.Enumerator._currentPosition">
            <summary>
            The current position of this enumerator.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.HashBucket.Enumerator._additionalEnumerator">
            <summary>
            The enumerator that represents the current position over the additionalValues of the HashBucket.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.HashBucket.Enumerator.#ctor(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1}.HashBucket)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.HashBucket.Enumerator"/> struct.
            </summary>
            <param name="bucket">The bucket.</param>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.HashBucket.Enumerator.Position">
            <summary>
            Describes the positions the enumerator state machine may be in.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.HashBucket.Enumerator.Position.BeforeFirst">
            <summary>
            The first element has not yet been moved to.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.HashBucket.Enumerator.Position.First">
            <summary>
            We're at the firstValue of the containing bucket.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.HashBucket.Enumerator.Position.Additional">
            <summary>
            We're enumerating the additionalValues in the bucket.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.HashBucket.Enumerator.Position.End">
            <summary>
            The end of enumeration has been reached.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.HashBucket.Enumerator.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current element.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.HashBucket.Enumerator.Current">
            <summary>
            Gets the current element.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.HashBucket.Enumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.HashBucket.Enumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.HashBucket.Enumerator.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.MutationInput">
            <summary>
            Description of the current data structure as input into a
            mutating or query method.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.MutationInput._root">
            <summary>
            The root of the data structure for the collection.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.MutationInput._comparers">
            <summary>
            The comparer used when comparing hash buckets.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.MutationInput._count">
            <summary>
            The current number of elements in the collection.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.MutationInput.#ctor(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode{Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1}.HashBucket},Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1}.Comparers,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.MutationInput"/> struct.
            </summary>
            <param name="root">The root.</param>
            <param name="comparers">The comparers.</param>
            <param name="count">The current number of elements in the collection.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.MutationInput.#ctor(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.MutationInput"/> struct.
            </summary>
            <param name="map">The map.</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.MutationInput.Root">
            <summary>
            Gets the root of the data structure for the collection.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.MutationInput.KeyComparer">
            <summary>
            Gets the key comparer.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.MutationInput.KeyOnlyComparer">
            <summary>
            Gets the key only comparer.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.MutationInput.ValueComparer">
            <summary>
            Gets the value comparer.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.MutationInput.HashBucketComparer">
            <summary>
            Gets the comparers.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.MutationInput.Count">
            <summary>
            Gets the current number of elements in the collection.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.MutationResult">
            <summary>
            Describes the result of a mutation on the immutable data structure.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.MutationResult._root">
            <summary>
            The root node of the data structure after the mutation.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.MutationResult._countAdjustment">
            <summary>
            The number of elements added or removed from the collection as a result of the operation (a negative number represents removed elements).
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.MutationResult.#ctor(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1}.MutationInput)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.MutationResult"/> struct.
            </summary>
            <param name="unchangedInput">The unchanged input.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.MutationResult.#ctor(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode{Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1}.HashBucket},System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.MutationResult"/> struct.
            </summary>
            <param name="root">The root.</param>
            <param name="countAdjustment">The count adjustment.</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.MutationResult.Root">
            <summary>
            Gets the root node of the data structure after the mutation.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.MutationResult.CountAdjustment">
            <summary>
            Gets the number of elements added or removed from the collection as a result of the operation (a negative number represents removed elements).
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.MutationResult.Finalize(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1})">
            <summary>
            Returns an immutable dictionary that captures the result of this mutation.
            </summary>
            <param name="priorMap">The prior version of the map.  Used to capture the equality comparer and previous count, when applicable.</param>
            <returns>The new collection.</returns>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Empty">
            <summary>
            An empty immutable dictionary with default equality comparers.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.s_FreezeBucketAction">
            <summary>
            The singleton delegate that freezes the contents of hash buckets when the root of the data structure is frozen.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2._count">
            <summary>
            The number of elements in the collection.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2._root">
            <summary>
            The root node of the tree that stores this map.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2._comparers">
            <summary>
            The comparer used when comparing hash buckets.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.#ctor(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode{Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1}.HashBucket},Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1}.Comparers,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2"/> class.
            </summary>
            <param name="root">The root.</param>
            <param name="comparers">The comparers.</param>
            <param name="count">The number of elements in the map.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.#ctor(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1}.Comparers)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2"/> class.
            </summary>
            <param name="comparers">The comparers.</param>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.KeyCollisionBehavior">
            <summary>
            How to respond when a key collision is discovered.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.KeyCollisionBehavior.SetValue">
            <summary>
            Sets the value for the given key, even if that overwrites an existing value.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.KeyCollisionBehavior.Skip">
            <summary>
            Skips the mutating operation if a key conflict is detected.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.KeyCollisionBehavior.ThrowIfValueDifferent">
            <summary>
            Throw an exception if the key already exists with a different key.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.KeyCollisionBehavior.ThrowAlways">
            <summary>
            Throw an exception if the key already exists regardless of its value.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.OperationResult">
            <summary>
            The result of a mutation operation.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.OperationResult.AppliedWithoutSizeChange">
            <summary>
            The change was applied and did not require a change to the number of elements in the collection.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.OperationResult.SizeChanged">
            <summary>
            The change required element(s) to be added or removed from the collection.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.OperationResult.NoChangeRequired">
            <summary>
            No change was required (the operation ended in a no-op).
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Clear">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Count">
            <summary>
            Gets the number of elements in this collection.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.IsEmpty">
            <summary>
            Gets a value indicating whether this instance is empty.
            </summary>
            <value>
              <c>true</c> if this instance is empty; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.KeyComparer">
            <summary>
            Gets the key comparer.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.ValueComparer">
            <summary>
            Gets the value comparer used to determine whether values are equal.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Keys">
            <summary>
            Gets the keys in the map.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Values">
            <summary>
            Gets the values in the map.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableDictionary{TKey,TValue}#Clear">
            <summary>
            Gets the empty instance.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.System#Collections#Generic#IDictionary{TKey,TValue}#Keys">
            <summary>
            Gets the keys.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.System#Collections#Generic#IDictionary{TKey,TValue}#Values">
            <summary>
            Gets the values.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Origin">
            <summary>
            Gets a data structure that captures the current state of this map, as an input into a query or mutating function.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Item(`0)">
            <summary>
            Gets the <typeparamref name="TValue"/> with the specified key.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.System#Collections#Generic#IDictionary{TKey,TValue}#Item(`0)">
            <summary>
            Gets or sets the <typeparamref name="TValue"/> with the specified key.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.ToBuilder">
            <summary>
            Creates a collection with the same contents as this collection that
            can be efficiently mutated across multiple operations using standard
            mutable interfaces.
            </summary>
            <remarks>
            This is an O(1) operation and results in only a single (small) memory allocation.
            The mutable collection that is returned is *not* thread-safe.
            </remarks>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Add(`0,`1)">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.AddRange(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.SetItem(`0,`1)">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.SetItems(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Applies a given set of key=value pairs to an immutable dictionary, replacing any conflicting keys in the resulting dictionary.
            </summary>
            <param name="items">The key=value pairs to set on the map.  Any keys that conflict with existing keys will overwrite the previous values.</param>
            <returns>An immutable dictionary.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Remove(`0)">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.RemoveRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.ContainsKey(`0)">
            <summary>
            Determines whether the specified key contains key.
            </summary>
            <param name="key">The key.</param>
            <returns>
              <c>true</c> if the specified key contains key; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Determines whether [contains] [the specified key value pair].
            </summary>
            <param name="pair">The key value pair.</param>
            <returns>
              <c>true</c> if [contains] [the specified key value pair]; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.TryGetKey(`0,`0@)">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.WithComparers(System.Collections.Generic.IEqualityComparer{`0},System.Collections.Generic.IEqualityComparer{`1})">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.WithComparers(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.ContainsValue(`1)">
            <summary>
            Determines whether the ImmutableSortedMap&lt;TKey,TValue&gt;
            contains an element with the specified value.
            </summary>
            <param name="value">
            The value to locate in the ImmutableSortedMap&lt;TKey,TValue&gt;.
            The value can be null for reference types.
            </param>
            <returns>
            true if the ImmutableSortedMap&lt;TKey,TValue&gt; contains
            an element with the specified value; otherwise, false.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableDictionary{TKey,TValue}#Add(`0,`1)">
            <summary>
            See the IImmutableMap{TKey,TValue} interface
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableDictionary{TKey,TValue}#SetItem(`0,`1)">
            <summary>
            See the IImmutableMap{TKey,TValue} interface
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableDictionary{TKey,TValue}#SetItems(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Applies a given set of key=value pairs to an immutable dictionary, replacing any conflicting keys in the resulting dictionary.
            </summary>
            <param name="items">The key=value pairs to set on the map.  Any keys that conflict with existing keys will overwrite the previous values.</param>
            <returns>An immutable dictionary.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableDictionary{TKey,TValue}#AddRange(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            See the IImmutableMap{TKey,TValue} interface
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableDictionary{TKey,TValue}#RemoveRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            See the IImmutableMap{TKey,TValue} interface
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableDictionary{TKey,TValue}#Remove(`0)">
            <summary>
            See the IImmutableMap{TKey,TValue} interface
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.System#Collections#Generic#IDictionary{TKey,TValue}#Add(`0,`1)">
            <summary>
            Adds an element with the provided key and value to the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <param name="key">The object to use as the key of the element to add.</param>
            <param name="value">The object to use as the value of the element to add.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.
            </exception>
            <exception cref="T:System.ArgumentException">
            An element with the same key already exists in the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </exception>
            <exception cref="T:System.NotSupportedException">
            The <see cref="T:System.Collections.Generic.IDictionary`2"/> is read-only.
            </exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.System#Collections#Generic#IDictionary{TKey,TValue}#Remove(`0)">
            <summary>
            Removes the element with the specified key from the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <returns>
            true if the element is successfully removed; otherwise, false.  This method also returns false if <paramref name="key"/> was not found in the original <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.
            </exception>
            <exception cref="T:System.NotSupportedException">
            The <see cref="T:System.Collections.Generic.IDictionary`2"/> is read-only.
            </exception>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.System#Collections#IDictionary#IsFixedSize">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.IDictionary" /> object has a fixed size.
            </summary>
            <returns>true if the <see cref="T:System.Collections.IDictionary" /> object has a fixed size; otherwise, false.</returns>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.System#Collections#IDictionary#IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.
            </summary>
            <returns>true if the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only; otherwise, false.
              </returns>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.System#Collections#IDictionary#Keys">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.ICollection`1" /> containing the keys of the <see cref="T:System.Collections.Generic.IDictionary`2" />.
            </summary>
            <returns>
            An <see cref="T:System.Collections.Generic.ICollection`1" /> containing the keys of the object that implements <see cref="T:System.Collections.Generic.IDictionary`2" />.
              </returns>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.System#Collections#IDictionary#Values">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.ICollection`1" /> containing the values in the <see cref="T:System.Collections.Generic.IDictionary`2" />.
            </summary>
            <returns>
            An <see cref="T:System.Collections.Generic.ICollection`1" /> containing the values in the object that implements <see cref="T:System.Collections.Generic.IDictionary`2" />.
              </returns>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Root">
            <summary>
            Gets the root node (for testing purposes).
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)">
            <summary>
            Adds an element with the provided key and value to the <see cref="T:System.Collections.IDictionary" /> object.
            </summary>
            <param name="key">The <see cref="T:System.Object" /> to use as the key of the element to add.</param>
            <param name="value">The <see cref="T:System.Object" /> to use as the value of the element to add.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.System#Collections#IDictionary#Contains(System.Object)">
            <summary>
            Determines whether the <see cref="T:System.Collections.IDictionary" /> object contains an element with the specified key.
            </summary>
            <param name="key">The key to locate in the <see cref="T:System.Collections.IDictionary" /> object.</param>
            <returns>
            true if the <see cref="T:System.Collections.IDictionary" /> contains an element with the key; otherwise, false.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.System#Collections#IDictionary#GetEnumerator">
            <summary>
            Returns an <see cref="T:System.Collections.IDictionaryEnumerator" /> object for the <see cref="T:System.Collections.IDictionary" /> object.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IDictionaryEnumerator" /> object for the <see cref="T:System.Collections.IDictionary" /> object.
            </returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.System#Collections#IDictionary#Remove(System.Object)">
            <summary>
            Removes the element with the specified key from the <see cref="T:System.Collections.IDictionary" /> object.
            </summary>
            <param name="key">The key of the element to remove.</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.System#Collections#IDictionary#Item(System.Object)">
            <summary>
            Gets or sets the element with the specified key.
            </summary>
            <param name="key">The key.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.System#Collections#IDictionary#Clear">
            <summary>
            Clears this instance.
            </summary>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.ICollection" /> to an <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:System.Collections.ICollection" />. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
            <param name="arrayIndex">The zero-based index in <paramref name="array" /> at which copying begins.</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.System#Collections#ICollection#SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.
            </summary>
            <returns>An object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.</returns>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.System#Collections#ICollection#IsSynchronized">
            <summary>
            Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread safe).
            </summary>
            <returns>true if access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread safe); otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.System#Collections#Generic#IEnumerable{System#Collections#Generic#KeyValuePair{TKey,TValue}}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.EmptyWithComparers(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1}.Comparers)">
            <summary>
            Gets an empty collection with the specified comparers.
            </summary>
            <param name="comparers">The comparers.</param>
            <returns>The empty dictionary.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.TryCastToImmutableMap(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1}@)">
            <summary>
            Attempts to discover an <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2"/> instance beneath some enumerable sequence
            if one exists.
            </summary>
            <param name="sequence">The sequence that may have come from an immutable map.</param>
            <param name="other">Receives the concrete <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2"/> typed value if one can be found.</param>
            <returns><c>true</c> if the cast was successful; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.ContainsKey(`0,Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1}.MutationInput)">
            <summary>
            Performs the operation on a given data structure.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1},Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1}.MutationInput)">
            <summary>
            Performs the operation on a given data structure.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.TryGetValue(`0,Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1}.MutationInput,`1@)">
            <summary>
            Performs the operation on a given data structure.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.TryGetKey(`0,Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1}.MutationInput,`0@)">
            <summary>
            Performs the operation on a given data structure.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Add(`0,`1,Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1}.KeyCollisionBehavior,Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1}.MutationInput)">
            <summary>
            Performs the operation on a given data structure.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.AddRange(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1}.MutationInput,Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1}.KeyCollisionBehavior)">
            <summary>
            Performs the operation on a given data structure.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Remove(`0,Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1}.MutationInput)">
            <summary>
            Performs the operation on a given data structure.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.UpdateRoot(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode{Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1}.HashBucket},System.Int32,Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1}.HashBucket,System.Collections.Generic.IEqualityComparer{Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1}.HashBucket})">
            <summary>
            Performs the set operation on a given data structure.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Wrap(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode{Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1}.HashBucket},Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1}.Comparers,System.Int32)">
            <summary>
            Wraps the specified data structure with an immutable collection wrapper.
            </summary>
            <param name="root">The root of the data structure.</param>
            <param name="comparers">The comparers.</param>
            <param name="count">The number of elements in the data structure.</param>
            <returns>
            The immutable collection.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.Wrap(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode{Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1}.HashBucket},System.Int32)">
            <summary>
            Wraps the specified data structure with an immutable collection wrapper.
            </summary>
            <param name="root">The root of the data structure.</param>
            <param name="adjustedCountIfDifferentRoot">The adjusted count if the root has changed.</param>
            <returns>The immutable collection.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary`2.AddRange(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Boolean)">
            <summary>
            Bulk adds entries to the map.
            </summary>
            <param name="pairs">The entries to add.</param>
            <param name="avoidToHashMap"><c>true</c> when being called from ToHashMap to avoid StackOverflow.</param>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionaryBuilderDebuggerProxy`2">
            <summary>
            A simple view of the immutable collection that the debugger can show to the developer.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionaryBuilderDebuggerProxy`2._map">
            <summary>
            The collection to be enumerated.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionaryBuilderDebuggerProxy`2._contents">
            <summary>
            The simple view of the collection.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionaryBuilderDebuggerProxy`2.#ctor(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1}.Builder)">
            <summary>   
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionaryBuilderDebuggerProxy`2"/> class.
            </summary>
            <param name="map">The collection to display in the debugger</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionaryBuilderDebuggerProxy`2.Contents">
            <summary>
            Gets a simple debugger-viewable collection.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionaryDebuggerProxy`2">
            <summary>
            A simple view of the immutable collection that the debugger can show to the developer.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionaryDebuggerProxy`2._map">
            <summary>
            The collection to be enumerated.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionaryDebuggerProxy`2._contents">
            <summary>
            The simple view of the collection.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionaryDebuggerProxy`2.#ctor(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionary{`0,`1})">
            <summary>   
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionaryDebuggerProxy`2"/> class.
            </summary>
            <param name="map">The collection to display in the debugger</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableDictionaryDebuggerProxy`2.Contents">
            <summary>
            Gets a simple debugger-viewable collection.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableExtensions">
            <summary>
            Extension methods for immutable types.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableExtensions.TryGetCount``1(System.Collections.Generic.IEnumerable{``0},System.Int32@)">
            <summary>
            Tries to divine the number of elements in a sequence without actually enumerating each element.
            </summary>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <param name="sequence">The enumerable source.</param>
            <param name="count">Receives the number of elements in the enumeration, if it could be determined.</param>
            <returns><c>true</c> if the count could be determined; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableExtensions.TryGetCount``1(System.Collections.IEnumerable,System.Int32@)">
            <summary>
            Tries to divine the number of elements in a sequence without actually enumerating each element.
            </summary>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <param name="sequence">The enumerable source.</param>
            <param name="count">Receives the number of elements in the enumeration, if it could be determined.</param>
            <returns><c>true</c> if the count could be determined; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableExtensions.GetCount``1(System.Collections.Generic.IEnumerable{``0}@)">
            <summary>
            Gets the number of elements in the specified sequence,
            while guaranteeing that the sequence is only enumerated once
            in total by this method and the caller.
            </summary>
            <typeparam name="T">The type of element in the collection.</typeparam>
            <param name="sequence">The sequence.</param>
            <returns>The number of elements in the sequence.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableExtensions.ToArray``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Gets a copy of a sequence as an array.
            </summary>
            <typeparam name="T">The type of element.</typeparam>
            <param name="sequence">The sequence to be copied.</param>
            <param name="count">The number of elements in the sequence.</param>
            <returns>The array.</returns>
            <remarks>
            This is more efficient than the Enumerable.ToArray{T} extension method
            because that only tries to cast the sequence to ICollection{T} to determine
            the count before it falls back to reallocating arrays as it enumerates.
            </remarks>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableExtensions.AsOrderedCollection``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Provides a known wrapper around a sequence of elements that provides the number of elements
            and an indexer into its contents.
            </summary>
            <typeparam name="T">The type of elements in the collection.</typeparam>
            <param name="sequence">The collection.</param>
            <returns>An ordered collection.  May not be thread-safe.  Never null.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableExtensions.ClearFastWhenEmpty``1(System.Collections.Generic.Stack{``0})">
            <summary>
            Clears the specified stack.  For empty stacks, it avoids the call to Clear, which
            avoids a call into the runtime's implementation of Array.Clear, helping performance,
            in particular around inlining.  Stack.Count typically gets inlined by today's JIT, while
            stack.Clear and Array.Clear typically don't.
            </summary>
            <typeparam name="T">Specifies the type of data in the stack to be cleared.</typeparam>
            <param name="stack">The stack to clear.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableExtensions.GetEnumerableDisposable``2(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Gets a disposable enumerable that can be used as the source for a C# foreach loop
            that will not box the enumerator if it is of a particular type.
            </summary>
            <typeparam name="T">The type of value to be enumerated.</typeparam>
            <typeparam name="TEnumerator">The type of the Enumerator struct.</typeparam>
            <param name="enumerable">The collection to be enumerated.</param>
            <returns>A struct that enumerates the collection.</returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableExtensions.ListOfTWrapper`1">
            <summary>
            Wraps a List{T} as an ordered collection.
            </summary>
            <typeparam name="T">The type of element in the collection.</typeparam>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableExtensions.ListOfTWrapper`1._collection">
            <summary>
            The list being exposed.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableExtensions.ListOfTWrapper`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableExtensions.ListOfTWrapper`1"/> class.
            </summary>
            <param name="collection">The collection.</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableExtensions.ListOfTWrapper`1.Count">
            <summary>
            Gets the count.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableExtensions.ListOfTWrapper`1.Item(System.Int32)">
            <summary>
            Gets the <typeparamref name="T"/> at the specified index.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableExtensions.ListOfTWrapper`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableExtensions.ListOfTWrapper`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableExtensions.FallbackWrapper`1">
            <summary>
            Wraps any IEnumerable as an ordered, indexable list.
            </summary>
            <typeparam name="T">The type of element in the collection.</typeparam>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableExtensions.FallbackWrapper`1._sequence">
            <summary>
            The original sequence.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableExtensions.FallbackWrapper`1._collection">
            <summary>
            The list-ified sequence.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableExtensions.FallbackWrapper`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableExtensions.FallbackWrapper`1"/> class.
            </summary>
            <param name="sequence">The sequence.</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableExtensions.FallbackWrapper`1.Count">
            <summary>
            Gets the count.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableExtensions.FallbackWrapper`1.Item(System.Int32)">
            <summary>
            Gets the <typeparamref name="T"/> at the specified index.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableExtensions.FallbackWrapper`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableExtensions.FallbackWrapper`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList">
            <summary>
            A set of initialization methods for instances of <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1"/>.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList.Create``1">
            <summary>
            Returns an empty collection.
            </summary>
            <typeparam name="T">The type of items stored by the collection.</typeparam>
            <returns>The immutable collection.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList.CreateRange``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a new immutable collection prefilled with the specified items.
            </summary>
            <typeparam name="T">The type of items stored by the collection.</typeparam>
            <param name="items">The items to prepopulate.</param>
            <returns>The new immutable collection.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList.ToImmutableList``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Enumerates a sequence exactly once and produces an immutable list of its contents.
            </summary>
            <typeparam name="TSource">The type of element in the sequence.</typeparam>
            <param name="source">The sequence to enumerate.</param>
            <returns>An immutable list.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList.IndexOf``1(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Searches for the specified object and returns the zero-based index of the
            first occurrence within the ImmutableList&lt;T&gt;
            </summary>
            <param name="list">The list to search.</param>
            <param name="item">
            The object to locate in the ImmutableList&lt;T&gt;. The value
            can be null for reference types.
            </param>
            <param name="equalityComparer">The equality comparer to use in the search.</param>
            <returns>
            The zero-based index of the first occurrence of item within the range of
            elements in the ImmutableList&lt;T&gt; that extends from index
            to the last element, if found; otherwise, -1.
            </returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1">
            <content>
            Contains the inner Builder class.
            </content>
            <summary>
            An immutable list implementation.
            </summary>
            <typeparam name="T">The type of elements in the set.</typeparam>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder">
            <summary>
            A list that mutates with little or no memory allocations,
            can produce and/or build on immutable list instances very efficiently.
            </summary>
            <remarks>
            <para>
            While <see cref="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.AddRange(System.Collections.Generic.IEnumerable{`0})"/> and other bulk change methods
            already provide fast bulk change operations on the collection, this class allows
            multiple combinations of changes to be made to a set with equal efficiency.
            </para>
            <para>
            Instance members of this class are <em>not</em> thread-safe.
            </para>
            </remarks>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder._root">
            <summary>
            The binary tree used to store the contents of the list.  Contents are typically not entirely frozen.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder._immutable">
            <summary>
            Caches an immutable instance that represents the current state of the collection.
            </summary>
            <value>Null if no immutable view has been created for the current version.</value>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder._version">
            <summary>
            A number that increments every time the builder changes its contents.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder._syncRoot">
            <summary>
            The object callers may use to synchronize access to this collection.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.#ctor(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder"/> class.
            </summary>
            <param name="list">A list to act as the basis for a new list.</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.Count">
            <summary>
            Gets the number of elements in this list.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <summary>
            Gets a value indicating whether this instance is read-only.
            </summary>
            <value>Always <c>false</c>.</value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.Version">
            <summary>
            Gets the current version of the contents of this builder.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.Root">
            <summary>
            Gets or sets the root node that represents the data in this collection.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.Item(System.Int32)">
            <summary>
            Gets or sets the value for a given index into the list.
            </summary>
            <param name="index">The index of the desired element.</param>
            <returns>The value at the specified index.</returns>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IOrderedCollection{T}#Item(System.Int32)">
            <summary>
            Gets the element in the collection at a given index.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.IndexOf(`0)">
            <summary>
            See <see cref="T:System.Collections.Generic.IList`1"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.Insert(System.Int32,`0)">
            <summary>
            See <see cref="T:System.Collections.Generic.IList`1"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.RemoveAt(System.Int32)">
            <summary>
            See <see cref="T:System.Collections.Generic.IList`1"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.Add(`0)">
            <summary>
            See <see cref="T:System.Collections.Generic.IList`1"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.Clear">
            <summary>
            See <see cref="T:System.Collections.Generic.IList`1"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.Contains(`0)">
            <summary>
            See <see cref="T:System.Collections.Generic.IList`1"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.Remove(`0)">
            <summary>
            See <see cref="T:System.Collections.Generic.IList`1"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.ForEach(System.Action{`0})">
            <summary>
            Performs the specified action on each element of the list.
            </summary>
            <param name="action">The System.Action&lt;T&gt; delegate to perform on each element of the list.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.CopyTo(`0[])">
            <summary>
            Copies the entire ImmutableList&lt;T&gt; to a compatible one-dimensional
            array, starting at the beginning of the target array.
            </summary>
            <param name="array">
            The one-dimensional System.Array that is the destination of the elements
            copied from ImmutableList&lt;T&gt;. The System.Array must have
            zero-based indexing.
            </param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the entire ImmutableList&lt;T&gt; to a compatible one-dimensional
            array, starting at the specified index of the target array.
            </summary>
            <param name="array">
            The one-dimensional System.Array that is the destination of the elements
            copied from ImmutableList&lt;T&gt;. The System.Array must have
            zero-based indexing.
            </param>
            <param name="arrayIndex">
            The zero-based index in array at which copying begins.
            </param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
            <summary>
            Copies a range of elements from the ImmutableList&lt;T&gt; to
            a compatible one-dimensional array, starting at the specified index of the
            target array.
            </summary>
            <param name="index">
            The zero-based index in the source ImmutableList&lt;T&gt; at
            which copying begins.
            </param>
            <param name="array">
            The one-dimensional System.Array that is the destination of the elements
            copied from ImmutableList&lt;T&gt;. The System.Array must have
            zero-based indexing.
            </param>
            <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
            <param name="count">The number of elements to copy.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.GetRange(System.Int32,System.Int32)">
            <summary>
            Creates a shallow copy of a range of elements in the source ImmutableList&lt;T&gt;.
            </summary>
            <param name="index">
            The zero-based ImmutableList&lt;T&gt; index at which the range
            starts.
            </param>
            <param name="count">
            The number of elements in the range.
            </param>
            <returns>
            A shallow copy of a range of elements in the source ImmutableList&lt;T&gt;.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.ConvertAll``1(System.Func{`0,``0})">
            <summary>
            Converts the elements in the current ImmutableList&lt;T&gt; to
            another type, and returns a list containing the converted elements.
            </summary>
            <param name="converter">
            A System.Converter&lt;TInput,TOutput&gt; delegate that converts each element from
            one type to another type.
            </param>
            <typeparam name="TOutput">
            The type of the elements of the target array.
            </typeparam>
            <returns>
            A ImmutableList&lt;T&gt; of the target type containing the converted
            elements from the current ImmutableList&lt;T&gt;.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.Exists(System.Predicate{`0})">
            <summary>
            Determines whether the ImmutableList&lt;T&gt; contains elements
            that match the conditions defined by the specified predicate.
            </summary>
            <param name="match">
            The System.Predicate&lt;T&gt; delegate that defines the conditions of the elements
            to search for.
            </param>
            <returns>
            true if the ImmutableList&lt;T&gt; contains one or more elements
            that match the conditions defined by the specified predicate; otherwise,
            false.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.Find(System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified
            predicate, and returns the first occurrence within the entire ImmutableList&lt;T&gt;.
            </summary>
            <param name="match">
            The System.Predicate&lt;T&gt; delegate that defines the conditions of the element
            to search for.
            </param>
            <returns>
            The first element that matches the conditions defined by the specified predicate,
            if found; otherwise, the default value for type T.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.FindAll(System.Predicate{`0})">
            <summary>
            Retrieves all the elements that match the conditions defined by the specified
            predicate.
            </summary>
            <param name="match">
            The System.Predicate&lt;T&gt; delegate that defines the conditions of the elements
            to search for.
            </param>
            <returns>
            A ImmutableList&lt;T&gt; containing all the elements that match
            the conditions defined by the specified predicate, if found; otherwise, an
            empty ImmutableList&lt;T&gt;.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.FindIndex(System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified
            predicate, and returns the zero-based index of the first occurrence within
            the entire ImmutableList&lt;T&gt;.
            </summary>
            <param name="match">
            The System.Predicate&lt;T&gt; delegate that defines the conditions of the element
            to search for.
            </param>
            <returns>
            The zero-based index of the first occurrence of an element that matches the
            conditions defined by match, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.FindIndex(System.Int32,System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified
            predicate, and returns the zero-based index of the first occurrence within
            the range of elements in the ImmutableList&lt;T&gt; that extends
            from the specified index to the last element.
            </summary>
            <param name="startIndex">The zero-based starting index of the search.</param>
            <param name="match">The System.Predicate&lt;T&gt; delegate that defines the conditions of the element to search for.</param>
            <returns>
            The zero-based index of the first occurrence of an element that matches the
            conditions defined by match, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified
            predicate, and returns the zero-based index of the first occurrence within
            the range of elements in the ImmutableList&lt;T&gt; that starts
            at the specified index and contains the specified number of elements.
            </summary>
            <param name="startIndex">The zero-based starting index of the search.</param>
            <param name="count">The number of elements in the section to search.</param>
            <param name="match">The System.Predicate&lt;T&gt; delegate that defines the conditions of the element to search for.</param>
            <returns>
            The zero-based index of the first occurrence of an element that matches the
            conditions defined by match, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.FindLast(System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified
            predicate, and returns the last occurrence within the entire ImmutableList&lt;T&gt;.
            </summary>
            <param name="match">
            The System.Predicate&lt;T&gt; delegate that defines the conditions of the element
            to search for.
            </param>
            <returns>
            The last element that matches the conditions defined by the specified predicate,
            if found; otherwise, the default value for type T.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.FindLastIndex(System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified
            predicate, and returns the zero-based index of the last occurrence within
            the entire ImmutableList&lt;T&gt;.
            </summary>
            <param name="match">
            The System.Predicate&lt;T&gt; delegate that defines the conditions of the element
            to search for.
            </param>
            <returns>
            The zero-based index of the last occurrence of an element that matches the
            conditions defined by match, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.FindLastIndex(System.Int32,System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified
            predicate, and returns the zero-based index of the last occurrence within
            the range of elements in the ImmutableList&lt;T&gt; that extends
            from the first element to the specified index.
            </summary>
            <param name="startIndex">The zero-based starting index of the backward search.</param>
            <param name="match">The System.Predicate&lt;T&gt; delegate that defines the conditions of the element
            to search for.</param>
            <returns>
            The zero-based index of the last occurrence of an element that matches the
            conditions defined by match, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified
            predicate, and returns the zero-based index of the last occurrence within
            the range of elements in the ImmutableList&lt;T&gt; that contains
            the specified number of elements and ends at the specified index.
            </summary>
            <param name="startIndex">The zero-based starting index of the backward search.</param>
            <param name="count">The number of elements in the section to search.</param>
            <param name="match">
            The System.Predicate&lt;T&gt; delegate that defines the conditions of the element
            to search for.
            </param>
            <returns>
            The zero-based index of the last occurrence of an element that matches the
            conditions defined by match, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.IndexOf(`0,System.Int32)">
            <summary>
            Searches for the specified object and returns the zero-based index of the
            first occurrence within the range of elements in the ImmutableList&lt;T&gt;
            that extends from the specified index to the last element.
            </summary>
            <param name="item">
            The object to locate in the ImmutableList&lt;T&gt;. The value
            can be null for reference types.
            </param>
            <param name="index">
            The zero-based starting index of the search. 0 (zero) is valid in an empty
            list.
            </param>
            <returns>
            The zero-based index of the first occurrence of item within the range of
            elements in the ImmutableList&lt;T&gt; that extends from index
            to the last element, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.IndexOf(`0,System.Int32,System.Int32)">
            <summary>
            Searches for the specified object and returns the zero-based index of the
            first occurrence within the range of elements in the ImmutableList&lt;T&gt;
            that starts at the specified index and contains the specified number of elements.
            </summary>
            <param name="item">
            The object to locate in the ImmutableList&lt;T&gt;. The value
            can be null for reference types.
            </param>
            <param name="index">
            The zero-based starting index of the search. 0 (zero) is valid in an empty
            list.
            </param>
            <param name="count">
            The number of elements in the section to search.
            </param>
            <returns>
            The zero-based index of the first occurrence of item within the range of
            elements in the ImmutableList&lt;T&gt; that starts at index and
            contains count number of elements, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.IndexOf(`0,System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Searches for the specified object and returns the zero-based index of the
            first occurrence within the range of elements in the ImmutableList&lt;T&gt;
            that starts at the specified index and contains the specified number of elements.
            </summary>
            <param name="item">
            The object to locate in the ImmutableList&lt;T&gt;. The value
            can be null for reference types.
            </param>
            <param name="index">
            The zero-based starting index of the search. 0 (zero) is valid in an empty
            list.
            </param>
            <param name="count">
            The number of elements in the section to search.
            </param>
            <param name="equalityComparer">The equality comparer to use in the search.</param>
            <returns>
            The zero-based index of the first occurrence of item within the range of
            elements in the ImmutableList&lt;T&gt; that starts at index and
            contains count number of elements, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.LastIndexOf(`0)">
            <summary>
            Searches for the specified object and returns the zero-based index of the
            last occurrence within the range of elements in the ImmutableList&lt;T&gt;
            that contains the specified number of elements and ends at the specified
            index.
            </summary>
            <param name="item">
            The object to locate in the ImmutableList&lt;T&gt;. The value
            can be null for reference types.
            </param>
            <returns>
            The zero-based index of the last occurrence of item within the range of elements
            in the ImmutableList&lt;T&gt; that contains count number of elements
            and ends at index, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.LastIndexOf(`0,System.Int32,System.Int32)">
            <summary>
            Searches for the specified object and returns the zero-based index of the
            last occurrence within the range of elements in the ImmutableList&lt;T&gt;
            that contains the specified number of elements and ends at the specified
            index.
            </summary>
            <param name="item">
            The object to locate in the ImmutableList&lt;T&gt;. The value
            can be null for reference types.
            </param>
            <param name="startIndex">The zero-based starting index of the backward search.</param>
            <param name="count">The number of elements in the section to search.</param>
            <returns>
            The zero-based index of the last occurrence of item within the range of elements
            in the ImmutableList&lt;T&gt; that contains count number of elements
            and ends at index, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.LastIndexOf(`0,System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Searches for the specified object and returns the zero-based index of the
            last occurrence within the range of elements in the ImmutableList&lt;T&gt;
            that contains the specified number of elements and ends at the specified
            index.
            </summary>
            <param name="item">
            The object to locate in the ImmutableList&lt;T&gt;. The value
            can be null for reference types.
            </param>
            <param name="startIndex">The zero-based starting index of the backward search.</param>
            <param name="count">The number of elements in the section to search.</param>
            <param name="equalityComparer">The equality comparer to use in the search.</param>
            <returns>
            The zero-based index of the last occurrence of item within the range of elements
            in the ImmutableList&lt;T&gt; that contains count number of elements
            and ends at index, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.TrueForAll(System.Predicate{`0})">
            <summary>
            Determines whether every element in the ImmutableList&lt;T&gt;
            matches the conditions defined by the specified predicate.
            </summary>
            <param name="match">
            The System.Predicate&lt;T&gt; delegate that defines the conditions to check against
            the elements.
            </param>
            <returns>
            true if every element in the ImmutableList&lt;T&gt; matches the
            conditions defined by the specified predicate; otherwise, false. If the list
            has no elements, the return value is true.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds the elements of a sequence to the end of this collection.
            </summary>
            <param name="items">
            The sequence whose elements should be appended to this collection.
            The sequence itself cannot be null, but it can contain elements that are
            null, if type <typeparamref name="T"/> is a reference type.
            </param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Inserts the elements of a collection into the ImmutableList&lt;T&gt;
            at the specified index.
            </summary>
            <param name="index">
            The zero-based index at which the new elements should be inserted.
            </param>
            <param name="items">
            The collection whose elements should be inserted into the ImmutableList&lt;T&gt;.
            The collection itself cannot be null, but it can contain elements that are
            null, if type T is a reference type.
            </param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.RemoveAll(System.Predicate{`0})">
            <summary>
            Removes all the elements that match the conditions defined by the specified
            predicate.
            </summary>
            <param name="match">
            The System.Predicate&lt;T&gt; delegate that defines the conditions of the elements
            to remove.
            </param>
            <returns>
            The number of elements removed from the ImmutableList&lt;T&gt;
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.Reverse">
            <summary>
            Reverses the order of the elements in the entire ImmutableList&lt;T&gt;.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.Reverse(System.Int32,System.Int32)">
            <summary>
            Reverses the order of the elements in the specified range.
            </summary>
            <param name="index">The zero-based starting index of the range to reverse.</param>
            <param name="count">The number of elements in the range to reverse.</param> 
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.Sort">
            <summary>
            Sorts the elements in the entire ImmutableList&lt;T&gt; using
            the default comparer.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.Sort(System.Comparison{`0})">
            <summary>
            Sorts the elements in the entire ImmutableList&lt;T&gt; using
            the specified System.Comparison&lt;T&gt;.
            </summary>
            <param name="comparison">
            The System.Comparison&lt;T&gt; to use when comparing elements.
            </param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.Sort(System.Collections.Generic.IComparer{`0})">
            <summary>
            Sorts the elements in the entire ImmutableList&lt;T&gt; using
            the specified comparer.
            </summary>
            <param name="comparer">
            The System.Collections.Generic.IComparer&lt;T&gt; implementation to use when comparing
            elements, or null to use the default comparer System.Collections.Generic.Comparer&lt;T&gt;.Default.
            </param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Sorts the elements in a range of elements in ImmutableList&lt;T&gt;
            using the specified comparer.
            </summary>
            <param name="index">
            The zero-based starting index of the range to sort.
            </param>
            <param name="count">
            The length of the range to sort.
            </param>
            <param name="comparer">
            The System.Collections.Generic.IComparer&lt;T&gt; implementation to use when comparing
            elements, or null to use the default comparer System.Collections.Generic.Comparer&lt;T&gt;.Default.
            </param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.BinarySearch(`0)">
            <summary>
            Searches the entire sorted System.Collections.Generic.List&lt;T&gt; for an element
            using the default comparer and returns the zero-based index of the element.
            </summary>
            <param name="item">The object to locate. The value can be null for reference types.</param>
            <returns>
            The zero-based index of item in the sorted System.Collections.Generic.List&lt;T&gt;,
            if item is found; otherwise, a negative number that is the bitwise complement
            of the index of the next element that is larger than item or, if there is
            no larger element, the bitwise complement of System.Collections.Generic.List&lt;T&gt;.Count.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            The default comparer System.Collections.Generic.Comparer&lt;T&gt;.Default cannot
            find an implementation of the System.IComparable&lt;T&gt; generic interface or
            the System.IComparable interface for type T.
            </exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
            <summary>
             Searches the entire sorted System.Collections.Generic.List&lt;T&gt; for an element
             using the specified comparer and returns the zero-based index of the element.
            </summary>
            <param name="item">The object to locate. The value can be null for reference types.</param>
            <param name="comparer">
            The System.Collections.Generic.IComparer&lt;T&gt; implementation to use when comparing
            elements.-or-null to use the default comparer System.Collections.Generic.Comparer&lt;T&gt;.Default.
            </param>
            <returns>
            The zero-based index of item in the sorted System.Collections.Generic.List&lt;T&gt;,
            if item is found; otherwise, a negative number that is the bitwise complement
            of the index of the next element that is larger than item or, if there is
            no larger element, the bitwise complement of System.Collections.Generic.List&lt;T&gt;.Count.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            comparer is null, and the default comparer System.Collections.Generic.Comparer&lt;T&gt;.Default
            cannot find an implementation of the System.IComparable&lt;T&gt; generic interface
            or the System.IComparable interface for type T.
            </exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
            <summary>
            Searches a range of elements in the sorted System.Collections.Generic.List&lt;T&gt;
            for an element using the specified comparer and returns the zero-based index
            of the element.
            </summary>
            <param name="index">The zero-based starting index of the range to search.</param>
            <param name="count"> The length of the range to search.</param>
            <param name="item">The object to locate. The value can be null for reference types.</param>
            <param name="comparer">
            The System.Collections.Generic.IComparer&lt;T&gt; implementation to use when comparing
            elements, or null to use the default comparer System.Collections.Generic.Comparer&lt;T&gt;.Default.
            </param>
            <returns>
            The zero-based index of item in the sorted System.Collections.Generic.List&lt;T&gt;,
            if item is found; otherwise, a negative number that is the bitwise complement
            of the index of the next element that is larger than item or, if there is
            no larger element, the bitwise complement of System.Collections.Generic.List&lt;T&gt;.Count.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            index is less than 0.-or-count is less than 0.
            </exception>
            <exception cref="T:System.ArgumentException">
            index and count do not denote a valid range in the System.Collections.Generic.List&lt;T&gt;.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            comparer is null, and the default comparer System.Collections.Generic.Comparer&lt;T&gt;.Default
            cannot find an implementation of the System.IComparable&lt;T&gt; generic interface
            or the System.IComparable interface for type T.
            </exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.ToImmutable">
            <summary>
            Creates an immutable list based on the contents of this instance.
            </summary>
            <returns>An immutable list.</returns>
            <remarks>
            This method is an O(n) operation, and approaches O(1) time as the number of
            actual mutations to the set since the last call to this method approaches 0.
            </remarks>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.System#Collections#IList#Add(System.Object)">
            <summary>
            Adds an item to the <see cref="T:System.Collections.IList" />.
            </summary>
            <param name="value">The object to add to the <see cref="T:System.Collections.IList" />.</param>
            <returns>
            The position into which the new element was inserted, or -1 to indicate that the item was not inserted into the collection,
            </returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.System#Collections#IList#Clear">
            <summary>
            Clears this instance.
            </summary>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.System#Collections#IList#Contains(System.Object)">
            <summary>
            Determines whether the <see cref="T:System.Collections.IList" /> contains a specific value.
            </summary>
            <param name="value">The object to locate in the <see cref="T:System.Collections.IList" />.</param>
            <returns>
            true if the <see cref="T:System.Object" /> is found in the <see cref="T:System.Collections.IList" />; otherwise, false.
            </returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.System#Collections#IList#IndexOf(System.Object)">
            <summary>
            Determines the index of a specific item in the <see cref="T:System.Collections.IList" />.
            </summary>
            <param name="value">The object to locate in the <see cref="T:System.Collections.IList" />.</param>
            <returns>
            The index of <paramref name="value" /> if found in the list; otherwise, -1.
            </returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.System#Collections#IList#Insert(System.Int32,System.Object)">
            <summary>
            Inserts an item to the <see cref="T:System.Collections.IList" /> at the specified index.
            </summary>
            <param name="index">The zero-based index at which <paramref name="value" /> should be inserted.</param>
            <param name="value">The object to insert into the <see cref="T:System.Collections.IList" />.</param>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.System#Collections#IList#IsFixedSize">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.IList" /> has a fixed size.
            </summary>
            <returns>true if the <see cref="T:System.Collections.IList" /> has a fixed size; otherwise, false.</returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.System#Collections#IList#IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.
            </summary>
            <returns>true if the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only; otherwise, false.
              </returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.System#Collections#IList#Remove(System.Object)">
            <summary>
            Removes the first occurrence of a specific object from the <see cref="T:System.Collections.IList" />.
            </summary>
            <param name="value">The object to remove from the <see cref="T:System.Collections.IList" />.</param>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.System#Collections#IList#Item(System.Int32)">
            <summary>
            Gets or sets the <see cref="T:System.Object" /> at the specified index.
            </summary>
            <value>
            The <see cref="T:System.Object" />.
            </value>
            <param name="index">The index.</param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.ICollection" /> to an <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:System.Collections.ICollection" />. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
            <param name="arrayIndex">The zero-based index in <paramref name="array" /> at which copying begins.</param>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.System#Collections#ICollection#IsSynchronized">
            <summary>
            Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread safe).
            </summary>
            <returns>true if access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread safe); otherwise, false.</returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Builder.System#Collections#ICollection#SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.
            </summary>
            <returns>An object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.</returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Empty">
            <summary>
            An empty immutable list.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1._root">
            <summary>
            The root node of the AVL tree that stores this set.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1"/> class.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.#ctor(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList{`0}.Node)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1"/> class.
            </summary>
            <param name="root">The root of the AVL tree with the contents of this set.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Clear">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.BinarySearch(`0)">
            <summary>
            Searches the entire sorted System.Collections.Generic.List&lt;T&gt; for an element
            using the default comparer and returns the zero-based index of the element.
            </summary>
            <param name="item">The object to locate. The value can be null for reference types.</param>
            <returns>
            The zero-based index of item in the sorted System.Collections.Generic.List&lt;T&gt;,
            if item is found; otherwise, a negative number that is the bitwise complement
            of the index of the next element that is larger than item or, if there is
            no larger element, the bitwise complement of System.Collections.Generic.List&lt;T&gt;.Count.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            The default comparer System.Collections.Generic.Comparer&lt;T&gt;.Default cannot
            find an implementation of the System.IComparable&lt;T&gt; generic interface or
            the System.IComparable interface for type T.
            </exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
            <summary>
             Searches the entire sorted System.Collections.Generic.List&lt;T&gt; for an element
             using the specified comparer and returns the zero-based index of the element.
            </summary>
            <param name="item">The object to locate. The value can be null for reference types.</param>
            <param name="comparer">
            The System.Collections.Generic.IComparer&lt;T&gt; implementation to use when comparing
            elements.-or-null to use the default comparer System.Collections.Generic.Comparer&lt;T&gt;.Default.
            </param>
            <returns>
            The zero-based index of item in the sorted System.Collections.Generic.List&lt;T&gt;,
            if item is found; otherwise, a negative number that is the bitwise complement
            of the index of the next element that is larger than item or, if there is
            no larger element, the bitwise complement of System.Collections.Generic.List&lt;T&gt;.Count.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            comparer is null, and the default comparer System.Collections.Generic.Comparer&lt;T&gt;.Default
            cannot find an implementation of the System.IComparable&lt;T&gt; generic interface
            or the System.IComparable interface for type T.
            </exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
            <summary>
            Searches a range of elements in the sorted System.Collections.Generic.List&lt;T&gt;
            for an element using the specified comparer and returns the zero-based index
            of the element.
            </summary>
            <param name="index">The zero-based starting index of the range to search.</param>
            <param name="count"> The length of the range to search.</param>
            <param name="item">The object to locate. The value can be null for reference types.</param>
            <param name="comparer">
            The System.Collections.Generic.IComparer&lt;T&gt; implementation to use when comparing
            elements, or null to use the default comparer System.Collections.Generic.Comparer&lt;T&gt;.Default.
            </param>
            <returns>
            The zero-based index of item in the sorted System.Collections.Generic.List&lt;T&gt;,
            if item is found; otherwise, a negative number that is the bitwise complement
            of the index of the next element that is larger than item or, if there is
            no larger element, the bitwise complement of System.Collections.Generic.List&lt;T&gt;.Count.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            index is less than 0.-or-count is less than 0.
            </exception>
            <exception cref="T:System.ArgumentException">
            index and count do not denote a valid range in the System.Collections.Generic.List&lt;T&gt;.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            comparer is null, and the default comparer System.Collections.Generic.Comparer&lt;T&gt;.Default
            cannot find an implementation of the System.IComparable&lt;T&gt; generic interface
            or the System.IComparable interface for type T.
            </exception>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.IsEmpty">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableList{T}#Clear">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1"/> interface.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Count">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1"/> interface.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.System#Collections#ICollection#SyncRoot">
            <summary>
            See ICollection.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.System#Collections#ICollection#IsSynchronized">
            <summary>
            See the ICollection interface.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Item(System.Int32)">
            <summary>
            Gets the element of the set at the given index.
            </summary>
            <param name="index">The 0-based index of the element in the set to return.</param>
            <returns>The element at the given position.</returns>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IOrderedCollection{T}#Item(System.Int32)">
            <summary>
            Gets the element in the collection at a given index.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.ToBuilder">
            <summary>
            Creates a collection with the same contents as this collection that
            can be efficiently mutated across multiple operations using standard
            mutable interfaces.
            </summary>
            <remarks>
            This is an O(1) operation and results in only a single (small) memory allocation.
            The mutable collection that is returned is *not* thread-safe.
            </remarks>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Add(`0)">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Insert(System.Int32,`0)">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Remove(`0)">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Remove(`0,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.RemoveRange(System.Int32,System.Int32)">
            <summary>
            Removes the specified values from this list.
            </summary>
            <param name="index">The starting index to begin removal.</param>
            <param name="count">The number of elements to remove.</param>
            <returns>A new list with the elements removed.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.RemoveRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Removes the specified values from this list.
            </summary>
            <param name="items">The items to remove if matches are found in this list.</param>
            <returns>
            A new list with the elements removed.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.RemoveRange(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Removes the specified values from this list.
            </summary>
            <param name="items">The items to remove if matches are found in this list.</param>
            <param name="equalityComparer">
            The equality comparer to use in the search.
            </param>
            <returns>
            A new list with the elements removed.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.RemoveAt(System.Int32)">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.RemoveAll(System.Predicate{`0})">
            <summary>
            Removes all the elements that match the conditions defined by the specified
            predicate.
            </summary>
            <param name="match">
            The System.Predicate&lt;T&gt; delegate that defines the conditions of the elements
            to remove.
            </param>
            <returns>
            The new list.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.SetItem(System.Int32,`0)">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Replace(`0,`0)">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Replace(`0,`0,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Reverse">
            <summary>
            Reverses the order of the elements in the entire ImmutableList&lt;T&gt;.
            </summary>
            <returns>The reversed list.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Reverse(System.Int32,System.Int32)">
            <summary>
            Reverses the order of the elements in the specified range.
            </summary>
            <param name="index">The zero-based starting index of the range to reverse.</param>
            <param name="count">The number of elements in the range to reverse.</param> 
            <returns>The reversed list.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Sort">
            <summary>
            Sorts the elements in the entire ImmutableList&lt;T&gt; using
            the default comparer.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Sort(System.Comparison{`0})">
            <summary>
            Sorts the elements in the entire ImmutableList&lt;T&gt; using
            the specified System.Comparison&lt;T&gt;.
            </summary>
            <param name="comparison">
            The System.Comparison&lt;T&gt; to use when comparing elements.
            </param>
            <returns>The sorted list.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Sort(System.Collections.Generic.IComparer{`0})">
            <summary>
            Sorts the elements in the entire ImmutableList&lt;T&gt; using
            the specified comparer.
            </summary>
            <param name="comparer">
            The System.Collections.Generic.IComparer&lt;T&gt; implementation to use when comparing
            elements, or null to use the default comparer System.Collections.Generic.Comparer&lt;T&gt;.Default.
            </param>
            <returns>The sorted list.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Sorts the elements in a range of elements in ImmutableList&lt;T&gt;
            using the specified comparer.
            </summary>
            <param name="index">
            The zero-based starting index of the range to sort.
            </param>
            <param name="count">
            The length of the range to sort.
            </param>
            <param name="comparer">
            The System.Collections.Generic.IComparer&lt;T&gt; implementation to use when comparing
            elements, or null to use the default comparer System.Collections.Generic.Comparer&lt;T&gt;.Default.
            </param>
            <returns>The sorted list.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.ForEach(System.Action{`0})">
            <summary>
            Performs the specified action on each element of the list.
            </summary>
            <param name="action">The System.Action&lt;T&gt; delegate to perform on each element of the list.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.CopyTo(`0[])">
            <summary>
            Copies the entire ImmutableList&lt;T&gt; to a compatible one-dimensional
            array, starting at the beginning of the target array.
            </summary>
            <param name="array">
            The one-dimensional System.Array that is the destination of the elements
            copied from ImmutableList&lt;T&gt;. The System.Array must have
            zero-based indexing.
            </param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the entire ImmutableList&lt;T&gt; to a compatible one-dimensional
            array, starting at the specified index of the target array.
            </summary>
            <param name="array">
            The one-dimensional System.Array that is the destination of the elements
            copied from ImmutableList&lt;T&gt;. The System.Array must have
            zero-based indexing.
            </param>
            <param name="arrayIndex">
            The zero-based index in array at which copying begins.
            </param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
            <summary>
            Copies a range of elements from the ImmutableList&lt;T&gt; to
            a compatible one-dimensional array, starting at the specified index of the
            target array.
            </summary>
            <param name="index">
            The zero-based index in the source ImmutableList&lt;T&gt; at
            which copying begins.
            </param>
            <param name="array">
            The one-dimensional System.Array that is the destination of the elements
            copied from ImmutableList&lt;T&gt;. The System.Array must have
            zero-based indexing.
            </param>
            <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
            <param name="count">The number of elements to copy.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.GetRange(System.Int32,System.Int32)">
            <summary>
            Creates a shallow copy of a range of elements in the source ImmutableList&lt;T&gt;.
            </summary>
            <param name="index">
            The zero-based ImmutableList&lt;T&gt; index at which the range
            starts.
            </param>
            <param name="count">
            The number of elements in the range.
            </param>
            <returns>
            A shallow copy of a range of elements in the source ImmutableList&lt;T&gt;.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.ConvertAll``1(System.Func{`0,``0})">
            <summary>
            Converts the elements in the current ImmutableList&lt;T&gt; to
            another type, and returns a list containing the converted elements.
            </summary>
            <param name="converter">
            A System.Converter&lt;TInput,TOutput&gt; delegate that converts each element from
            one type to another type.
            </param>
            <typeparam name="TOutput">
            The type of the elements of the target array.
            </typeparam>
            <returns>
            A ImmutableList&lt;T&gt; of the target type containing the converted
            elements from the current ImmutableList&lt;T&gt;.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Exists(System.Predicate{`0})">
            <summary>
            Determines whether the ImmutableList&lt;T&gt; contains elements
            that match the conditions defined by the specified predicate.
            </summary>
            <param name="match">
            The System.Predicate&lt;T&gt; delegate that defines the conditions of the elements
            to search for.
            </param>
            <returns>
            true if the ImmutableList&lt;T&gt; contains one or more elements
            that match the conditions defined by the specified predicate; otherwise,
            false.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Find(System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified
            predicate, and returns the first occurrence within the entire ImmutableList&lt;T&gt;.
            </summary>
            <param name="match">
            The System.Predicate&lt;T&gt; delegate that defines the conditions of the element
            to search for.
            </param>
            <returns>
            The first element that matches the conditions defined by the specified predicate,
            if found; otherwise, the default value for type T.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.FindAll(System.Predicate{`0})">
            <summary>
            Retrieves all the elements that match the conditions defined by the specified
            predicate.
            </summary>
            <param name="match">
            The System.Predicate&lt;T&gt; delegate that defines the conditions of the elements
            to search for.
            </param>
            <returns>
            A ImmutableList&lt;T&gt; containing all the elements that match
            the conditions defined by the specified predicate, if found; otherwise, an
            empty ImmutableList&lt;T&gt;.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.FindIndex(System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified
            predicate, and returns the zero-based index of the first occurrence within
            the entire ImmutableList&lt;T&gt;.
            </summary>
            <param name="match">
            The System.Predicate&lt;T&gt; delegate that defines the conditions of the element
            to search for.
            </param>
            <returns>
            The zero-based index of the first occurrence of an element that matches the
            conditions defined by match, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.FindIndex(System.Int32,System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified
            predicate, and returns the zero-based index of the first occurrence within
            the range of elements in the ImmutableList&lt;T&gt; that extends
            from the specified index to the last element.
            </summary>
            <param name="startIndex">The zero-based starting index of the search.</param>
            <param name="match">The System.Predicate&lt;T&gt; delegate that defines the conditions of the element to search for.</param>
            <returns>
            The zero-based index of the first occurrence of an element that matches the
            conditions defined by match, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified
            predicate, and returns the zero-based index of the first occurrence within
            the range of elements in the ImmutableList&lt;T&gt; that starts
            at the specified index and contains the specified number of elements.
            </summary>
            <param name="startIndex">The zero-based starting index of the search.</param>
            <param name="count">The number of elements in the section to search.</param>
            <param name="match">The System.Predicate&lt;T&gt; delegate that defines the conditions of the element to search for.</param>
            <returns>
            The zero-based index of the first occurrence of an element that matches the
            conditions defined by match, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.FindLast(System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified
            predicate, and returns the last occurrence within the entire ImmutableList&lt;T&gt;.
            </summary>
            <param name="match">
            The System.Predicate&lt;T&gt; delegate that defines the conditions of the element
            to search for.
            </param>
            <returns>
            The last element that matches the conditions defined by the specified predicate,
            if found; otherwise, the default value for type T.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.FindLastIndex(System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified
            predicate, and returns the zero-based index of the last occurrence within
            the entire ImmutableList&lt;T&gt;.
            </summary>
            <param name="match">
            The System.Predicate&lt;T&gt; delegate that defines the conditions of the element
            to search for.
            </param>
            <returns>
            The zero-based index of the last occurrence of an element that matches the
            conditions defined by match, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.FindLastIndex(System.Int32,System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified
            predicate, and returns the zero-based index of the last occurrence within
            the range of elements in the ImmutableList&lt;T&gt; that extends
            from the first element to the specified index.
            </summary>
            <param name="startIndex">The zero-based starting index of the backward search.</param>
            <param name="match">The System.Predicate&lt;T&gt; delegate that defines the conditions of the element
            to search for.</param>
            <returns>
            The zero-based index of the last occurrence of an element that matches the
            conditions defined by match, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified
            predicate, and returns the zero-based index of the last occurrence within
            the range of elements in the ImmutableList&lt;T&gt; that contains
            the specified number of elements and ends at the specified index.
            </summary>
            <param name="startIndex">The zero-based starting index of the backward search.</param>
            <param name="count">The number of elements in the section to search.</param>
            <param name="match">
            The System.Predicate&lt;T&gt; delegate that defines the conditions of the element
            to search for.
            </param>
            <returns>
            The zero-based index of the last occurrence of an element that matches the
            conditions defined by match, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.IndexOf(`0,System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Searches for the specified object and returns the zero-based index of the
            first occurrence within the range of elements in the ImmutableList&lt;T&gt;
            that starts at the specified index and contains the specified number of elements.
            </summary>
            <param name="item">
            The object to locate in the ImmutableList&lt;T&gt;. The value
            can be null for reference types.
            </param>
            <param name="index">
            The zero-based starting index of the search. 0 (zero) is valid in an empty
            list.
            </param>
            <param name="count">
            The number of elements in the section to search.
            </param>
            <param name="equalityComparer">
            The equality comparer to use in the search.
            </param>
            <returns>
            The zero-based index of the first occurrence of item within the range of
            elements in the ImmutableList&lt;T&gt; that starts at index and
            contains count number of elements, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.LastIndexOf(`0,System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Searches for the specified object and returns the zero-based index of the
            last occurrence within the range of elements in the ImmutableList&lt;T&gt;
            that contains the specified number of elements and ends at the specified
            index.
            </summary>
            <param name="item">
            The object to locate in the ImmutableList&lt;T&gt;. The value
            can be null for reference types.
            </param>
            <param name="index">The zero-based starting index of the backward search.</param>
            <param name="count">The number of elements in the section to search.</param>
            <param name="equalityComparer">
            The equality comparer to use in the search.
            </param>
            <returns>
            The zero-based index of the last occurrence of item within the range of elements
            in the ImmutableList&lt;T&gt; that contains count number of elements
            and ends at index, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.TrueForAll(System.Predicate{`0})">
            <summary>
            Determines whether every element in the ImmutableList&lt;T&gt;
            matches the conditions defined by the specified predicate.
            </summary>
            <param name="match">
            The System.Predicate&lt;T&gt; delegate that defines the conditions to check against
            the elements.
            </param>
            <returns>
            true if every element in the ImmutableList&lt;T&gt; matches the
            conditions defined by the specified predicate; otherwise, false. If the list
            has no elements, the return value is true.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Contains(`0)">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.IndexOf(`0)">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableList{T}#Add(`0)">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableList{T}#AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableList{T}#Insert(System.Int32,`0)">
            <summary>
            Inserts the specified value at the specified index.
            </summary>
            <param name="index">The index at which to insert the value.</param>
            <param name="item">The element to add.</param>
            <returns>The new immutable list.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableList{T}#InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Inserts the specified value at the specified index.
            </summary>
            <param name="index">The index at which to insert the value.</param>
            <param name="items">The elements to add.</param>
            <returns>The new immutable list.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableList{T}#Remove(`0,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableList{T}#RemoveAll(System.Predicate{`0})">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableList{T}#RemoveRange(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableList{T}#RemoveRange(System.Int32,System.Int32)">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableList`1"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableList{T}#RemoveAt(System.Int32)">
            <summary>
            Removes the element at the specified index.
            </summary>
            <param name="index">The index.</param>
            <returns>A new list with the elements removed.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableList{T}#SetItem(System.Int32,`0)">
            <summary>
            Replaces an element in the list at a given position with the specified element.
            </summary>
            <param name="index">The position in the list of the element to replace.</param>
            <param name="value">The element to replace the old element with.</param>
            <returns>The new list.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableList{T}#Replace(`0,`0,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Replaces an element in the list with the specified element.
            </summary>
            <param name="oldValue">The element to replace.</param>
            <param name="newValue">The element to replace the old element with.</param>
            <param name="equalityComparer">
            The equality comparer to use in the search.
            </param>
            <returns>The new list.</returns>
            <exception cref="T:System.ArgumentException">Thrown when the old value does not exist in the list.</exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.System#Collections#Generic#IList{T}#Insert(System.Int32,`0)">
            <summary>
            Inserts the specified index.
            </summary>
            <param name="index">The index.</param>
            <param name="item">The item.</param>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.System#Collections#Generic#IList{T}#RemoveAt(System.Int32)">
            <summary>
            Removes the value at the specified index.
            </summary>
            <param name="index">The index.</param>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.System#Collections#Generic#IList{T}#Item(System.Int32)">
            <summary>
            Gets or sets the value at the specified index.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <summary>
            Adds the specified item.
            </summary>
            <param name="item">The item.</param>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.System#Collections#Generic#ICollection{T}#Clear">
            <summary>
            Clears this instance.
            </summary>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.
            </summary>
            <returns>true if the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only; otherwise, false.
              </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.System#Collections#Generic#ICollection{T}#Remove(`0)">
            <summary>
            Removes the specified item.
            </summary>
            <param name="item">The item.</param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            See the ICollection interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.System#Collections#IList#Add(System.Object)">
            <summary>
            Adds an item to the <see cref="T:System.Collections.IList" />.
            </summary>
            <param name="value">The object to add to the <see cref="T:System.Collections.IList" />.</param>
            <returns>
            The position into which the new element was inserted, or -1 to indicate that the item was not inserted into the collection,
            </returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.System#Collections#IList#RemoveAt(System.Int32)">
            <summary>
            Removes the <see cref="T:System.Collections.IList" /> item at the specified index.
            </summary>
            <param name="index">The zero-based index of the item to remove.</param>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.System#Collections#IList#Clear">
            <summary>
            Clears this instance.
            </summary>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.System#Collections#IList#Contains(System.Object)">
            <summary>
            Determines whether the <see cref="T:System.Collections.IList" /> contains a specific value.
            </summary>
            <param name="value">The object to locate in the <see cref="T:System.Collections.IList" />.</param>
            <returns>
            true if the <see cref="T:System.Object" /> is found in the <see cref="T:System.Collections.IList" />; otherwise, false.
            </returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.System#Collections#IList#IndexOf(System.Object)">
            <summary>
            Determines the index of a specific item in the <see cref="T:System.Collections.IList" />.
            </summary>
            <param name="value">The object to locate in the <see cref="T:System.Collections.IList" />.</param>
            <returns>
            The index of <paramref name="value" /> if found in the list; otherwise, -1.
            </returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.System#Collections#IList#Insert(System.Int32,System.Object)">
            <summary>
            Inserts an item to the <see cref="T:System.Collections.IList" /> at the specified index.
            </summary>
            <param name="index">The zero-based index at which <paramref name="value" /> should be inserted.</param>
            <param name="value">The object to insert into the <see cref="T:System.Collections.IList" />.</param>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.System#Collections#IList#IsFixedSize">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.IList" /> has a fixed size.
            </summary>
            <returns>true if the <see cref="T:System.Collections.IList" /> has a fixed size; otherwise, false.</returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.System#Collections#IList#IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.
            </summary>
            <returns>true if the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only; otherwise, false.
              </returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.System#Collections#IList#Remove(System.Object)">
            <summary>
            Removes the first occurrence of a specific object from the <see cref="T:System.Collections.IList" />.
            </summary>
            <param name="value">The object to remove from the <see cref="T:System.Collections.IList" />.</param>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.System#Collections#IList#Item(System.Int32)">
            <summary>
            Gets or sets the <see cref="T:System.Object" /> at the specified index.
            </summary>
            <value>
            The <see cref="T:System.Object" />.
            </value>
            <param name="index">The index.</param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <remarks>
            CAUTION: when this enumerator is actually used as a valuetype (not boxed) do NOT copy it by assigning to a second variable 
            or by passing it to another method.  When this enumerator is disposed of it returns a mutable reference type stack to a resource pool,
            and if the value type enumerator is copied (which can easily happen unintentionally if you pass the value around) there is a risk
            that a stack that has already been returned to the resource pool may still be in use by one of the enumerator copies, leading to data
            corruption and/or exceptions.
            </remarks>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Root">
            <summary>
            Returns the Root Node of the list
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.WrapNode(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList{`0}.Node)">
            <summary>
            Creates a new sorted set wrapper for a node tree.
            </summary>
            <param name="root">The root of the collection.</param>
            <returns>The immutable sorted set instance.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.TryCastToImmutableList(System.Collections.Generic.IEnumerable{`0},Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList{`0}@)">
            <summary>
            Attempts to discover an <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1"/> instance beneath some enumerable sequence
            if one exists.
            </summary>
            <param name="sequence">The sequence that may have come from an immutable list.</param>
            <param name="other">Receives the concrete <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1"/> typed value if one can be found.</param>
            <returns><c>true</c> if the cast was successful; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Wrap(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList{`0}.Node)">
            <summary>
            Creates a wrapping collection type around a root node.
            </summary>
            <param name="root">The root node to wrap.</param>
            <returns>A wrapping collection type for the new tree.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.FillFromEmpty(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates an immutable list with the contents from a sequence of elements.
            </summary>
            <param name="items">The sequence of elements from which to create the list.</param>
            <returns>The immutable list.</returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Enumerator">
            <summary>
            Enumerates the contents of a binary tree.
            </summary>
            <remarks>
            This struct can and should be kept in exact sync with the other binary tree enumerators: 
            ImmutableList.Enumerator, ImmutableSortedMap.Enumerator, and ImmutableSortedSet.Enumerator.
            
            CAUTION: when this enumerator is actually used as a valuetype (not boxed) do NOT copy it by assigning to a second variable 
            or by passing it to another method.  When this enumerator is disposed of it returns a mutable reference type stack to a resource pool,
            and if the value type enumerator is copied (which can easily happen unintentionally if you pass the value around) there is a risk
            that a stack that has already been returned to the resource pool may still be in use by one of the enumerator copies, leading to data
            corruption and/or exceptions.
            </remarks>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Enumerator.s_EnumeratingStacks">
            <summary>
            The resource pool of reusable mutable stacks for purposes of enumeration.
            </summary>
            <remarks>
            We utilize this resource pool to make "allocation free" enumeration achievable.
            </remarks>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Enumerator._builder">
            <summary>
            The builder being enumerated, if applicable.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Enumerator._poolUserId">
            <summary>
            A unique ID for this instance of this enumerator.
            Used to protect pooled objects from use after they are recycled.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Enumerator._startIndex">
            <summary>
            The starting index of the collection at which to begin enumeration.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Enumerator._count">
            <summary>
            The number of elements to include in the enumeration.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Enumerator._remainingCount">
            <summary>
            The number of elements left in the enumeration.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Enumerator._reversed">
            <summary>
            A value indicating whether this enumerator walks in reverse order.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Enumerator._root">
            <summary>
            The set being enumerated.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Enumerator._stack">
            <summary>
            The stack to use for enumerating the binary tree.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Enumerator._current">
            <summary>
            The node currently selected.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Enumerator._enumeratingBuilderVersion">
            <summary>
            The version of the builder (when applicable) that is being enumerated.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Enumerator.#ctor(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList{`0}.Node,Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList{`0}.Builder,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Initializes an Enumerator structure.
            </summary>
            <param name="root">The root of the set to be enumerated.</param>
            <param name="builder">The builder, if applicable.</param>
            <param name="startIndex">The index of the first element to enumerate.</param>
            <param name="count">The number of elements in this collection.</param>
            <param name="reversed"><c>true</c> if the list should be enumerated in reverse order.</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Enumerator.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#ISecurePooledObjectUser#PoolUserId">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Enumerator.Current">
            <summary>
            The current element.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Enumerator.System#Collections#IEnumerator#Current">
            <summary>
            The current element.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Enumerator.Dispose">
            <summary>
            Disposes of this enumerator and returns the stack reference to the resource pool.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Enumerator.MoveNext">
            <summary>
            Advances enumeration to the next element.
            </summary>
            <returns>A value indicating whether there is another element in the enumeration.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Enumerator.Reset">
            <summary>
            Restarts enumeration.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Enumerator.ResetStack">
            <summary>Resets the stack used for enumeration.</summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Enumerator.NextBranch(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList{`0}.Node)">
            <summary>
            Obtains the right branch of the given node (or the left, if walking in reverse).
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Enumerator.PreviousBranch(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList{`0}.Node)">
            <summary>
            Obtains the left branch of the given node (or the right, if walking in reverse).
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Enumerator.ThrowIfDisposed">
            <summary>
            Throws an ObjectDisposedException if this enumerator has been disposed.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Enumerator.ThrowIfChanged">
            <summary>
            Throws an exception if the underlying builder's contents have been changed since enumeration started.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if the collection has changed.</exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Enumerator.PushNext(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList{`0}.Node)">
            <summary>
            Pushes this node and all its Left descendents onto the stack.
            </summary>
            <param name="node">The starting node to push onto the stack.</param>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node">
            <summary>
            A node in the AVL tree storing this set.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.EmptyNode">
            <summary>
            The default empty node.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node._key">
            <summary>
            The key associated with this node.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node._frozen">
            <summary>
            A value indicating whether this node has been frozen (made immutable).
            </summary>
            <remarks>
            Nodes must be frozen before ever being observed by a wrapping collection type
            to protect collections from further mutations.
            </remarks>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node._height">
            <summary>
            The depth of the tree beneath this node.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node._count">
            <summary>
            The number of elements contained by this subtree starting at this node.
            </summary>
            <remarks>
            If this node would benefit from saving 4 bytes, we could have only a few nodes 
            scattered throughout the graph actually record the count of nodes beneath them.
            Those without the count could query their descendents, which would often short-circuit
            when they hit a node that *does* include a count field.
            </remarks>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node._left">
            <summary>
            The left tree.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node._right">
            <summary>
            The right tree.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node"/> class
            that is pre-frozen.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.#ctor(`0,Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList{`0}.Node,Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList{`0}.Node,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node"/> class
            that is not yet frozen.
            </summary>
            <param name="key">The value stored by this node.</param>
            <param name="left">The left branch.</param>
            <param name="right">The right branch.</param>
            <param name="frozen">Whether this node is prefrozen.</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.IsEmpty">
            <summary>
            Gets a value indicating whether this instance is empty.
            </summary>
            <value>
            <c>true</c> if this instance is empty; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.Height">
            <summary>
            Gets the height of the tree beneath this node.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.Left">
            <summary>
            Gets the left branch of this node.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IBinaryTree#Left">
            <summary>
            Gets the left branch of this node.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.Right">
            <summary>
            Gets the right branch of this node.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IBinaryTree#Right">
            <summary>
            Gets the right branch of this node.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IBinaryTree{T}#Left">
            <summary>
            Gets the left branch of this node.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IBinaryTree{T}#Right">
            <summary>
            Gets the right branch of this node.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.Value">
            <summary>
            Gets the value represented by the current node.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.Count">
            <summary>
            Gets the number of elements contained by this subtree starting at this node.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.Key">
            <summary>
            Gets the key.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.Item(System.Int32)">
            <summary>
            Gets the element of the set at the given index.
            </summary>
            <param name="index">The 0-based index of the element in the set to return.</param>
            <returns>The element at the given position.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.GetEnumerator(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList{`0}.Builder)">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <param name="builder">The builder, if applicable.</param>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.NodeTreeFromList(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IOrderedCollection{`0},System.Int32,System.Int32)">
            <summary>
            Creates a node tree that contains the contents of a list.
            </summary>
            <param name="items">An indexable list with the contents that the new node tree should contain.</param>
            <param name="start">The starting index within <paramref name="items"/> that should be captured by the node tree.</param>
            <param name="length">The number of elements from <paramref name="items"/> that should be captured by the node tree.</param>
            <returns>The root of the created node tree.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.Add(`0)">
            <summary>
            Adds the specified key to the tree.
            </summary>
            <param name="key">The key.</param>
            <returns>The new tree.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.Insert(System.Int32,`0)">
            <summary>
            Adds a value at a given index to this node.
            </summary>
            <param name="index">The location for the new value.</param>
            <param name="key">The value to add.</param>
            <returns>The new tree.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds the specified keys to the tree.
            </summary>
            <param name="keys">The keys.</param>
            <returns>The new tree.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds a collection of values at a given index to this node.
            </summary>
            <param name="index">The location for the new values.</param>
            <param name="keys">The values to add.</param>
            <returns>The new tree.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.RemoveAt(System.Int32)">
            <summary>
            Removes a value at a given index to this node.
            </summary>
            <param name="index">The location for the new value.</param>
            <returns>The new tree.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.RemoveAll(System.Predicate{`0})">
            <summary>
            Removes all the elements that match the conditions defined by the specified
            predicate.
            </summary>
            <param name="match">
            The System.Predicate&lt;T&gt; delegate that defines the conditions of the elements
            to remove.
            </param>
            <returns>
            The new node tree.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.ReplaceAt(System.Int32,`0)">
            <summary>
            Replaces a value at a given index.
            </summary>
            <param name="index">The location for the new value.</param>
            <param name="value">The new value for the node.</param>
            <returns>The new tree.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.Reverse">
            <summary>
            Reverses the order of the elements in the entire ImmutableList&lt;T&gt;.
            </summary>
            <returns>The reversed list.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.Reverse(System.Int32,System.Int32)">
            <summary>
            Reverses the order of the elements in the specified range.
            </summary>
            <param name="index">The zero-based starting index of the range to reverse.</param>
            <param name="count">The number of elements in the range to reverse.</param> 
            <returns>The reversed list.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.Sort">
            <summary>
            Sorts the elements in the entire ImmutableList&lt;T&gt; using
            the default comparer.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.Sort(System.Comparison{`0})">
            <summary>
            Sorts the elements in the entire ImmutableList&lt;T&gt; using
            the specified System.Comparison&lt;T&gt;.
            </summary>
            <param name="comparison">
            The System.Comparison&lt;T&gt; to use when comparing elements.
            </param>
            <returns>The sorted list.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.Sort(System.Collections.Generic.IComparer{`0})">
            <summary>
            Sorts the elements in the entire ImmutableList&lt;T&gt; using
            the specified comparer.
            </summary>
            <param name="comparer">
            The System.Collections.Generic.IComparer&lt;T&gt; implementation to use when comparing
            elements, or null to use the default comparer System.Collections.Generic.Comparer&lt;T&gt;.Default.
            </param>
            <returns>The sorted list.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Sorts the elements in a range of elements in ImmutableList&lt;T&gt;
            using the specified comparer.
            </summary>
            <param name="index">
            The zero-based starting index of the range to sort.
            </param>
            <param name="count">
            The length of the range to sort.
            </param>
            <param name="comparer">
            The System.Collections.Generic.IComparer&lt;T&gt; implementation to use when comparing
            elements, or null to use the default comparer System.Collections.Generic.Comparer&lt;T&gt;.Default.
            </param>
            <returns>The sorted list.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
            <summary>
            Searches a range of elements in the sorted System.Collections.Generic.List&lt;T&gt;
            for an element using the specified comparer and returns the zero-based index
            of the element.
            </summary>
            <param name="index">The zero-based starting index of the range to search.</param>
            <param name="count"> The length of the range to search.</param>
            <param name="item">The object to locate. The value can be null for reference types.</param>
            <param name="comparer">
            The System.Collections.Generic.IComparer&lt;T&gt; implementation to use when comparing
            elements, or null to use the default comparer System.Collections.Generic.Comparer&lt;T&gt;.Default.
            </param>
            <returns>
            The zero-based index of item in the sorted System.Collections.Generic.List&lt;T&gt;,
            if item is found; otherwise, a negative number that is the bitwise complement
            of the index of the next element that is larger than item or, if there is
            no larger element, the bitwise complement of System.Collections.Generic.List&lt;T&gt;.Count.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            index is less than 0.-or-count is less than 0.
            </exception>
            <exception cref="T:System.ArgumentException">
            index and count do not denote a valid range in the System.Collections.Generic.List&lt;T&gt;.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            comparer is null, and the default comparer System.Collections.Generic.Comparer&lt;T&gt;.Default
            cannot find an implementation of the System.IComparable&lt;T&gt; generic interface
            or the System.IComparable interface for type T.
            </exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.IndexOf(`0,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Searches for the specified object and returns the zero-based index of the
            first occurrence within the range of elements in the ImmutableList&lt;T&gt;
            that starts at the specified index and contains the specified number of elements.
            </summary>
            <param name="item">
            The object to locate in the ImmutableList&lt;T&gt;. The value
            can be null for reference types.
            </param>
            <param name="equalityComparer">The equality comparer to use for testing the match of two elements.</param>
            <returns>
            The zero-based index of the first occurrence of item within the range of
            elements in the ImmutableList&lt;T&gt; that starts at index and
            contains count number of elements, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.IndexOf(`0,System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Searches for the specified object and returns the zero-based index of the
            first occurrence within the range of elements in the ImmutableList&lt;T&gt;
            that starts at the specified index and contains the specified number of elements.
            </summary>
            <param name="item">
            The object to locate in the ImmutableList&lt;T&gt;. The value
            can be null for reference types.
            </param>
            <param name="index">
            The zero-based starting index of the search. 0 (zero) is valid in an empty
            list.
            </param>
            <param name="count">
            The number of elements in the section to search.
            </param>
            <param name="equalityComparer">The equality comparer to use for testing the match of two elements.</param>
            <returns>
            The zero-based index of the first occurrence of item within the range of
            elements in the ImmutableList&lt;T&gt; that starts at index and
            contains count number of elements, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.LastIndexOf(`0,System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Searches for the specified object and returns the zero-based index of the
            last occurrence within the range of elements in the ImmutableList&lt;T&gt;
            that contains the specified number of elements and ends at the specified
            index.
            </summary>
            <param name="item">
            The object to locate in the ImmutableList&lt;T&gt;. The value
            can be null for reference types.
            </param>
            <param name="index">The zero-based starting index of the backward search.</param>
            <param name="count">The number of elements in the section to search.</param>
            <param name="equalityComparer">The equality comparer to use for testing the match of two elements.</param>
            <returns>
            The zero-based index of the last occurrence of item within the range of elements
            in the ImmutableList&lt;T&gt; that contains count number of elements
            and ends at index, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.CopyTo(`0[])">
            <summary>
            Copies the entire ImmutableList&lt;T&gt; to a compatible one-dimensional
            array, starting at the beginning of the target array.
            </summary>
            <param name="array">
            The one-dimensional System.Array that is the destination of the elements
            copied from ImmutableList&lt;T&gt;. The System.Array must have
            zero-based indexing.
            </param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the entire ImmutableList&lt;T&gt; to a compatible one-dimensional
            array, starting at the specified index of the target array.
            </summary>
            <param name="array">
            The one-dimensional System.Array that is the destination of the elements
            copied from ImmutableList&lt;T&gt;. The System.Array must have
            zero-based indexing.
            </param>
            <param name="arrayIndex">
            The zero-based index in array at which copying begins.
            </param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
            <summary>
            Copies a range of elements from the ImmutableList&lt;T&gt; to
            a compatible one-dimensional array, starting at the specified index of the
            target array.
            </summary>
            <param name="index">
            The zero-based index in the source ImmutableList&lt;T&gt; at
            which copying begins.
            </param>
            <param name="array">
            The one-dimensional System.Array that is the destination of the elements
            copied from ImmutableList&lt;T&gt;. The System.Array must have
            zero-based indexing.
            </param>
            <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
            <param name="count">The number of elements to copy.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.ICollection" /> to an <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:System.Collections.ICollection" />. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
            <param name="arrayIndex">The zero-based index in <paramref name="array" /> at which copying begins.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.ConvertAll``1(System.Func{`0,``0})">
            <summary>
            Converts the elements in the current ImmutableList&lt;T&gt; to
            another type, and returns a list containing the converted elements.
            </summary>
            <param name="converter">
            A System.Converter&lt;TInput,TOutput&gt; delegate that converts each element from
            one type to another type.
            </param>
            <typeparam name="TOutput">
            The type of the elements of the target array.
            </typeparam>
            <returns>
            A node tree with the transformed list.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.TrueForAll(System.Predicate{`0})">
            <summary>
            Determines whether every element in the ImmutableList&lt;T&gt;
            matches the conditions defined by the specified predicate.
            </summary>
            <param name="match">
            The System.Predicate&lt;T&gt; delegate that defines the conditions to check against
            the elements.
            </param>
            <returns>
            true if every element in the ImmutableList&lt;T&gt; matches the
            conditions defined by the specified predicate; otherwise, false. If the list
            has no elements, the return value is true.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.Exists(System.Predicate{`0})">
            <summary>
            Determines whether the ImmutableList&lt;T&gt; contains elements
            that match the conditions defined by the specified predicate.
            </summary>
            <param name="match">
            The System.Predicate&lt;T&gt; delegate that defines the conditions of the elements
            to search for.
            </param>
            <returns>
            true if the ImmutableList&lt;T&gt; contains one or more elements
            that match the conditions defined by the specified predicate; otherwise,
            false.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.Find(System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified
            predicate, and returns the first occurrence within the entire ImmutableList&lt;T&gt;.
            </summary>
            <param name="match">
            The System.Predicate&lt;T&gt; delegate that defines the conditions of the element
            to search for.
            </param>
            <returns>
            The first element that matches the conditions defined by the specified predicate,
            if found; otherwise, the default value for type T.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.FindAll(System.Predicate{`0})">
            <summary>
            Retrieves all the elements that match the conditions defined by the specified
            predicate.
            </summary>
            <param name="match">
            The System.Predicate&lt;T&gt; delegate that defines the conditions of the elements
            to search for.
            </param>
            <returns>
            A ImmutableList&lt;T&gt; containing all the elements that match
            the conditions defined by the specified predicate, if found; otherwise, an
            empty ImmutableList&lt;T&gt;.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.FindIndex(System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified
            predicate, and returns the zero-based index of the first occurrence within
            the entire ImmutableList&lt;T&gt;.
            </summary>
            <param name="match">
            The System.Predicate&lt;T&gt; delegate that defines the conditions of the element
            to search for.
            </param>
            <returns>
            The zero-based index of the first occurrence of an element that matches the
            conditions defined by match, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.FindIndex(System.Int32,System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified
            predicate, and returns the zero-based index of the first occurrence within
            the range of elements in the ImmutableList&lt;T&gt; that extends
            from the specified index to the last element.
            </summary>
            <param name="startIndex">The zero-based starting index of the search.</param>
            <param name="match">The System.Predicate&lt;T&gt; delegate that defines the conditions of the element to search for.</param>
            <returns>
            The zero-based index of the first occurrence of an element that matches the
            conditions defined by match, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified
            predicate, and returns the zero-based index of the first occurrence within
            the range of elements in the ImmutableList&lt;T&gt; that starts
            at the specified index and contains the specified number of elements.
            </summary>
            <param name="startIndex">The zero-based starting index of the search.</param>
            <param name="count">The number of elements in the section to search.</param>
            <param name="match">The System.Predicate&lt;T&gt; delegate that defines the conditions of the element to search for.</param>
            <returns>
            The zero-based index of the first occurrence of an element that matches the
            conditions defined by match, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.FindLast(System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified
            predicate, and returns the last occurrence within the entire ImmutableList&lt;T&gt;.
            </summary>
            <param name="match">
            The System.Predicate&lt;T&gt; delegate that defines the conditions of the element
            to search for.
            </param>
            <returns>
            The last element that matches the conditions defined by the specified predicate,
            if found; otherwise, the default value for type T.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.FindLastIndex(System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified
            predicate, and returns the zero-based index of the last occurrence within
            the entire ImmutableList&lt;T&gt;.
            </summary>
            <param name="match">
            The System.Predicate&lt;T&gt; delegate that defines the conditions of the element
            to search for.
            </param>
            <returns>
            The zero-based index of the last occurrence of an element that matches the
            conditions defined by match, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.FindLastIndex(System.Int32,System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified
            predicate, and returns the zero-based index of the last occurrence within
            the range of elements in the ImmutableList&lt;T&gt; that extends
            from the first element to the specified index.
            </summary>
            <param name="startIndex">The zero-based starting index of the backward search.</param>
            <param name="match">The System.Predicate&lt;T&gt; delegate that defines the conditions of the element
            to search for.</param>
            <returns>
            The zero-based index of the last occurrence of an element that matches the
            conditions defined by match, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
            <summary>
            Searches for an element that matches the conditions defined by the specified
            predicate, and returns the zero-based index of the last occurrence within
            the range of elements in the ImmutableList&lt;T&gt; that contains
            the specified number of elements and ends at the specified index.
            </summary>
            <param name="startIndex">The zero-based starting index of the backward search.</param>
            <param name="count">The number of elements in the section to search.</param>
            <param name="match">
            The System.Predicate&lt;T&gt; delegate that defines the conditions of the element
            to search for.
            </param>
            <returns>
            The zero-based index of the last occurrence of an element that matches the
            conditions defined by match, if found; otherwise, -1.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.Freeze">
            <summary>
            Freezes this node and all descendent nodes so that any mutations require a new instance of the nodes.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.RotateLeft(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList{`0}.Node)">
            <summary>
            AVL rotate left operation.
            </summary>
            <param name="tree">The tree.</param>
            <returns>The rotated tree.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.RotateRight(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList{`0}.Node)">
            <summary>
            AVL rotate right operation.
            </summary>
            <param name="tree">The tree.</param>
            <returns>The rotated tree.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.DoubleLeft(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList{`0}.Node)">
            <summary>
            AVL rotate double-left operation.
            </summary>
            <param name="tree">The tree.</param>
            <returns>The rotated tree.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.DoubleRight(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList{`0}.Node)">
            <summary>
            AVL rotate double-right operation.
            </summary>
            <param name="tree">The tree.</param>
            <returns>The rotated tree.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.Balance(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList{`0}.Node)">
            <summary>
            Returns a value indicating whether the tree is in balance.
            </summary>
            <param name="tree">The tree.</param>
            <returns>0 if the tree is in balance, a positive integer if the right side is heavy, or a negative integer if the left side is heavy.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.IsRightHeavy(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList{`0}.Node)">
            <summary>
            Determines whether the specified tree is right heavy.
            </summary>
            <param name="tree">The tree.</param>
            <returns>
            <c>true</c> if [is right heavy] [the specified tree]; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.IsLeftHeavy(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList{`0}.Node)">
            <summary>
            Determines whether the specified tree is left heavy.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.MakeBalanced(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList{`0}.Node)">
            <summary>
            Balances the specified tree.
            </summary>
            <param name="tree">The tree.</param>
            <returns>A balanced tree.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.BalanceNode(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList{`0}.Node)">
            <summary>
            Balance the specified node.  Allows for a large imbalance between left and
            right nodes, but assumes left and right nodes are individually balanced.
            </summary>
            <param name="node">The node.</param>
            <returns>A balanced node</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.Mutate(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList{`0}.Node,Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList{`0}.Node)">
            <summary>
            Creates a node mutation, either by mutating this node (if not yet frozen) or by creating a clone of this node
            with the described changes.
            </summary>
            <param name="left">The left branch of the mutated node.</param>
            <param name="right">The right branch of the mutated node.</param>
            <returns>The mutated (or created) node.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList`1.Node.Mutate(`0)">
            <summary>
            Creates a node mutation, either by mutating this node (if not yet frozen) or by creating a clone of this node
            with the described changes.
            </summary>
            <param name="value">The new value for this node.</param>
            <returns>The mutated (or created) node.</returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableListBuilderDebuggerProxy`1">
            <summary>
            A simple view of the immutable list that the debugger can show to the developer.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableListBuilderDebuggerProxy`1._list">
            <summary>
            The collection to be enumerated.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableListBuilderDebuggerProxy`1._cachedContents">
            <summary>
            The simple view of the collection.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableListBuilderDebuggerProxy`1.#ctor(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList{`0}.Builder)">
            <summary>   
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableListBuilderDebuggerProxy`1"/> class.
            </summary>
            <param name="builder">The list to display in the debugger</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableListBuilderDebuggerProxy`1.Contents">
            <summary>
            Gets a simple debugger-viewable list.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableListDebuggerProxy`1">
            <summary>
            A simple view of the immutable list that the debugger can show to the developer.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableListDebuggerProxy`1._list">
            <summary>
            The collection to be enumerated.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableListDebuggerProxy`1._cachedContents">
            <summary>
            The simple view of the collection.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableListDebuggerProxy`1.#ctor(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableList{`0})">
            <summary>   
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableListDebuggerProxy`1"/> class.
            </summary>
            <param name="list">The list to display in the debugger</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableListDebuggerProxy`1.Contents">
            <summary>
            Gets a simple debugger-viewable list.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1">
            <summary>
            An immutable queue.
            </summary>
            <typeparam name="T">The type of elements stored in the queue.</typeparam>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1.s_EmptyField">
            <summary>
            The singleton empty queue.
            </summary>
            <remarks>
            Additional instances representing the empty queue may exist on deserialized instances.
            Actually since this queue is a struct, instances don't even apply and there are no singletons.
            </remarks>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1._backwards">
            <summary>
            The end of the queue that enqueued elements are pushed onto.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1._forwards">
            <summary>
            The end of the queue from which elements are dequeued.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1._backwardsReversed">
            <summary>
            Backing field for the <see cref="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1.BackwardsReversed"/> property.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1.#ctor(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack{`0},Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1"/> class.
            </summary>
            <param name="forward">The forward stack.</param>
            <param name="backward">The backward stack.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1.Clear">
            <summary>
            Gets the empty queue.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1.IsEmpty">
            <summary>
            Gets a value indicating whether this instance is empty.
            </summary>
            <value>
              <c>true</c> if this instance is empty; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1.Empty">
            <summary>
            Gets the empty queue.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableQueue{T}#Clear">
            <summary>
            Gets an empty queue.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1.BackwardsReversed">
            <summary>
            Gets the reversed <see cref="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1._backwards"/> stack.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1.Peek">
            <summary>
            Gets the element at the front of the queue.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown when the stack is empty.</exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1.Enqueue(`0)">
            <summary>
            Adds an element to the back of the queue.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The new queue.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableQueue{T}#Enqueue(`0)">
            <summary>
            Adds an element to the back of the queue.
            </summary>
            <param name="value">The value.</param>
            <returns>
            The new queue.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1.Dequeue">
            <summary>
            Returns a queue that is missing the front element.
            </summary>
            <returns>A queue; never <c>null</c>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when the stack is empty.</exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1.Dequeue(`0@)">
            <summary>
            Retrieves the item at the head of the queue, and returns a queue with the head element removed.
            </summary>
            <param name="value">Receives the value from the head of the queue.</param>
            <returns>The new queue with the head element removed.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when the stack is empty.</exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableQueue{T}#Dequeue">
            <summary>
            Returns a queue that is missing the front element.
            </summary>
            <returns>A queue; never <c>null</c>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when the stack is empty.</exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            An <see cref="T:Enumerator"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1.Enumerator">
            <summary>
            A memory allocation-free enumerator of <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1"/>.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1.Enumerator._originalQueue">
            <summary>
            The original queue being enumerated.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1.Enumerator._remainingForwardsStack">
            <summary>
            The remaining forwards stack of the queue being enumerated.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1.Enumerator._remainingBackwardsStack">
            <summary>
            The remaining backwards stack of the queue being enumerated.
            Its order is reversed when the field is first initialized.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1.Enumerator.#ctor(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1.Enumerator"/> struct.
            </summary>
            <param name="queue">The queue to enumerate.</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1.Enumerator.Current">
            <summary>
            The current element.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1.Enumerator.MoveNext">
            <summary>
            Advances enumeration to the next element.
            </summary>
            <returns>A value indicating whether there is another element in the enumeration.</returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1.EnumeratorObject">
            <summary>
            A memory allocation-free enumerator of <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1"/>.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1.EnumeratorObject._originalQueue">
            <summary>
            The original queue being enumerated.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1.EnumeratorObject._remainingForwardsStack">
            <summary>
            The remaining forwards stack of the queue being enumerated.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1.EnumeratorObject._remainingBackwardsStack">
            <summary>
            The remaining backwards stack of the queue being enumerated.
            Its order is reversed when the field is first initialized.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1.EnumeratorObject._disposed">
            <summary>
            A value indicating whether this enumerator has been disposed.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1.EnumeratorObject.#ctor(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1.Enumerator"/> struct.
            </summary>
            <param name="queue">The queue to enumerate.</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1.EnumeratorObject.Current">
            <summary>
            The current element.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1.EnumeratorObject.System#Collections#IEnumerator#Current">
            <summary>
            The current element.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1.EnumeratorObject.MoveNext">
            <summary>
            Advances enumeration to the next element.
            </summary>
            <returns>A value indicating whether there is another element in the enumeration.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1.EnumeratorObject.Reset">
            <summary>
            Restarts enumeration.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1.EnumeratorObject.Dispose">
            <summary>
            Disposes this instance.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue`1.EnumeratorObject.ThrowIfDisposed">
            <summary>
            Throws an <see cref="T:System.ObjectDisposedException"/> if this 
            enumerator has already been disposed.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueueDebuggerProxy`1">
            <summary>
            A simple view of the immutable collection that the debugger can show to the developer.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueueDebuggerProxy`1._queue">
            <summary>
            The collection to be enumerated.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueueDebuggerProxy`1._contents">
            <summary>
            The simple view of the collection.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueueDebuggerProxy`1.#ctor(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueue{`0})">
            <summary>   
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueueDebuggerProxy`1"/> class.
            </summary>
            <param name="queue">The collection to display in the debugger</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableQueueDebuggerProxy`1.Contents">
            <summary>
            Gets a simple debugger-viewable collection.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2">
            <content>
            Contains the inner Builder class.
            </content>
            <summary>
            An immutable sorted dictionary implementation.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder">
            <summary>
            A sorted dictionary that mutates with little or no memory allocations,
            can produce and/or build on immutable sorted dictionary instances very efficiently.
            </summary>
            <remarks>
            <para>
            This class allows multiple combinations of changes to be made to a set with equal efficiency.
            </para>
            <para>
            Instance members of this class are <em>not</em> thread-safe.
            </para>
            </remarks>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder._root">
            <summary>
            The binary tree used to store the contents of the map.  Contents are typically not entirely frozen.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder._keyComparer">
            <summary>
            The key comparer.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder._valueComparer">
            <summary>
            The value comparer.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder._count">
            <summary>
            The number of entries in the map.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder._immutable">
            <summary>
            Caches an immutable instance that represents the current state of the collection.
            </summary>
            <value>Null if no immutable view has been created for the current version.</value>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder._version">
            <summary>
            A number that increments every time the builder changes its contents.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder._syncRoot">
            <summary>
            The object callers may use to synchronize access to this collection.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.#ctor(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary{`0,`1})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder"/> class.
            </summary>
            <param name="map">A map to act as the basis for a new map.</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.System#Collections#Generic#IDictionary{TKey,TValue}#Keys">
            <summary>
            See <see cref="T:System.Collections.Generic.IDictionary`2"/>
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.Keys">
            <summary>
            See <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/>
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.System#Collections#Generic#IDictionary{TKey,TValue}#Values">
            <summary>
            See <see cref="T:System.Collections.Generic.IDictionary`2"/>
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.Values">
            <summary>
            See <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/>
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.Count">
            <summary>
            Gets the number of elements in this map.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#IsReadOnly">
            <summary>
            Gets a value indicating whether this instance is read-only.
            </summary>
            <value>Always <c>false</c>.</value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.Version">
            <summary>
            Gets the current version of the contents of this builder.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.Root">
            <summary>
            Gets or sets the root node that represents the data in this collection.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.Item(`0)">
            <summary>
            Gets or sets the value for a given key.
            </summary>
            <param name="key">The key.</param>
            <returns>The value associated with the given key.</returns>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.System#Collections#IDictionary#IsFixedSize">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.IDictionary" /> object has a fixed size.
            </summary>
            <returns>true if the <see cref="T:System.Collections.IDictionary" /> object has a fixed size; otherwise, false.</returns>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.System#Collections#IDictionary#IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.
            </summary>
            <returns>true if the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only; otherwise, false.
              </returns>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.System#Collections#IDictionary#Keys">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.ICollection`1" /> containing the keys of the <see cref="T:System.Collections.Generic.IDictionary`2" />.
            </summary>
            <returns>
            An <see cref="T:System.Collections.Generic.ICollection`1" /> containing the keys of the object that implements <see cref="T:System.Collections.Generic.IDictionary`2" />.
              </returns>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.System#Collections#IDictionary#Values">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.ICollection`1" /> containing the values in the <see cref="T:System.Collections.Generic.IDictionary`2" />.
            </summary>
            <returns>
            An <see cref="T:System.Collections.Generic.ICollection`1" /> containing the values in the object that implements <see cref="T:System.Collections.Generic.IDictionary`2" />.
              </returns>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.System#Collections#ICollection#SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.
            </summary>
            <returns>An object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.</returns>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.System#Collections#ICollection#IsSynchronized">
            <summary>
            Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread safe).
            </summary>
            <returns>true if access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread safe); otherwise, false.</returns>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.KeyComparer">
            <summary>
            Gets or sets the key comparer.
            </summary>
            <value>
            The key comparer.
            </value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.ValueComparer">
            <summary>
            Gets or sets the value comparer.
            </summary>
            <value>
            The value comparer.
            </value>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.System#Collections#IDictionary#Add(System.Object,System.Object)">
            <summary>
            Adds an element with the provided key and value to the <see cref="T:System.Collections.IDictionary" /> object.
            </summary>
            <param name="key">The <see cref="T:System.Object" /> to use as the key of the element to add.</param>
            <param name="value">The <see cref="T:System.Object" /> to use as the value of the element to add.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.System#Collections#IDictionary#Contains(System.Object)">
            <summary>
            Determines whether the <see cref="T:System.Collections.IDictionary" /> object contains an element with the specified key.
            </summary>
            <param name="key">The key to locate in the <see cref="T:System.Collections.IDictionary" /> object.</param>
            <returns>
            true if the <see cref="T:System.Collections.IDictionary" /> contains an element with the key; otherwise, false.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.System#Collections#IDictionary#GetEnumerator">
            <summary>
            Returns an <see cref="T:System.Collections.IDictionaryEnumerator" /> object for the <see cref="T:System.Collections.IDictionary" /> object.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IDictionaryEnumerator" /> object for the <see cref="T:System.Collections.IDictionary" /> object.
            </returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.System#Collections#IDictionary#Remove(System.Object)">
            <summary>
            Removes the element with the specified key from the <see cref="T:System.Collections.IDictionary" /> object.
            </summary>
            <param name="key">The key of the element to remove.</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.System#Collections#IDictionary#Item(System.Object)">
            <summary>
            Gets or sets the element with the specified key.
            </summary>
            <param name="key">The key.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.ICollection" /> to an <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:System.Collections.ICollection" />. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
            <param name="index">The zero-based index in <paramref name="array" /> at which copying begins.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.Add(`0,`1)">
            <summary>
            See <see cref="T:System.Collections.Generic.IDictionary`2"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.ContainsKey(`0)">
            <summary>
            See <see cref="T:System.Collections.Generic.IDictionary`2"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.Remove(`0)">
            <summary>
            See <see cref="T:System.Collections.Generic.IDictionary`2"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.TryGetValue(`0,`1@)">
            <summary>
            See <see cref="T:System.Collections.Generic.IDictionary`2"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.TryGetKey(`0,`0@)">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            See <see cref="T:System.Collections.Generic.IDictionary`2"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.Clear">
            <summary>
            See <see cref="T:System.Collections.Generic.IDictionary`2"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            See <see cref="T:System.Collections.Generic.IDictionary`2"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            See <see cref="T:System.Collections.Generic.IDictionary`2"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            See <see cref="T:System.Collections.Generic.IDictionary`2"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.GetEnumerator">
            <summary>
            See <see cref="T:System.Collections.Generic.IDictionary`2"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.System#Collections#Generic#IEnumerable{System#Collections#Generic#KeyValuePair{TKey,TValue}}#GetEnumerator">
            <summary>
            See <see cref="T:System.Collections.Generic.IDictionary`2"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            See <see cref="T:System.Collections.Generic.IDictionary`2"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.ContainsValue(`1)">
            <summary>
            Determines whether the ImmutableSortedMap&lt;TKey,TValue&gt;
            contains an element with the specified value.
            </summary>
            <param name="value">
            The value to locate in the ImmutableSortedMap&lt;TKey,TValue&gt;.
            The value can be null for reference types.
            </param>
            <returns>
            true if the ImmutableSortedMap&lt;TKey,TValue&gt; contains
            an element with the specified value; otherwise, false.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.AddRange(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Removes any entries from the dictionaries with keys that match those found in the specified sequence.
            </summary>
            <param name="items">The keys for entries to remove from the dictionary.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.RemoveRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Removes any entries from the dictionaries with keys that match those found in the specified sequence.
            </summary>
            <param name="keys">The keys for entries to remove from the dictionary.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.GetValueOrDefault(`0)">
            <summary>
            Gets the value for a given key if a matching key exists in the dictionary.
            </summary>
            <param name="key">The key to search for.</param>
            <returns>The value for the key, or <c>default(TValue)</c> if no matching key was found.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.GetValueOrDefault(`0,`1)">
            <summary>
            Gets the value for a given key if a matching key exists in the dictionary.
            </summary>
            <param name="key">The key to search for.</param>
            <param name="defaultValue">The default value to return if no matching key is found in the dictionary.</param>
            <returns>
            The value for the key, or <paramref name="defaultValue"/> if no matching key was found.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Builder.ToImmutable">
            <summary>
            Creates an immutable sorted dictionary based on the contents of this instance.
            </summary>
            <returns>An immutable map.</returns>
            <remarks>
            This method is an O(n) operation, and approaches O(1) time as the number of
            actual mutations to the set since the last call to this method approaches 0.
            </remarks>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Empty">
            <summary>
            An empty sorted dictionary with default sort and equality comparers.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2._root">
            <summary>
            The root node of the AVL tree that stores this map.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2._count">
            <summary>
            The number of elements in the set.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2._keyComparer">
            <summary>
            The comparer used to sort keys in this map.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2._valueComparer">
            <summary>
            The comparer used to detect equivalent values in this map.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.#ctor(System.Collections.Generic.IComparer{`0},System.Collections.Generic.IEqualityComparer{`1})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2"/> class.
            </summary>
            <param name="keyComparer">The key comparer.</param>
            <param name="valueComparer">The value comparer.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.#ctor(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary{`0,`1}.Node,System.Int32,System.Collections.Generic.IComparer{`0},System.Collections.Generic.IEqualityComparer{`1})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2"/> class.
            </summary>
            <param name="root">The root of the tree containing the contents of the map.</param>
            <param name="count">The number of elements in this map.</param>
            <param name="keyComparer">The key comparer.</param>
            <param name="valueComparer">The value comparer.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Clear">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.ValueComparer">
            <summary>
            Gets the value comparer used to determine whether values are equal.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.IsEmpty">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Count">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Keys">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Values">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableDictionary{TKey,TValue}#Clear">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#Generic#IDictionary{TKey,TValue}#Keys">
            <summary>
            Gets the keys.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#Generic#IDictionary{TKey,TValue}#Values">
            <summary>
            Gets the values.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.KeyComparer">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Root">
            <summary>
            Gets the root node (for testing purposes).
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Item(`0)">
            <summary>
            Gets the <typeparamref name="TValue"/> with the specified key.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#Generic#IDictionary{TKey,TValue}#Item(`0)">
            <summary>
            Gets or sets the <typeparamref name="TValue"/> with the specified key.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.ToBuilder">
            <summary>
            Creates a collection with the same contents as this collection that
            can be efficiently mutated across multiple operations using standard
            mutable interfaces.
            </summary>
            <remarks>
            This is an O(1) operation and results in only a single (small) memory allocation.
            The mutable collection that is returned is *not* thread-safe.
            </remarks>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Add(`0,`1)">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.SetItem(`0,`1)">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.SetItems(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Applies a given set of key=value pairs to an immutable dictionary, replacing any conflicting keys in the resulting dictionary.
            </summary>
            <param name="items">The key=value pairs to set on the map.  Any keys that conflict with existing keys will overwrite the previous values.</param>
            <returns>An immutable dictionary.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.AddRange(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Remove(`0)">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.RemoveRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.WithComparers(System.Collections.Generic.IComparer{`0},System.Collections.Generic.IEqualityComparer{`1})">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.WithComparers(System.Collections.Generic.IComparer{`0})">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.ContainsValue(`1)">
            <summary>
            Determines whether the ImmutableSortedMap&lt;TKey,TValue&gt;
            contains an element with the specified value.
            </summary>
            <param name="value">
            The value to locate in the ImmutableSortedMap&lt;TKey,TValue&gt;.
            The value can be null for reference types.
            </param>
            <returns>
            true if the ImmutableSortedMap&lt;TKey,TValue&gt; contains
            an element with the specified value; otherwise, false.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableDictionary{TKey,TValue}#Add(`0,`1)">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableDictionary{TKey,TValue}#SetItem(`0,`1)">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableDictionary{TKey,TValue}#SetItems(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Applies a given set of key=value pairs to an immutable dictionary, replacing any conflicting keys in the resulting dictionary.
            </summary>
            <param name="items">The key=value pairs to set on the map.  Any keys that conflict with existing keys will overwrite the previous values.</param>
            <returns>An immutable dictionary.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableDictionary{TKey,TValue}#AddRange(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableDictionary{TKey,TValue}#RemoveRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableDictionary{TKey,TValue}#Remove(`0)">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.ContainsKey(`0)">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.TryGetKey(`0,`0@)">
            <summary>
            See the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#Generic#IDictionary{TKey,TValue}#Add(`0,`1)">
            <summary>
            Adds an element with the provided key and value to the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <param name="key">The object to use as the key of the element to add.</param>
            <param name="value">The object to use as the value of the element to add.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.
            </exception>
            <exception cref="T:System.ArgumentException">
            An element with the same key already exists in the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </exception>
            <exception cref="T:System.NotSupportedException">
            The <see cref="T:System.Collections.Generic.IDictionary`2"/> is read-only.
            </exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#Generic#IDictionary{TKey,TValue}#Remove(`0)">
            <summary>
            Removes the element with the specified key from the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <returns>
            true if the element is successfully removed; otherwise, false.  This method also returns false if <paramref name="key"/> was not found in the original <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.
            </exception>
            <exception cref="T:System.NotSupportedException">
            The <see cref="T:System.Collections.Generic.IDictionary`2"/> is read-only.
            </exception>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#IDictionary#IsFixedSize">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.IDictionary" /> object has a fixed size.
            </summary>
            <returns>true if the <see cref="T:System.Collections.IDictionary" /> object has a fixed size; otherwise, false.</returns>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#IDictionary#IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.
            </summary>
            <returns>true if the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only; otherwise, false.
              </returns>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#IDictionary#Keys">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.ICollection`1" /> containing the keys of the <see cref="T:System.Collections.Generic.IDictionary`2" />.
            </summary>
            <returns>
            An <see cref="T:System.Collections.Generic.ICollection`1" /> containing the keys of the object that implements <see cref="T:System.Collections.Generic.IDictionary`2" />.
              </returns>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#IDictionary#Values">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.ICollection`1" /> containing the values in the <see cref="T:System.Collections.Generic.IDictionary`2" />.
            </summary>
            <returns>
            An <see cref="T:System.Collections.Generic.ICollection`1" /> containing the values in the object that implements <see cref="T:System.Collections.Generic.IDictionary`2" />.
              </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)">
            <summary>
            Adds an element with the provided key and value to the <see cref="T:System.Collections.IDictionary" /> object.
            </summary>
            <param name="key">The <see cref="T:System.Object" /> to use as the key of the element to add.</param>
            <param name="value">The <see cref="T:System.Object" /> to use as the value of the element to add.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#IDictionary#Contains(System.Object)">
            <summary>
            Determines whether the <see cref="T:System.Collections.IDictionary" /> object contains an element with the specified key.
            </summary>
            <param name="key">The key to locate in the <see cref="T:System.Collections.IDictionary" /> object.</param>
            <returns>
            true if the <see cref="T:System.Collections.IDictionary" /> contains an element with the key; otherwise, false.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#IDictionary#GetEnumerator">
            <summary>
            Returns an <see cref="T:System.Collections.IDictionaryEnumerator" /> object for the <see cref="T:System.Collections.IDictionary" /> object.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IDictionaryEnumerator" /> object for the <see cref="T:System.Collections.IDictionary" /> object.
            </returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#IDictionary#Remove(System.Object)">
            <summary>
            Removes the element with the specified key from the <see cref="T:System.Collections.IDictionary" /> object.
            </summary>
            <param name="key">The key of the element to remove.</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#IDictionary#Item(System.Object)">
            <summary>
            Gets or sets the element with the specified key.
            </summary>
            <param name="key">The key.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#IDictionary#Clear">
            <summary>
            Clears this instance.
            </summary>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.ICollection" /> to an <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:System.Collections.ICollection" />. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
            <param name="index">The zero-based index in <paramref name="array" /> at which copying begins.</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#ICollection#SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.
            </summary>
            <returns>An object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.</returns>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#ICollection#IsSynchronized">
            <summary>
            Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread safe).
            </summary>
            <returns>true if access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread safe); otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#Generic#IEnumerable{System#Collections#Generic#KeyValuePair{TKey,TValue}}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Wrap(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary{`0,`1}.Node,System.Int32,System.Collections.Generic.IComparer{`0},System.Collections.Generic.IEqualityComparer{`1})">
            <summary>
            Creates a new sorted set wrapper for a node tree.
            </summary>
            <param name="root">The root of the collection.</param>
            <param name="count">The number of elements in the map.</param>
            <param name="keyComparer">The key comparer to use for the map.</param>
            <param name="valueComparer">The value comparer to use for the map.</param>
            <returns>The immutable sorted set instance.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.TryCastToImmutableMap(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary{`0,`1}@)">
            <summary>
            Attempts to discover an <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2"/> instance beneath some enumerable sequence
            if one exists.
            </summary>
            <param name="sequence">The sequence that may have come from an immutable map.</param>
            <param name="other">Receives the concrete <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2"/> typed value if one can be found.</param>
            <returns><c>true</c> if the cast was successful; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.AddRange(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Boolean,System.Boolean)">
            <summary>
            Bulk adds entries to the map.
            </summary>
            <param name="items">The entries to add.</param>
            <param name="overwriteOnCollision"><c>true</c> to allow the <paramref name="items"/> sequence to include duplicate keys and let the last one win; <c>false</c> to throw on collisions.</param>
            <param name="avoidToSortedMap"><c>true</c> when being called from ToHashMap to avoid StackOverflow.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Wrap(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary{`0,`1}.Node,System.Int32)">
            <summary>
            Creates a wrapping collection type around a root node.
            </summary>
            <param name="root">The root node to wrap.</param>
            <param name="adjustedCountIfDifferentRoot">The number of elements in the new tree, assuming it's different from the current tree.</param>
            <returns>A wrapping collection type for the new tree.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.FillFromEmpty(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Boolean)">
            <summary>
            Efficiently creates a new collection based on the contents of some sequence.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Enumerator">
            <summary>
            Enumerates the contents of a binary tree.
            </summary>
            <remarks>
            This struct can and should be kept in exact sync with the other binary tree enumerators: 
            ImmutableList.Enumerator, ImmutableSortedMap.Enumerator, and ImmutableSortedSet.Enumerator.
            
            CAUTION: when this enumerator is actually used as a valuetype (not boxed) do NOT copy it by assigning to a second variable 
            or by passing it to another method.  When this enumerator is disposed of it returns a mutable reference type stack to a resource pool,
            and if the value type enumerator is copied (which can easily happen unintentionally if you pass the value around) there is a risk
            that a stack that has already been returned to the resource pool may still be in use by one of the enumerator copies, leading to data
            corruption and/or exceptions.
            </remarks>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Enumerator.s_enumeratingStacks">
            <summary>
            The resource pool of reusable mutable stacks for purposes of enumeration.
            </summary>
            <remarks>
            We utilize this resource pool to make "allocation free" enumeration achievable.
            </remarks>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Enumerator._builder">
            <summary>
            The builder being enumerated, if applicable.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Enumerator._poolUserId">
            <summary>
            A unique ID for this instance of this enumerator.
            Used to protect pooled objects from use after they are recycled.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Enumerator._root">
            <summary>
            The set being enumerated.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Enumerator._stack">
            <summary>
            The stack to use for enumerating the binary tree.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Enumerator._current">
            <summary>
            The node currently selected.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Enumerator._enumeratingBuilderVersion">
            <summary>
            The version of the builder (when applicable) that is being enumerated.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Enumerator.#ctor(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary{`0,`1}.Node,Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary{`0,`1}.Builder)">
            <summary>
            Initializes an Enumerator structure.
            </summary>
            <param name="root">The root of the set to be enumerated.</param>
            <param name="builder">The builder, if applicable.</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Enumerator.Current">
            <summary>
            The current element.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Enumerator.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#ISecurePooledObjectUser#PoolUserId">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Enumerator.System#Collections#IEnumerator#Current">
            <summary>
            The current element.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Enumerator.Dispose">
            <summary>
            Disposes of this enumerator and returns the stack reference to the resource pool.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Enumerator.MoveNext">
            <summary>
            Advances enumeration to the next element.
            </summary>
            <returns>A value indicating whether there is another element in the enumeration.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Enumerator.Reset">
            <summary>
            Restarts enumeration.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Enumerator.ThrowIfDisposed">
            <summary>
            Throws an ObjectDisposedException if this enumerator has been disposed.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Enumerator.ThrowIfChanged">
            <summary>
            Throws an exception if the underlying builder's contents have been changed since enumeration started.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if the collection has changed.</exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Enumerator.PushLeft(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary{`0,`1}.Node)">
            <summary>
            Pushes this node and all its Left descendents onto the stack.
            </summary>
            <param name="node">The starting node to push onto the stack.</param>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node">
            <summary>
            A node in the AVL tree storing this map.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.EmptyNode">
            <summary>
            The default empty node.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node._key">
            <summary>
            The key associated with this node.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node._value">
            <summary>
            The value associated with this node.
            </summary>
            <remarks>
            Sadly this field could be readonly but doing so breaks serialization due to bug: 
            http://connect.microsoft.com/VisualStudio/feedback/details/312970/weird-argumentexception-when-deserializing-field-in-typedreferences-cannot-be-static-or-init-only
            </remarks>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node._frozen">
            <summary>
            A value indicating whether this node has been frozen (made immutable).
            </summary>
            <remarks>
            Nodes must be frozen before ever being observed by a wrapping collection type
            to protect collections from further mutations.
            </remarks>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node._height">
            <summary>
            The depth of the tree beneath this node.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node._left">
            <summary>
            The left tree.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node._right">
            <summary>
            The right tree.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node"/> class
            that is pre-frozen.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.#ctor(`0,`1,Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary{`0,`1}.Node,Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary{`0,`1}.Node,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node"/> class
            that is not yet frozen.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <param name="frozen">Whether this node is prefrozen.</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.IsEmpty">
            <summary>
            Gets a value indicating whether this instance is empty.
            </summary>
            <value>
            <c>true</c> if this instance is empty; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IBinaryTree{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Left">
            <summary>
            Gets the left branch of this node.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IBinaryTree{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Right">
            <summary>
            Gets the right branch of this node.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.Height">
            <summary>
            Gets the height of the tree beneath this node.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.Left">
            <summary>
            Gets the left branch of this node.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IBinaryTree#Left">
            <summary>
            Gets the left branch of this node.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.Right">
            <summary>
            Gets the right branch of this node.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IBinaryTree#Right">
            <summary>
            Gets the right branch of this node.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.Value">
            <summary>
            Gets the value represented by the current node.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IBinaryTree#Count">
            <summary>
            Gets the number of elements contained by this node and below.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.Keys">
            <summary>
            Gets the keys.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.Values">
            <summary>
            Gets the values.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.System#Collections#Generic#IEnumerable{System#Collections#Generic#KeyValuePair{TKey,TValue}}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.GetEnumerator(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary{`0,`1}.Builder)">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <param name="builder">The builder, if applicable.</param>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32,System.Int32)">
            <summary>
            See <see cref="T:System.Collections.Generic.IDictionary`2"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.CopyTo(System.Array,System.Int32,System.Int32)">
            <summary>
            See <see cref="T:System.Collections.Generic.IDictionary`2"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.NodeTreeFromSortedDictionary(System.Collections.Generic.SortedDictionary{`0,`1})">
            <summary>
            Creates a node tree from an existing (mutable) collection.
            </summary>
            <param name="dictionary">The collection.</param>
            <returns>The root of the node tree.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.Add(`0,`1,System.Collections.Generic.IComparer{`0},System.Collections.Generic.IEqualityComparer{`1},System.Boolean@)">
            <summary>
            Adds the specified key.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
            <param name="keyComparer">The key comparer.</param>
            <param name="valueComparer">The value comparer.</param>
            <param name="mutated">Receives a value indicating whether this node tree has mutated because of this operation.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.SetItem(`0,`1,System.Collections.Generic.IComparer{`0},System.Collections.Generic.IEqualityComparer{`1},System.Boolean@,System.Boolean@)">
            <summary>
            Adds the specified key.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
            <param name="keyComparer">The key comparer.</param>
            <param name="valueComparer">The value comparer.</param>
            <param name="replacedExistingValue">Receives a value indicating whether an existing value was replaced.</param>
            <param name="mutated">Receives a value indicating whether this node tree has mutated because of this operation.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.Remove(`0,System.Collections.Generic.IComparer{`0},System.Boolean@)">
            <summary>
            Removes the specified key.
            </summary>
            <param name="key">The key.</param>
            <param name="keyComparer">The key comparer.</param>
            <param name="mutated">Receives a value indicating whether this node tree has mutated because of this operation.</param>
            <returns>The new AVL tree.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.GetValueOrDefault(`0,System.Collections.Generic.IComparer{`0})">
            <summary>
            Gets the value or default.
            </summary>
            <param name="key">The key.</param>
            <param name="keyComparer">The key comparer.</param>
            <returns>The value.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.TryGetValue(`0,System.Collections.Generic.IComparer{`0},`1@)">
            <summary>
            Tries to get the value.
            </summary>
            <param name="key">The key.</param>
            <param name="keyComparer">The key comparer.</param>
            <param name="value">The value.</param>
            <returns>True if the key was found.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.TryGetKey(`0,System.Collections.Generic.IComparer{`0},`0@)">
            <summary>
            Searches the dictionary for a given key and returns the equal key it finds, if any.
            </summary>
            <param name="equalKey">The key to search for.</param>
            <param name="keyComparer">The key comparer.</param>
            <param name="actualKey">The key from the dictionary that the search found, or <paramref name="equalKey"/> if the search yielded no match.</param>
            <returns>A value indicating whether the search was successful.</returns>
            <remarks>
            This can be useful when you want to reuse a previously stored reference instead of
            a newly constructed one (so that more sharing of references can occur) or to look up
            the canonical value, or a value that has more complete data than the value you currently have,
            although their comparer functions indicate they are equal.
            </remarks>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.ContainsKey(`0,System.Collections.Generic.IComparer{`0})">
            <summary>
            Determines whether the specified key contains key.
            </summary>
            <param name="key">The key.</param>
            <param name="keyComparer">The key comparer.</param>
            <returns>
            <c>true</c> if the specified key contains key; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.ContainsValue(`1,System.Collections.Generic.IEqualityComparer{`1})">
            <summary>
            Determines whether the ImmutableSortedMap&lt;TKey,TValue&gt;
            contains an element with the specified value.
            </summary>
            <param name="value">
            The value to locate in the ImmutableSortedMap&lt;TKey,TValue&gt;.
            The value can be null for reference types.
            </param>
            <param name="valueComparer">The value comparer to use.</param>
            <returns>
            true if the ImmutableSortedMap&lt;TKey,TValue&gt; contains
            an element with the specified value; otherwise, false.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.Contains(System.Collections.Generic.KeyValuePair{`0,`1},System.Collections.Generic.IComparer{`0},System.Collections.Generic.IEqualityComparer{`1})">
            <summary>
            Determines whether [contains] [the specified pair].
            </summary>
            <param name="pair">The pair.</param>
            <param name="keyComparer">The key comparer.</param>
            <param name="valueComparer">The value comparer.</param>
            <returns>
            <c>true</c> if [contains] [the specified pair]; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.Freeze(System.Action{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Freezes this node and all descendent nodes so that any mutations require a new instance of the nodes.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.RotateLeft(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary{`0,`1}.Node)">
            <summary>
            AVL rotate left operation.
            </summary>
            <param name="tree">The tree.</param>
            <returns>The rotated tree.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.RotateRight(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary{`0,`1}.Node)">
            <summary>
            AVL rotate right operation.
            </summary>
            <param name="tree">The tree.</param>
            <returns>The rotated tree.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.DoubleLeft(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary{`0,`1}.Node)">
            <summary>
            AVL rotate double-left operation.
            </summary>
            <param name="tree">The tree.</param>
            <returns>The rotated tree.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.DoubleRight(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary{`0,`1}.Node)">
            <summary>
            AVL rotate double-right operation.
            </summary>
            <param name="tree">The tree.</param>
            <returns>The rotated tree.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.Balance(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary{`0,`1}.Node)">
            <summary>
            Returns a value indicating whether the tree is in balance.
            </summary>
            <param name="tree">The tree.</param>
            <returns>0 if the tree is in balance, a positive integer if the right side is heavy, or a negative integer if the left side is heavy.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.IsRightHeavy(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary{`0,`1}.Node)">
            <summary>
            Determines whether the specified tree is right heavy.
            </summary>
            <param name="tree">The tree.</param>
            <returns>
            <c>true</c> if [is right heavy] [the specified tree]; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.IsLeftHeavy(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary{`0,`1}.Node)">
            <summary>
            Determines whether the specified tree is left heavy.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.MakeBalanced(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary{`0,`1}.Node)">
            <summary>
            Balances the specified tree.
            </summary>
            <param name="tree">The tree.</param>
            <returns>A balanced tree.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.NodeTreeFromList(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IOrderedCollection{System.Collections.Generic.KeyValuePair{`0,`1}},System.Int32,System.Int32)">
            <summary>
            Creates a node tree that contains the contents of a list.
            </summary>
            <param name="items">An indexable list with the contents that the new node tree should contain.</param>
            <param name="start">The starting index within <paramref name="items"/> that should be captured by the node tree.</param>
            <param name="length">The number of elements from <paramref name="items"/> that should be captured by the node tree.</param>
            <returns>The root of the created node tree.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.SetOrAdd(`0,`1,System.Collections.Generic.IComparer{`0},System.Collections.Generic.IEqualityComparer{`1},System.Boolean,System.Boolean@,System.Boolean@)">
            <summary>
            Adds the specified key. Callers are expected to have validated arguments.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
            <param name="keyComparer">The key comparer.</param>
            <param name="valueComparer">The value comparer.</param>
            <param name="overwriteExistingValue">if <c>true</c>, an existing key=value pair will be overwritten with the new one.</param>
            <param name="replacedExistingValue">Receives a value indicating whether an existing value was replaced.</param>
            <param name="mutated">Receives a value indicating whether this node tree has mutated because of this operation.</param>
            <returns>The new AVL tree.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.RemoveRecursive(`0,System.Collections.Generic.IComparer{`0},System.Boolean@)">
            <summary>
            Removes the specified key. Callers are expected to validate arguments.
            </summary>
            <param name="key">The key.</param>
            <param name="keyComparer">The key comparer.</param>
            <param name="mutated">Receives a value indicating whether this node tree has mutated because of this operation.</param>
            <returns>The new AVL tree.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.Mutate(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary{`0,`1}.Node,Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary{`0,`1}.Node)">
            <summary>
            Creates a node mutation, either by mutating this node (if not yet frozen) or by creating a clone of this node
            with the described changes.
            </summary>
            <param name="left">The left branch of the mutated node.</param>
            <param name="right">The right branch of the mutated node.</param>
            <returns>The mutated (or created) node.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node.Search(`0,System.Collections.Generic.IComparer{`0})">
            <summary>
            Searches the specified key. Callers are expected to validate arguments.
            </summary>
            <param name="key">The key.</param>
            <param name="keyComparer">The key comparer.</param>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionaryBuilderDebuggerProxy`2">
            <summary>
            A simple view of the immutable collection that the debugger can show to the developer.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionaryBuilderDebuggerProxy`2._map">
            <summary>
            The collection to be enumerated.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionaryBuilderDebuggerProxy`2._contents">
            <summary>
            The simple view of the collection.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionaryBuilderDebuggerProxy`2.#ctor(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary{`0,`1}.Builder)">
            <summary>   
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionaryBuilderDebuggerProxy`2"/> class.
            </summary>
            <param name="map">The collection to display in the debugger</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionaryBuilderDebuggerProxy`2.Contents">
            <summary>
            Gets a simple debugger-viewable collection.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionaryDebuggerProxy`2">
            <summary>
            A simple view of the immutable collection that the debugger can show to the developer.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionaryDebuggerProxy`2._map">
            <summary>
            The collection to be enumerated.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionaryDebuggerProxy`2._contents">
            <summary>
            The simple view of the collection.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionaryDebuggerProxy`2.#ctor(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary{`0,`1})">
            <summary>   
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionaryDebuggerProxy`2"/> class.
            </summary>
            <param name="map">The collection to display in the debugger</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionaryDebuggerProxy`2.Contents">
            <summary>
            Gets a simple debugger-viewable collection.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack">
            <summary>
            A set of initialization methods for instances of <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1"/>.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack.Create``1">
            <summary>
            Returns an empty collection.
            </summary>
            <typeparam name="T">The type of items stored by the collection.</typeparam>
            <returns>The immutable collection.</returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1">
            <summary>
            An immutable stack.
            </summary>
            <typeparam name="T">The type of element stored by the stack.</typeparam>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1.s_EmptyField">
            <summary>
            The singleton empty stack.
            </summary>
            <remarks>
            Additional instances representing the empty stack may exist on deserialized stacks.
            </remarks>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1._head">
            <summary>
            The element on the top of the stack.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1._tail">
            <summary>
            A stack that contains the rest of the elements (under the top element).
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1"/> class
            that acts as the empty stack.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1.#ctor(`0,Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1"/> class.
            </summary>
            <param name="head">The head element on the stack.</param>
            <param name="tail">The rest of the elements on the stack.</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1.Empty">
            <summary>
            Gets the empty stack, upon which all stacks are built.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1.Clear">
            <summary>
            Gets the empty stack, upon which all stacks are built.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableStack{T}#Clear">
            <summary>
            Gets an empty stack.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1.IsEmpty">
            <summary>
            Gets a value indicating whether this instance is empty.
            </summary>
            <value>
              <c>true</c> if this instance is empty; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1.Peek">
            <summary>
            Gets the element on the top of the stack.
            </summary>
            <returns>
            The element on the top of the stack. 
            </returns>
            <exception cref="T:System.InvalidOperationException">Thrown when the stack is empty.</exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1.Push(`0)">
            <summary>
            Pushes an element onto a stack and returns the new stack.
            </summary>
            <param name="value">The element to push onto the stack.</param>
            <returns>The new stack.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableStack{T}#Push(`0)">
            <summary>
            Pushes an element onto a stack and returns the new stack.
            </summary>
            <param name="value">The element to push onto the stack.</param>
            <returns>The new stack.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1.Pop">
            <summary>
            Returns a stack that lacks the top element on this stack.
            </summary>
            <returns>A stack; never <c>null</c></returns>
            <exception cref="T:System.InvalidOperationException">Thrown when the stack is empty.</exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1.Pop(`0@)">
            <summary>
            Pops the top element off the stack.
            </summary>
            <param name="value">The value that was removed from the stack.</param>
            <returns>
            A stack; never <c>null</c>
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IImmutableStack{T}#Pop">
            <summary>
            Returns a stack that lacks the top element on this stack.
            </summary>
            <returns>A stack; never <c>null</c></returns>
            <exception cref="T:System.InvalidOperationException">Thrown when the stack is empty.</exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            An <see cref="T:Enumerator"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1.Reverse">
            <summary>
            Reverses the order of a stack.
            </summary>
            <returns>The reversed stack.</returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1.Enumerator">
            <summary>
            Enumerates a stack with no memory allocations.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1.Enumerator._originalStack">
            <summary>
            The original stack being enumerated.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1.Enumerator._remainingStack">
            <summary>
            The remaining stack not yet enumerated.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1.Enumerator.#ctor(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1.Enumerator"/> struct.
            </summary>
            <param name="stack">The stack to enumerator.</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1.Enumerator.Current">
            <summary>
            Gets the current element.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1.Enumerator.MoveNext">
            <summary>
            Moves to the first or next element.
            </summary>
            <returns>A value indicating whether there are any more elements.</returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1.EnumeratorObject">
            <summary>
            Enumerates a stack with no memory allocations.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1.EnumeratorObject._originalStack">
            <summary>
            The original stack being enumerated.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1.EnumeratorObject._remainingStack">
            <summary>
            The remaining stack not yet enumerated.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1.EnumeratorObject._disposed">
            <summary>
            A flag indicating whether this enumerator has been disposed.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1.EnumeratorObject.#ctor(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1.EnumeratorObject"/> class.
            </summary>
            <param name="stack">The stack to enumerator.</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1.EnumeratorObject.Current">
            <summary>
            Gets the current element.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1.EnumeratorObject.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current element.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1.EnumeratorObject.MoveNext">
            <summary>
            Moves to the first or next element.
            </summary>
            <returns>A value indicating whether there are any more elements.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1.EnumeratorObject.Reset">
            <summary>
            Resets the position to just before the first element in the list.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1.EnumeratorObject.Dispose">
            <summary>
            Disposes this instance.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack`1.EnumeratorObject.ThrowIfDisposed">
            <summary>
            Throws an <see cref="T:System.ObjectDisposedException"/> if this 
            enumerator has already been disposed.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStackDebuggerProxy`1">
            <summary>
            A simple view of the immutable collection that the debugger can show to the developer.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStackDebuggerProxy`1._stack">
            <summary>
            The collection to be enumerated.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStackDebuggerProxy`1._contents">
            <summary>
            The simple view of the collection.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStackDebuggerProxy`1.#ctor(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStack{`0})">
            <summary>   
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStackDebuggerProxy`1"/> class.
            </summary>
            <param name="stack">The collection to display in the debugger</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableStackDebuggerProxy`1.Contents">
            <summary>
            Gets a simple debugger-viewable collection.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IOrderedCollection`1">
            <summary>
            Describes an ordered collection of elements.
            </summary>
            <typeparam name="T">The type of element in the collection.</typeparam>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IOrderedCollection`1.Count">
            <summary>
            Gets the number of elements in the collection.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IOrderedCollection`1.Item(System.Int32)">
            <summary>
            Gets the element in the collection at a given index.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IStrongEnumerable`2">
            <summary>
            An interface that must be implemented by collections that want to avoid
            boxing their own enumerators when using the 
            <see cref="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableExtensions.GetEnumerableDisposable``2(System.Collections.Generic.IEnumerable{``0})"/>
            method.
            </summary>
            <typeparam name="T">The type of value to be enumerated.</typeparam>
            <typeparam name="TEnumerator">The type of the enumerator struct.</typeparam>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IStrongEnumerable`2.GetEnumerator">
            <summary>
            Gets the strongly-typed enumerator.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IStrongEnumerator`1">
            <summary>
            An <see cref="T:System.Collections.Generic.IEnumerator`1"/>-like interface that does not derive from <see cref="T:System.IDisposable"/>.
            </summary>
            <typeparam name="T">The type of value to be enumerated.</typeparam>
            <remarks>
            This interface is useful because some enumerator struct types do not want to implement
            <see cref="T:System.IDisposable"/> since it increases the size of the generated code in foreach.
            </remarks>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IStrongEnumerator`1.Current">
            <summary>
            Returns the current element.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IStrongEnumerator`1.MoveNext">
            <summary>
            Advances to the next element.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.KeysOrValuesCollectionAccessor`3">
            <summary>
            A thin wrapper around the Keys or Values enumerators so they look like a collection.
            </summary>
            <typeparam name="TKey">The type of key in the dictionary.</typeparam>
            <typeparam name="TValue">The type of value in the dictionary.</typeparam>
            <typeparam name="T">Either TKey or TValue.</typeparam>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.KeysOrValuesCollectionAccessor`3._dictionary">
            <summary>
            The underlying wrapped dictionary.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.KeysOrValuesCollectionAccessor`3._keysOrValues">
            <summary>
            The key or value enumerable that this instance wraps.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.KeysOrValuesCollectionAccessor`3.#ctor(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary{`0,`1},System.Collections.Generic.IEnumerable{`2})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.KeysOrValuesCollectionAccessor`3"/> class.
            </summary>
            <param name="dictionary">The dictionary to base on.</param>
            <param name="keysOrValues">The keys or values enumeration to wrap as a collection.</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.KeysOrValuesCollectionAccessor`3.IsReadOnly">
            <summary>
            See <see cref="T:System.Collections.Generic.ICollection`1"/>
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.KeysOrValuesCollectionAccessor`3.Count">
            <summary>
            See <see cref="T:System.Collections.Generic.ICollection`1"/>
            </summary>
            <returns>The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.</returns>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.KeysOrValuesCollectionAccessor`3.Dictionary">
            <summary>
            Gets the wrapped dictionary.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.KeysOrValuesCollectionAccessor`3.Add(`2)">
            <summary>
            See <see cref="T:System.Collections.Generic.ICollection`1"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.KeysOrValuesCollectionAccessor`3.Clear">
            <summary>
            See <see cref="T:System.Collections.Generic.ICollection`1"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.KeysOrValuesCollectionAccessor`3.Contains(`2)">
            <summary>
            See <see cref="T:System.Collections.Generic.ICollection`1"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.KeysOrValuesCollectionAccessor`3.CopyTo(`2[],System.Int32)">
            <summary>
            See <see cref="T:System.Collections.Generic.ICollection`1"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.KeysOrValuesCollectionAccessor`3.Remove(`2)">
            <summary>
            See <see cref="T:System.Collections.Generic.ICollection`1"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.KeysOrValuesCollectionAccessor`3.GetEnumerator">
            <summary>
            See <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.KeysOrValuesCollectionAccessor`3.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            See <see cref="T:System.Collections.IEnumerable"/>
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.KeysOrValuesCollectionAccessor`3.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.ICollection" /> to an <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:System.Collections.ICollection" />. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
            <param name="arrayIndex">The zero-based index in <paramref name="array" /> at which copying begins.</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.KeysOrValuesCollectionAccessor`3.System#Collections#ICollection#IsSynchronized">
            <summary>
            Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread safe).
            </summary>
            <returns>true if access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread safe); otherwise, false.</returns>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.KeysOrValuesCollectionAccessor`3.System#Collections#ICollection#SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.
            </summary>
            <returns>An object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.</returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.KeysCollectionAccessor`2">
            <summary>
            A lightweight collection view over and IEnumerable of keys.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.KeysCollectionAccessor`2.#ctor(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary{`0,`1})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.KeysCollectionAccessor`2"/> class.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.KeysCollectionAccessor`2.Contains(`0)">
            <summary>
            See <see cref="T:System.Collections.Generic.ICollection`1"/>
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ValuesCollectionAccessor`2">
            <summary>
            A lightweight collection view over and IEnumerable of values.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ValuesCollectionAccessor`2.#ctor(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IImmutableDictionary{`0,`1})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ValuesCollectionAccessor`2"/> class.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ValuesCollectionAccessor`2.Contains(`1)">
            <summary>
            See <see cref="T:System.Collections.Generic.ICollection`1"/>
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.RefAsValueType`1">
            <summary>
            A simple struct we wrap reference types inside when storing in arrays to
            bypass the CLR's covariant checks when writing to arrays.
            </summary>
            <remarks>
            We use RefAsValueType{T} as a wrapper to avoid paying the cost of covariant checks whenever
            the underlying array that the Stack{T} class uses is written to. 
            We've recognized this as a perf win in ETL traces for these stack frames:
            clr!JIT_Stelem_Ref
              clr!ArrayStoreCheck
                clr!ObjIsInstanceOf
            </remarks>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.RefAsValueType`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.RefAsValueType`1"/> struct.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.RefAsValueType`1.Value">
            <summary>
            The value.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SecureObjectPool">
            <summary>
            Object pooling utilities.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SecureObjectPool.s_poolUserIdCounter">
            <summary>
            The ever-incrementing (and wrap-on-overflow) integer for owner id's.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SecureObjectPool.UnassignedId">
            <summary>
            The ID reserved for unassigned objects.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SecureObjectPool.NewId">
            <summary>
            Returns a new ID.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SecurePooledObject`1.Owner">
            <summary>
            Gets or sets the current owner of this recyclable object.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SecurePooledObject`1.Use``1(``0@)">
            <summary>
            Returns the recyclable value if it hasn't been reclaimed already.
            </summary>
            <typeparam name="TCaller">The type of renter of the object.</typeparam>
            <param name="caller">The renter of the object.</param>
            <returns>The rented object.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if <paramref name="caller"/> is no longer the renter of the value.</exception>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1">
            <summary>
            A node in the AVL tree storing key/value pairs with Int32 keys.
            </summary>
            <remarks>
            This is a trimmed down version of <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.ImmutableSortedDictionary`2.Node"/>
            with TKey fixed to be Int32.  This avoids multiple interface-based dispatches while examining
            each node in the tree during a lookup: an interface call to the comparer's Compare method,
            and then an interface call to Int32's IComparable's CompareTo method as part of
            the GenericComparer{Int32}'s Compare implementation.
            </remarks>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.EmptyNode">
            <summary>
            The default empty node.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1._key">
            <summary>
            The Int32 key associated with this node.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1._value">
            <summary>
            The value associated with this node.
            </summary>
            <remarks>
            Sadly, this field could be readonly but doing so breaks serialization due to bug: 
            http://connect.microsoft.com/VisualStudio/feedback/details/312970/weird-argumentexception-when-deserializing-field-in-typedreferences-cannot-be-static-or-init-only
            </remarks>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1._frozen">
            <summary>
            A value indicating whether this node has been frozen (made immutable).
            </summary>
            <remarks>
            Nodes must be frozen before ever being observed by a wrapping collection type
            to protect collections from further mutations.
            </remarks>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1._height">
            <summary>
            The depth of the tree beneath this node.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1._left">
            <summary>
            The left tree.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1._right">
            <summary>
            The right tree.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1"/> class that is pre-frozen.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.#ctor(System.Int32,`0,Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode{`0},Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode{`0},System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1"/> class that is not yet frozen.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <param name="frozen">Whether this node is prefrozen.</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.IsEmpty">
            <summary>
            Gets a value indicating whether this instance is empty.
            </summary>
            <value>
            <c>true</c> if this instance is empty; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.Height">
            <summary>
            Gets the height of the tree beneath this node.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.Left">
            <summary>
            Gets the left branch of this node.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.Right">
            <summary>
            Gets the right branch of this node.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IBinaryTree#Left">
            <summary>
            Gets the left branch of this node.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IBinaryTree#Right">
            <summary>
            Gets the right branch of this node.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#IBinaryTree#Count">
            <summary>
            Gets the number of elements contained by this node and below.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.Value">
            <summary>
            Gets the value represented by the current node.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.Values">
            <summary>
            Gets the values.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.SetItem(System.Int32,`0,System.Collections.Generic.IEqualityComparer{`0},System.Boolean@,System.Boolean@)">
            <summary>
            Adds the specified key.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
            <param name="valueComparer">The value comparer.</param>
            <param name="replacedExistingValue">Receives a value indicating whether an existing value was replaced.</param>
            <param name="mutated">Receives a value indicating whether this node tree has mutated because of this operation.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.Remove(System.Int32,System.Boolean@)">
            <summary>
            Removes the specified key.
            </summary>
            <param name="key">The key.</param>
            <param name="mutated">Receives a value indicating whether this node tree has mutated because of this operation.</param>
            <returns>The new AVL tree.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.GetValueOrDefault(System.Int32)">
            <summary>
            Gets the value or default.
            </summary>
            <param name="key">The key.</param>
            <returns>The value.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.TryGetValue(System.Int32,`0@)">
            <summary>
            Tries to get the value.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
            <returns>True if the key was found.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.Freeze(System.Action{System.Collections.Generic.KeyValuePair{System.Int32,`0}})">
            <summary>
            Freezes this node and all descendent nodes so that any mutations require a new instance of the nodes.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.RotateLeft(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode{`0})">
            <summary>
            AVL rotate left operation.
            </summary>
            <param name="tree">The tree.</param>
            <returns>The rotated tree.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.RotateRight(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode{`0})">
            <summary>
            AVL rotate right operation.
            </summary>
            <param name="tree">The tree.</param>
            <returns>The rotated tree.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.DoubleLeft(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode{`0})">
            <summary>
            AVL rotate double-left operation.
            </summary>
            <param name="tree">The tree.</param>
            <returns>The rotated tree.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.DoubleRight(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode{`0})">
            <summary>
            AVL rotate double-right operation.
            </summary>
            <param name="tree">The tree.</param>
            <returns>The rotated tree.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.Balance(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode{`0})">
            <summary>
            Returns a value indicating whether the tree is in balance.
            </summary>
            <param name="tree">The tree.</param>
            <returns>0 if the tree is in balance, a positive integer if the right side is heavy, or a negative integer if the left side is heavy.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.IsRightHeavy(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode{`0})">
            <summary>
            Determines whether the specified tree is right heavy.
            </summary>
            <param name="tree">The tree.</param>
            <returns>
            <c>true</c> if [is right heavy] [the specified tree]; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.IsLeftHeavy(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode{`0})">
            <summary>
            Determines whether the specified tree is left heavy.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.MakeBalanced(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode{`0})">
            <summary>
            Balances the specified tree.
            </summary>
            <param name="tree">The tree.</param>
            <returns>A balanced tree.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.NodeTreeFromList(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.IOrderedCollection{System.Collections.Generic.KeyValuePair{System.Int32,`0}},System.Int32,System.Int32)">
            <summary>
            Creates a node tree that contains the contents of a list.
            </summary>
            <param name="items">An indexable list with the contents that the new node tree should contain.</param>
            <param name="start">The starting index within <paramref name="items"/> that should be captured by the node tree.</param>
            <param name="length">The number of elements from <paramref name="items"/> that should be captured by the node tree.</param>
            <returns>The root of the created node tree.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.SetOrAdd(System.Int32,`0,System.Collections.Generic.IEqualityComparer{`0},System.Boolean,System.Boolean@,System.Boolean@)">
            <summary>
            Adds the specified key. Callers are expected to have validated arguments.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
            <param name="valueComparer">The value comparer.</param>
            <param name="overwriteExistingValue">if <c>true</c>, an existing key=value pair will be overwritten with the new one.</param>
            <param name="replacedExistingValue">Receives a value indicating whether an existing value was replaced.</param>
            <param name="mutated">Receives a value indicating whether this node tree has mutated because of this operation.</param>
            <returns>The new AVL tree.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.RemoveRecursive(System.Int32,System.Boolean@)">
            <summary>
            Removes the specified key. Callers are expected to validate arguments.
            </summary>
            <param name="key">The key.</param>
            <param name="mutated">Receives a value indicating whether this node tree has mutated because of this operation.</param>
            <returns>The new AVL tree.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.Mutate(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode{`0},Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode{`0})">
            <summary>
            Creates a node mutation, either by mutating this node (if not yet frozen) or by creating a clone of this node
            with the described changes.
            </summary>
            <param name="left">The left branch of the mutated node.</param>
            <param name="right">The right branch of the mutated node.</param>
            <returns>The mutated (or created) node.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.Search(System.Int32)">
            <summary>
            Searches the specified key. Callers are expected to validate arguments.
            </summary>
            <param name="key">The key.</param>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.Enumerator">
            <summary>
            Enumerates the contents of a binary tree.
            </summary>
            <remarks>
            This struct can and should be kept in exact sync with the other binary tree enumerators: 
            ImmutableList.Enumerator, ImmutableSortedMap.Enumerator, and ImmutableSortedSet.Enumerator.
            
            CAUTION: when this enumerator is actually used as a valuetype (not boxed) do NOT copy it by assigning to a second variable 
            or by passing it to another method.  When this enumerator is disposed of it returns a mutable reference type stack to a resource pool,
            and if the value type enumerator is copied (which can easily happen unintentionally if you pass the value around) there is a risk
            that a stack that has already been returned to the resource pool may still be in use by one of the enumerator copies, leading to data
            corruption and/or exceptions.
            </remarks>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.Enumerator.s_enumeratingStacks">
            <summary>
            The resource pool of reusable mutable stacks for purposes of enumeration.
            </summary>
            <remarks>
            We utilize this resource pool to make "allocation free" enumeration achievable.
            </remarks>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.Enumerator._poolUserId">
            <summary>
            A unique ID for this instance of this enumerator.
            Used to protect pooled objects from use after they are recycled.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.Enumerator._root">
            <summary>
            The set being enumerated.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.Enumerator._stack">
            <summary>
            The stack to use for enumerating the binary tree.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.Enumerator._current">
            <summary>
            The node currently selected.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.Enumerator.#ctor(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode{`0})">
            <summary>
            Initializes an Enumerator structure.
            </summary>
            <param name="root">The root of the set to be enumerated.</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.Enumerator.Current">
            <summary>
            The current element.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.Enumerator.Microsoft#PowerShell#Commands#StringManipulation#Collections#Immutable#ISecurePooledObjectUser#PoolUserId">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.Enumerator.System#Collections#IEnumerator#Current">
            <summary>
            The current element.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.Enumerator.Dispose">
            <summary>
            Disposes of this enumerator and returns the stack reference to the resource pool.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.Enumerator.MoveNext">
            <summary>
            Advances enumeration to the next element.
            </summary>
            <returns>A value indicating whether there is another element in the enumeration.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.Enumerator.Reset">
            <summary>
            Restarts enumeration.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.Enumerator.ThrowIfDisposed">
            <summary>
            Throws an ObjectDisposedException if this enumerator has been disposed.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode`1.Enumerator.PushLeft(Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.SortedInt32KeyNode{`0})">
            <summary>
            Pushes this node and all its Left descendents onto the stack.
            </summary>
            <param name="node">The starting node to push onto the stack.</param>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.Validation.Requires">
            <summary>
            Common runtime checks that throw ArgumentExceptions upon failure.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.Validation.Requires.NotNull``1(``0,System.String)">
            <summary>
            Throws an exception if the specified parameter's value is null.
            </summary>
            <typeparam name="T">The type of the parameter.</typeparam>
            <param name="value">The value of the argument.</param>
            <param name="parameterName">The name of the parameter to include in any thrown exception.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="value"/> is <c>null</c></exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.Validation.Requires.NotNullPassthrough``1(``0,System.String)">
            <summary>
            Throws an exception if the specified parameter's value is null.  It passes through the specified value back as a return value.
            </summary>
            <typeparam name="T">The type of the parameter.</typeparam>
            <param name="value">The value of the argument.</param>
            <param name="parameterName">The name of the parameter to include in any thrown exception.</param>
            <returns>The value of the parameter.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="value"/> is <c>null</c></exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.Validation.Requires.NotNullAllowStructs``1(``0,System.String)">
            <summary>
            Throws an exception if the specified parameter's value is null.
            </summary>
            <typeparam name="T">The type of the parameter.</typeparam>
            <param name="value">The value of the argument.</param>
            <param name="parameterName">The name of the parameter to include in any thrown exception.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="value"/> is <c>null</c></exception>
            <remarks>
            This method exists for callers who themselves only know the type as a generic parameter which
            may or may not be a class, but certainly cannot be null.
            </remarks>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.Validation.Requires.FailArgumentNullException(System.String)">
            <summary>
            Throws an <see cref="T:System.ArgumentNullException"/>.
            </summary>
            <param name="parameterName">The name of the parameter that was null.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.Validation.Requires.Range(System.Boolean,System.String,System.String)">
            <summary>
            Throws an <see cref="T:System.ArgumentOutOfRangeException"/> if a condition does not evaluate to true.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.Validation.Requires.FailRange(System.String,System.String)">
            <summary>
            Throws an <see cref="T:System.ArgumentOutOfRangeException"/>.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.Validation.Requires.Argument(System.Boolean)">
            <summary>
            Throws an ArgumentException if a condition does not evaluate to true.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.Validation.Requires.FailObjectDisposed``1(``0)">
            <summary>
            Throws an ObjectDisposedException for a disposed object.
            </summary>
            <typeparam name="TDisposed">Specifies the type of the disposed object.</typeparam>
            <param name="disposed">The disposed object.</param>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StringManipulation.Collections.Immutable.Validation.ValidatedNotNullAttribute">
            <summary>
            Indicates to Code Analysis that a method validates a particular parameter.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.PSUtilityPSSnapIn">
            <summary>
            
            MshUtilityMshSnapin (or MshUtilityMshSnapinInstaller) is a class for facilitating registry 
            of necessary information for monad utility mshsnapin. 
            
            This class will be built with monad utility dll 
            
            </summary>
            
        </member>
        <member name="M:Microsoft.PowerShell.PSUtilityPSSnapIn.#ctor">
            <summary>
            Create an instance of this class. 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.PSUtilityPSSnapIn.Name">
            <summary>
            Get name of this mshsnapin.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.PSUtilityPSSnapIn.Vendor">
            <summary>
            Get the default vendor string for this mshsnapin. 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.PSUtilityPSSnapIn.VendorResource">
            <summary>
            Get resource information for vendor. This is a string of format: resourceBaseName,resourceName. 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.PSUtilityPSSnapIn.Description">
            <summary>
            Get the default description string for this mshsnapin. 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.PSUtilityPSSnapIn.DescriptionResource">
            <summary>
            Get resource information for description. This is a string of format: resourceBaseName,resourceName. 
            </summary>
        </member>
        <member name="T:System.Management.Automation.CustomSerialization">
            <summary>
            This class provides functionality for serializing a PSObject
            </summary>
        </member>
        <member name="F:System.Management.Automation.CustomSerialization._depth">
            <summary>
            depth of serialization
            </summary>
        </member>
        <member name="F:System.Management.Automation.CustomSerialization._writer">
            <summary>
            XmlWriter to be used for writing.
            </summary>
        </member>
        <member name="F:System.Management.Automation.CustomSerialization._notypeinformation">
            <summary>
            Whether type information should be included in the xml
            </summary>
        </member>
        <member name="F:System.Management.Automation.CustomSerialization._serializer">
            <summary>
            CustomerSerializer used for formatting the output for _writer
            </summary>
        </member>
        <member name="M:System.Management.Automation.CustomSerialization.#ctor(System.Xml.XmlWriter,System.Boolean,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="writer">
            writer to be used for serialization.
            </param>
            <param name="notypeinformation">
            should the type information to be shown.
            </param>
            <param name="depth">
            depth to be used for serialization. If this value is specified, 
            depth from types.xml is not used.
            </param>
        </member>
        <member name="F:System.Management.Automation.CustomSerialization.mshDefaultSerializationDepth">
            <summary>
            Default depth of serialization
            </summary>
        </member>
        <member name="P:System.Management.Automation.CustomSerialization.MshDefaultSerializationDepth">
            <summary>
            Default depth of serializaiton
            </summary>
        </member>
        <member name="M:System.Management.Automation.CustomSerialization.#ctor(System.Xml.XmlWriter,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="writer">
            writer to be used for serialization.
            </param>
            <param name="notypeinformation">
            should the type information to be shown.
            </param>
        </member>
        <member name="M:System.Management.Automation.CustomSerialization.Serialize(System.Object)">
            <summary>
            Serialzies passed in object
            </summary>
            <param name="source">
            object to be serialized
            </param>
        </member>
        <member name="M:System.Management.Automation.CustomSerialization.SerializeAsStream(System.Object)">
            <summary>
            Serialzies passed in object
            </summary>
            <param name="source">
            object to be serialized
            </param>
        </member>
        <member name="M:System.Management.Automation.CustomSerialization.Start">
            <summary>
            Writes the start of root element 
            </summary>
        </member>
        <member name="M:System.Management.Automation.CustomSerialization.Done">
            <summary>
            Write the end of root element
            </summary>
        </member>
        <member name="M:System.Management.Automation.CustomSerialization.DoneAsStream">
            <summary>
            Flush the writer
            </summary>
        </member>
        <member name="T:System.Management.Automation.CustomInternalSerializer">
            <summary>
            This internal helper class provides methods for serializing mshObject.
            </summary>
        </member>
        <member name="F:System.Management.Automation.CustomInternalSerializer._writer">
            <summary>
            Xml writer to be used
            </summary>
        </member>
        <member name="F:System.Management.Automation.CustomInternalSerializer.firstcall">
            <summary>
            check first call for every pipeline object to write Object tag else property tag
            </summary>
        </member>
        <member name="F:System.Management.Automation.CustomInternalSerializer._notypeinformation">
            <summary>
            should the type information to be shown
            </summary>
        </member>
        <member name="F:System.Management.Automation.CustomInternalSerializer.firstobjectcall">
            <summary>
            check object call
            </summary>
        </member>
        <member name="M:System.Management.Automation.CustomInternalSerializer.#ctor(System.Xml.XmlWriter,System.Boolean,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="writer">
            Xml writer to be used
            </param>
            <param name="notypeinformation">
            Xml writer to be used
            </param>
            <param name="isfirstcallforObject">
            check first call for every pipeline object to write Object tag else property tag
            </param>
        </member>
        <member name="M:System.Management.Automation.CustomInternalSerializer.Stop">
            <summary>
            Called from a separate thread will stop the serialization process
            </summary>
        </member>
        <member name="M:System.Management.Automation.CustomInternalSerializer.WriteOneObject(System.Object,System.String,System.Int32)">
            <summary>
            This writes one object.
            </summary>
            <param name="source">
            source to be serialized.
            </param>
            <param name="property">
            name of property. If null, name attribute is not written.
            </param>
            <param name="depth">
            depth to which this object should be serialized.
            </param>
        </member>
        <member name="M:System.Management.Automation.CustomInternalSerializer.HandlePrimitiveKnownType(System.Object,System.String)">
            <summary>
            Serializes Primitive Known Types.
            </summary>
            <returns>
            true if source is handled, else false.
            </returns>
        </member>
        <member name="M:System.Management.Automation.CustomInternalSerializer.HandlePrimitiveKnownTypePSObject(System.Object,System.String,System.Int32)">
            <summary>
            Serializes PSObject whose base objects are of primitive known type
            </summary>
            <param name="source"></param>
            <param name="property"></param>
            <param name="depth"></param>
            <returns>
            true if source is handled, else false.
            </returns>
        </member>
        <member name="M:System.Management.Automation.CustomInternalSerializer.GetKnownContainerTypeInfo(System.Object,System.Management.Automation.ContainerType@,System.Collections.IDictionary@,System.Collections.IEnumerable@)">
            <summary>
            Checks if source is known container type and returns appropriate 
            information
            </summary>
            <param name="source"></param>
            <param name="ct"></param>
            <param name="dictionary"></param>
            <param name="enumerable"></param>
        </member>
        <member name="M:System.Management.Automation.CustomInternalSerializer.DerivesFromGenericType(System.Type,System.Type)">
            <summary>
            Checks if derived is of type baseType or a type derived from baseType
            </summary>
            <param name="derived"></param>
            <param name="baseType"></param>
            <returns></returns>
        </member>
        <member name="M:System.Management.Automation.CustomInternalSerializer.WritePrimitiveTypePSObjectWithNotes(System.Management.Automation.PSObject,System.Object,System.Management.Automation.TypeSerializationInfo,System.String,System.Int32)">
            <summary>
            Serializes an PSObject whose baseobject is of primitive type
            and which has notes.
            </summary>
            <param name="source">
            source from which notes are written
            </param>
            <param name="primitive">
            primitive object which is written as base object. In most cases it
            is same source.ImmediateBaseObject. When PSObject is serialized as string,
            it can be different. <see cref="M:System.Management.Automation.CustomInternalSerializer.HandlePSObjectAsString(System.Management.Automation.PSObject,System.String,System.Int32)"/> for more info.
            </param>
            <param name="pktInfo">
            TypeSerializationInfo for the primitive. 
            </param>
            <param name="property"></param>
            <param name="depth"></param>
        </member>
        <member name="M:System.Management.Automation.CustomInternalSerializer.WriteStartOfPSObject(System.Management.Automation.PSObject,System.String,System.Boolean)">
            <summary>
            Writes start element, attributes and typeNames for PSObject.
            </summary>
            <param name="mshObject"></param>
            <param name="property"></param>
            <param name="writeTNH">
            if true, TypeName information is written, else not.
            </param>
        </member>
        <member name="M:System.Management.Automation.CustomInternalSerializer.PSObjectHasNotes(System.Management.Automation.PSObject)">
            <summary>
            Returns true if PSObject has notes. 
            </summary>
            <param name="source"></param>
            <returns>
            </returns>
        </member>
        <member name="M:System.Management.Automation.CustomInternalSerializer.WriteMemberInfoCollection(System.Management.Automation.PSMemberInfoCollection{System.Management.Automation.PSMemberInfo},System.Int32,System.Boolean)">
            <summary>
            Serialize member set. This method serializes without writing 
            enclosing tags and attributes.
            </summary>
            <param name="me">
            enumerable containing members
            </param>
            <param name="depth"></param>
            <param name="writeEnclosingMemberSetElementTag">
            if this is true, write an enclosing "<memberset></memberset>" tag.
            </param>
            <returns></returns>
        </member>
        <member name="M:System.Management.Automation.CustomInternalSerializer.WritePSObjectProperties(System.Management.Automation.PSObject,System.Int32)">
            <summary>
            Serializes properties of PSObject
            </summary>
        </member>
        <member name="M:System.Management.Automation.CustomInternalSerializer.SerializeProperties(System.Management.Automation.PSMemberInfoInternalCollection{System.Management.Automation.PSPropertyInfo},System.String,System.Int32)">
            <summary>
            Serializes properties from collection
            </summary>
            <param name="propertyCollection">
            Collection of properties to serialize
            </param>
            <param name="name">
            Name for enclosing element tag
            </param>
            <param name="depth">
            depth to which each property should be 
            serialized
            </param>
        </member>
        <member name="M:System.Management.Automation.CustomInternalSerializer.WriteEnumerable(System.Collections.IEnumerable,System.Int32)">
            <summary>
            Serializes IEnumerable
            </summary>
            <param name="enumerable">
            enumerable which is serialized
            </param>
            <param name="depth"></param>
        </member>
        <member name="M:System.Management.Automation.CustomInternalSerializer.WriteDictionary(System.Collections.IDictionary,System.Int32)">
            <summary>
            Serializes IDictionary
            </summary>
            <param name="dictionary">dictionary which is serialized</param>
            <param name="depth"></param>
        </member>
        <member name="M:System.Management.Automation.CustomInternalSerializer.GetStringFromPSObject(System.Management.Automation.PSObject)">
            <summary>
            Gets the string from PSObject using the information from
            types.ps1xml. This string is used for serializing the PSObject.
            </summary>
            
            <param name="source">
            PSObject to be converted to string
            </param>
            
            <returns>
            string value to use for serializing this PSObject.
            </returns>
        </member>
        <member name="M:System.Management.Automation.CustomInternalSerializer.SerializeAsString(System.Management.Automation.PSObject)">
            <summary>
            Reads the information the PSObject
            and returns true if this object should be serialized as
            string
            </summary>
            <param name="source">PSObject to be serialized</param>
            <returns>true if the object needs to be serialized as a string</returns>
        </member>
        <member name="M:System.Management.Automation.CustomInternalSerializer.GetDepthOfSerialization(System.Management.Automation.PSObject,System.Int32)">
            <summary>
            compute the serialization depth for an PSObject instance subtree
            </summary>
            <param name="source">PSObject whose serialization depth has to be computed</param>
            <param name="depth">current depth</param>
            <returns></returns>
        </member>
        <member name="M:System.Management.Automation.CustomInternalSerializer.WriteNull(System.String)">
            <summary>
            Writes null
            </summary>
            <param name="property"></param>
        </member>
        <member name="M:System.Management.Automation.CustomInternalSerializer.WriteOnePrimitiveKnownType(System.Xml.XmlWriter,System.String,System.Object,System.Management.Automation.TypeSerializationInfo)">
            <summary>
            Writes an item or property in Monad namespace
            </summary>
            <param name="writer">The XmlWriter stream to which the object is serialized.</param>
            <param name="property">name of property. Pass null for item</param>
            <param name="source">object to be written</param>
            <param name="entry">serialization information about source</param>
        </member>
        <member name="M:System.Management.Automation.CustomInternalSerializer.WriteStartElement(System.Xml.XmlWriter,System.String)">
            <summary>
            Writes start element in Monad namespace
            </summary>
            <param name="writer"></param>
            <param name="elementTag">tag of element</param>
        </member>
        <member name="M:System.Management.Automation.CustomInternalSerializer.WriteAttribute(System.Xml.XmlWriter,System.String,System.String)">
            <summary>
            Writes attribute in monad namespace
            </summary>
            <param name="writer"></param>
            <param name="name">name of attribute</param>
            <param name="value">value of attribute</param>
        </member>
        <member name="T:System.Management.Automation.CustomSerializationStrings">
            <summary>
            This class contains strings required for serialization for Convertto-XML
            </summary> 
        </member>
        <member name="F:System.Management.Automation.CustomSerializationStrings.RootElementTag">
            <summary>
            Element tag for root node
            </summary>
        </member>
        <member name="F:System.Management.Automation.CustomSerializationStrings.PSObjectTag">
            <summary>
            Element tag for PSObject
            </summary>
        </member>
        <member name="F:System.Management.Automation.CustomSerializationStrings.Properties">
            <summary>
            Element tag for properties
            </summary>
        </member>
        <member name="F:System.Management.Automation.CustomSerializationStrings.NameAttribute">
            <summary>
            String for name attribute
            </summary>
        </member>
        <member name="F:System.Management.Automation.CustomSerializationStrings.TypeAttribute">
            <summary>
            String for type attribute
            </summary>
        </member>
        <member name="F:System.Management.Automation.CustomSerializationStrings.DictionaryKey">
            <summary>
            Value of name attribute for dictionary key part in dictnary entry
            </summary>
        </member>
        <member name="F:System.Management.Automation.CustomSerializationStrings.DictionaryValue">
            <summary>
            Value of name attribute for dictionary value part in dictnary entry
            </summary>
        </member>
        <member name="T:CsvCommandStrings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:CsvCommandStrings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:CsvCommandStrings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:CsvCommandStrings.CannotAppendCsvWithMismatchedPropertyNames">
            <summary>
              Looks up a localized string similar to Cannot append CSV content to the following file: {1}. The appended object does not have a property that corresponds to the following column: {0}. To continue with mismatched properties, add the -Force parameter, and then retry the command..
            </summary>
        </member>
        <member name="P:CsvCommandStrings.CannotSpecifyPathAndLiteralPath">
            <summary>
              Looks up a localized string similar to You must specify either the -Path or -LiteralPath parameters, but not both..
            </summary>
        </member>
        <member name="P:CsvCommandStrings.UseDefaultNameForUnspecifiedHeader">
            <summary>
              Looks up a localized string similar to One or more headers were not specified. Default names starting with &quot;H&quot; have been used in place of any missing headers..
            </summary>
        </member>
        <member name="T:Debugger">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Debugger.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Debugger.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Debugger.BreakpointIdNotFound">
            <summary>
              Looks up a localized string similar to There is no breakpoint with ID &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Debugger.CannotSetBreakpointInconsistentLanguageMode">
            <summary>
              Looks up a localized string similar to Cannot set breakpoint. The language mode for this session is incompatible with the system-wide language mode..
            </summary>
        </member>
        <member name="P:Debugger.DebugBreakMessage">
            <summary>
              Looks up a localized string similar to Wait-Debugger called on line {0} in {1}..
            </summary>
        </member>
        <member name="P:Debugger.FileDoesNotExist">
            <summary>
              Looks up a localized string similar to File &apos;{0}&apos; does not exist..
            </summary>
        </member>
        <member name="P:Debugger.LineLessThanOne">
            <summary>
              Looks up a localized string similar to Line cannot be less than 1..
            </summary>
        </member>
        <member name="P:Debugger.PersistDebugPreferenceFailure">
            <summary>
              Looks up a localized string similar to Failed to persist debug options for Process {0}..
            </summary>
        </member>
        <member name="P:Debugger.RemoteDebuggerNotSupported">
            <summary>
              Looks up a localized string similar to Debugging is not supported on remote sessions..
            </summary>
        </member>
        <member name="P:Debugger.RemoteDebuggerNotSupportedInHost">
            <summary>
              Looks up a localized string similar to Breakpoints cannot be set in the remote session because remote debugging is not supported by the current host..
            </summary>
        </member>
        <member name="P:Debugger.RunspaceDebuggingCannotDebugDefaultRunspace">
            <summary>
              Looks up a localized string similar to You cannot debug the default host Runspace using this cmdlet. To debug the default Runspace use the normal debugging commands from the host..
            </summary>
        </member>
        <member name="P:Debugger.RunspaceDebuggingEndSession">
            <summary>
              Looks up a localized string similar to To end the debugging session type the &apos;Detach&apos; command at the debugger prompt, or type &apos;Ctrl+C&apos; otherwise..
            </summary>
        </member>
        <member name="P:Debugger.RunspaceDebuggingNoHost">
            <summary>
              Looks up a localized string similar to Cannot debug Runspace. There is no host or host UI. The debugger requires a host and host UI for debugging..
            </summary>
        </member>
        <member name="P:Debugger.RunspaceDebuggingNoHostRunspaceOrDebugger">
            <summary>
              Looks up a localized string similar to Cannot debug Runspace. The host has no debugger. Try debugging the Runspace inside the Windows PowerShell console or the Windows PowerShell ISE, both of which have built-in debuggers..
            </summary>
        </member>
        <member name="P:Debugger.RunspaceDebuggingNoRunspaceFound">
            <summary>
              Looks up a localized string similar to No Runspace was found..
            </summary>
        </member>
        <member name="P:Debugger.RunspaceDebuggingScriptCompleted">
            <summary>
              Looks up a localized string similar to Command or script completed..
            </summary>
        </member>
        <member name="P:Debugger.RunspaceDebuggingStarted">
            <summary>
              Looks up a localized string similar to Debugging Runspace: {0}.
            </summary>
        </member>
        <member name="P:Debugger.RunspaceDebuggingTooManyRunspacesFound">
            <summary>
              Looks up a localized string similar to More than one Runspace was found. Only one Runspace can be debugged at a time..
            </summary>
        </member>
        <member name="P:Debugger.RunspaceOptionInvalidRunspaceState">
            <summary>
              Looks up a localized string similar to Cannot set debug options on Runspace {0} because it is not in the Opened state..
            </summary>
        </member>
        <member name="P:Debugger.RunspaceOptionNoDebugger">
            <summary>
              Looks up a localized string similar to No debugger was found for Runspace {0}..
            </summary>
        </member>
        <member name="P:Debugger.WrongExtension">
            <summary>
              Looks up a localized string similar to Cannot set breakpoint on file &apos;{0}&apos;; only *.ps1 and *.psm1 files are valid..
            </summary>
        </member>
        <member name="T:EventingStrings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:EventingStrings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:EventingStrings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:EventingStrings.ActionMandatoryForLocal">
            <summary>
              Looks up a localized string similar to Action must be specified for non-forwarded events..
            </summary>
        </member>
        <member name="P:EventingStrings.EventIdentifierNotFound">
            <summary>
              Looks up a localized string similar to Event with identifier &apos;{0}&apos; does not exist..
            </summary>
        </member>
        <member name="P:EventingStrings.EventResource">
            <summary>
              Looks up a localized string similar to Event &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:EventingStrings.EventSubscription">
            <summary>
              Looks up a localized string similar to Event subscription &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:EventingStrings.EventSubscriptionNotFound">
            <summary>
              Looks up a localized string similar to Event subscription with identifier &apos;{0}&apos; does not exist..
            </summary>
        </member>
        <member name="P:EventingStrings.EventSubscriptionSourceNotFound">
            <summary>
              Looks up a localized string similar to Event subscription with source identifier &apos;{0}&apos; does not exist..
            </summary>
        </member>
        <member name="P:EventingStrings.Remove">
            <summary>
              Looks up a localized string similar to Remove.
            </summary>
        </member>
        <member name="P:EventingStrings.SourceIdentifierNotFound">
            <summary>
              Looks up a localized string similar to Event with source identifier &apos;{0}&apos; does not exist..
            </summary>
        </member>
        <member name="P:EventingStrings.Unsubscribe">
            <summary>
              Looks up a localized string similar to Unsubscribe.
            </summary>
        </member>
        <member name="T:NewObjectStrings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:NewObjectStrings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:NewObjectStrings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:NewObjectStrings.ApartmentNotSupported">
            <summary>
              Looks up a localized string similar to {0} Please note that Single-Threaded Apartment is not supported in PowerShell Core..
            </summary>
        </member>
        <member name="P:NewObjectStrings.CannotCreateTypeConstrainedLanguage">
            <summary>
              Looks up a localized string similar to Cannot create type. Only core types are supported in this language mode..
            </summary>
        </member>
        <member name="P:NewObjectStrings.CannotFindAppropriateCtor">
            <summary>
              Looks up a localized string similar to A constructor was not found. Cannot find an appropriate constructor for type {0}..
            </summary>
        </member>
        <member name="P:NewObjectStrings.CannotInstantiateWinRTType">
            <summary>
              Looks up a localized string similar to Creating instances of attribute and delegated Windows RT types is not supported..
            </summary>
        </member>
        <member name="P:NewObjectStrings.CannotLoadComObjectType">
            <summary>
              Looks up a localized string similar to Cannot load COM type {0}..
            </summary>
        </member>
        <member name="P:NewObjectStrings.ComInteropLoaded">
            <summary>
              Looks up a localized string similar to The object written to the pipeline is an instance of the type &quot;{0}&quot; from the component&apos;s primary interoperability assembly. If this type exposes different members than the IDispatch members, scripts that are written to work with this object might not work if the primary interoperability assembly is not installed..
            </summary>
        </member>
        <member name="P:NewObjectStrings.InvalidValue">
            <summary>
              Looks up a localized string similar to The value supplied is not valid, or the property is read-only. Change the value, and then try again..
            </summary>
        </member>
        <member name="P:NewObjectStrings.MemberNotFound">
            <summary>
              Looks up a localized string similar to The member &quot;{1}&quot; was not found for the specified {2} object..
            </summary>
        </member>
        <member name="P:NewObjectStrings.TypeNotFound">
            <summary>
              Looks up a localized string similar to Cannot find type [{0}]: verify that the assembly containing this type is loaded..
            </summary>
        </member>
        <member name="T:MeasureObjectStrings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:MeasureObjectStrings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:MeasureObjectStrings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:MeasureObjectStrings.NonNumericInputObject">
            <summary>
              Looks up a localized string similar to Input object &quot;{0}&quot; is not numeric..
            </summary>
        </member>
        <member name="P:MeasureObjectStrings.NonNumericProperty">
            <summary>
              Looks up a localized string similar to Property &quot;{0}&quot; is not numeric..
            </summary>
        </member>
        <member name="P:MeasureObjectStrings.PropertyNotFound">
            <summary>
              Looks up a localized string similar to The property &quot;{0}&quot; cannot be found in the input for any objects..
            </summary>
        </member>
        <member name="T:MatchStringStrings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:MatchStringStrings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:MatchStringStrings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:MatchStringStrings.FileOpenError">
            <summary>
              Looks up a localized string similar to Cannot open the file because the current provider ({0}) cannot open files..
            </summary>
        </member>
        <member name="P:MatchStringStrings.FileReadError">
            <summary>
              Looks up a localized string similar to The file {0} cannot be read: {1}.
            </summary>
        </member>
        <member name="P:MatchStringStrings.FilterContextWarning">
            <summary>
              Looks up a localized string similar to The option &quot;Context&quot; is not valid when searching results that are piped from Select-String output..
            </summary>
        </member>
        <member name="P:MatchStringStrings.InvalidRegex">
            <summary>
              Looks up a localized string similar to The string {0} is not a valid regular expression: {1}.
            </summary>
        </member>
        <member name="T:SelectObjectStrings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:SelectObjectStrings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:SelectObjectStrings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:SelectObjectStrings.AlreadyExistingProperty">
            <summary>
              Looks up a localized string similar to The property cannot be processed because the property &quot;{0}&quot; already exists..
            </summary>
        </member>
        <member name="P:SelectObjectStrings.EmptyScriptBlockAndNoName">
            <summary>
              Looks up a localized string similar to A property is an empty script block and does not provide a name..
            </summary>
        </member>
        <member name="P:SelectObjectStrings.MutlipleExpandProperties">
            <summary>
              Looks up a localized string similar to Multiple properties cannot be expanded..
            </summary>
        </member>
        <member name="P:SelectObjectStrings.PropertyNotFound">
            <summary>
              Looks up a localized string similar to Property &quot;{0}&quot; cannot be found..
            </summary>
        </member>
        <member name="P:SelectObjectStrings.RenamingMultipleResults">
            <summary>
              Looks up a localized string similar to Cannot rename multiple results..
            </summary>
        </member>
        <member name="T:SortObjectStrings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:SortObjectStrings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:SortObjectStrings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:SortObjectStrings.PropertyNotFound">
            <summary>
              Looks up a localized string similar to &quot;Sort-Object&quot; - &quot;{0}&quot; cannot be found in &quot;InputObject&quot;..
            </summary>
        </member>
        <member name="T:WriteErrorStrings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:WriteErrorStrings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:WriteErrorStrings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:WriteErrorStrings.WriteErrorException">
            <summary>
              Looks up a localized string similar to &quot;The Write-Error cmdlet reported an error.&quot;.
            </summary>
        </member>
        <member name="T:VariableCommandStrings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:VariableCommandStrings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:VariableCommandStrings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:VariableCommandStrings.AddVariableAction">
            <summary>
              Looks up a localized string similar to Add variable.
            </summary>
        </member>
        <member name="P:VariableCommandStrings.AddVariableTarget">
            <summary>
              Looks up a localized string similar to Name: {0}.
            </summary>
        </member>
        <member name="P:VariableCommandStrings.ClearVariableAction">
            <summary>
              Looks up a localized string similar to Clear variable.
            </summary>
        </member>
        <member name="P:VariableCommandStrings.ClearVariableTarget">
            <summary>
              Looks up a localized string similar to Name: {0}.
            </summary>
        </member>
        <member name="P:VariableCommandStrings.NewVariableAction">
            <summary>
              Looks up a localized string similar to New variable.
            </summary>
        </member>
        <member name="P:VariableCommandStrings.NewVariableTarget">
            <summary>
              Looks up a localized string similar to Name: {0} Value: {1}.
            </summary>
        </member>
        <member name="P:VariableCommandStrings.RemoveVariableAction">
            <summary>
              Looks up a localized string similar to Remove variable.
            </summary>
        </member>
        <member name="P:VariableCommandStrings.RemoveVariableTarget">
            <summary>
              Looks up a localized string similar to Name: {0}.
            </summary>
        </member>
        <member name="P:VariableCommandStrings.SetVariableAction">
            <summary>
              Looks up a localized string similar to Set variable.
            </summary>
        </member>
        <member name="P:VariableCommandStrings.SetVariableTarget">
            <summary>
              Looks up a localized string similar to Name: {0} Value: {1}.
            </summary>
        </member>
        <member name="T:GetMember">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:GetMember.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:GetMember.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:GetMember.NoObjectSpecified">
            <summary>
              Looks up a localized string similar to You must specify an object for the Get-Member cmdlet..
            </summary>
        </member>
        <member name="T:GetRandomCommandStrings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:GetRandomCommandStrings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:GetRandomCommandStrings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:GetRandomCommandStrings.MaxMustBeGreaterThanZeroApi">
            <summary>
              Looks up a localized string similar to &apos;maxValue&apos; must be greater than zero..
            </summary>
        </member>
        <member name="P:GetRandomCommandStrings.MinGreaterThanOrEqualMax">
            <summary>
              Looks up a localized string similar to The Minimum value ({0}) cannot be greater than or equal to the Maximum value ({1})..
            </summary>
        </member>
        <member name="P:GetRandomCommandStrings.MinGreaterThanOrEqualMaxApi">
            <summary>
              Looks up a localized string similar to &apos;minValue&apos; cannot be greater than maxValue..
            </summary>
        </member>
        <member name="T:UtilityCommonStrings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:UtilityCommonStrings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:UtilityCommonStrings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:UtilityCommonStrings.AlgorithmTypeNotSupported">
            <summary>
              Looks up a localized string similar to Algorithm &apos;{0}&apos; is not supported in this system..
            </summary>
        </member>
        <member name="P:UtilityCommonStrings.CouldNotParseAsPowerShellDataFile">
            <summary>
              Looks up a localized string similar to The file &apos;{0}&apos; could not be parsed as a PowerShell Data File..
            </summary>
        </member>
        <member name="P:UtilityCommonStrings.EmptyCSSUri">
            <summary>
              Looks up a localized string similar to This command cannot be run because &apos;{0}&apos; is empty or blank. Please specify CSSUri and then run the command..
            </summary>
        </member>
        <member name="P:UtilityCommonStrings.FileNotFound">
            <summary>
              Looks up a localized string similar to This command cannot be run because the file path &apos;{0}&apos; is not valid. Please provide a valid file path and then run the command..
            </summary>
        </member>
        <member name="P:UtilityCommonStrings.FileOpenError">
            <summary>
              Looks up a localized string similar to Cannot open the file because the current provider ({0}) cannot open files..
            </summary>
        </member>
        <member name="P:UtilityCommonStrings.FileReadError">
            <summary>
              Looks up a localized string similar to The file &apos;{0}&apos; cannot be read: {1}.
            </summary>
        </member>
        <member name="P:UtilityCommonStrings.FormatHexPathPrefix">
            <summary>
              Looks up a localized string similar to Path: .
            </summary>
        </member>
        <member name="P:UtilityCommonStrings.FormatHexResolvePathError">
            <summary>
              Looks up a localized string similar to Cannot display the context of {0} as hex. The path resolves to multiple files..
            </summary>
        </member>
        <member name="P:UtilityCommonStrings.FormatHexTypeNotSupported">
            <summary>
              Looks up a localized string similar to Cannot convert input of type {0} to hexadecimal. To view the hexadecimal formatting of its string representation, pipe it to the Out-String cmdlet before piping it to Format-Hex..
            </summary>
        </member>
        <member name="P:UtilityCommonStrings.GroupObjectSingleProperty">
            <summary>
              Looks up a localized string similar to The command cannot be run because using the AsHashTable parameter with more than one property requires adding the AsString parameter..
            </summary>
        </member>
        <member name="P:UtilityCommonStrings.GroupObjectWithHashTable">
            <summary>
              Looks up a localized string similar to The command cannot be run because the AsString parameter requires that you specify the AsHashtable parameter..
            </summary>
        </member>
        <member name="P:UtilityCommonStrings.InvalidOperation">
            <summary>
              Looks up a localized string similar to The objects grouped by this property cannot be expanded because there is a key duplication. Provide a valid value for the property, and then try again..
            </summary>
        </member>
        <member name="P:UtilityCommonStrings.Invalidpath">
            <summary>
              Looks up a localized string similar to {2} has one or more exceptions that are not valid..
            </summary>
        </member>
        <member name="P:UtilityCommonStrings.NoMatchFound">
            <summary>
              Looks up a localized string similar to There are no matching results found for {2}..
            </summary>
        </member>
        <member name="P:UtilityCommonStrings.NotSupported">
            <summary>
              Looks up a localized string similar to The command is not supported on this operating system..
            </summary>
        </member>
        <member name="P:UtilityCommonStrings.PathDoesNotExist">
            <summary>
              Looks up a localized string similar to Cannot find path &apos;{0}&apos; because it does not exist..
            </summary>
        </member>
        <member name="P:UtilityCommonStrings.PSPrefixReservedInInformationTag">
            <summary>
              Looks up a localized string similar to Cannot use tag &apos;{0}&apos;. The &apos;PS&apos; prefix is reserved..
            </summary>
        </member>
        <member name="P:UtilityCommonStrings.SearchXMLPrefixNullError">
            <summary>
              Looks up a localized string similar to This command cannot be run because the prefix value in the Namespace parameter is null. Provide a valid value for the prefix, and then run the command again..
            </summary>
        </member>
        <member name="P:UtilityCommonStrings.TypeNotSupported">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is not supported in this system..
            </summary>
        </member>
        <member name="T:HostStrings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:HostStrings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:HostStrings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:HostStrings.InvalidColorErrorTemplate">
            <summary>
              Looks up a localized string similar to Cannot process the color because {0} is not a valid color..
            </summary>
        </member>
        <member name="P:HostStrings.NoStringToEvalulateError">
            <summary>
              Looks up a localized string similar to Cannot evaluate the error because a string is not specified..
            </summary>
        </member>
        <member name="T:AddMember">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:AddMember.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:AddMember.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:AddMember.AliasReferenceShouldNotBeNullOrEmpty">
            <summary>
              Looks up a localized string similar to The member referenced by this alias should not be null or empty..
            </summary>
        </member>
        <member name="P:AddMember.CannotAddMemberType">
            <summary>
              Looks up a localized string similar to Cannot add a member with type &quot;{0}&quot;. Specify a different type for the MemberTypes parameter..
            </summary>
        </member>
        <member name="P:AddMember.CannotRemoveTypeDataMember">
            <summary>
              Looks up a localized string similar to Cannot force the member with name &quot;{0}&quot; and type &quot;{1}&quot; to be added. A member with that name and type already exists, and the existing member is not an instance extension..
            </summary>
        </member>
        <member name="P:AddMember.InvalidValueForNotePropertyName">
            <summary>
              Looks up a localized string similar to The parameter NotePropertyName cannot take values that could be converted to the type {0}. To define the name of a member with those values, use Add-Member, and specify the member type..
            </summary>
        </member>
        <member name="P:AddMember.MemberAlreadyExists">
            <summary>
              Looks up a localized string similar to Cannot add a member with the name &quot;{0}&quot; because a member with that name already exists. To overwrite the member anyway, add the Force parameter to your command..
            </summary>
        </member>
        <member name="P:AddMember.NotePropertyNameShouldNotBeNull">
            <summary>
              Looks up a localized string similar to The name for a NoteProperty member should not be null or an empty string..
            </summary>
        </member>
        <member name="P:AddMember.TypeNameShouldNotBeEmpty">
            <summary>
              Looks up a localized string similar to The TypeName parameter should not be null, empty, or contain only white spaces..
            </summary>
        </member>
        <member name="P:AddMember.Value1AndValue2AreNotBothNull">
            <summary>
              Looks up a localized string similar to Both Value and SecondValue parameters should not be null for a member of type &quot;{0}&quot;. Specify a non-null value for one of the two parameters..
            </summary>
        </member>
        <member name="P:AddMember.Value1Prompt">
            <summary>
              Looks up a localized string similar to The Value parameter is required for a member of type &quot;{0}&quot;. Specify the Value parameter when adding members of this type..
            </summary>
        </member>
        <member name="P:AddMember.Value1ShouldNotBeNull">
            <summary>
              Looks up a localized string similar to The Value parameter should not be null for a member of type &quot;{0}&quot;. Specify a non-null value for the Value parameter when adding members of this type..
            </summary>
        </member>
        <member name="P:AddMember.Value2ShouldNotBeNull">
            <summary>
              Looks up a localized string similar to The SecondValue parameter should not be null for a member of type &quot;{0}&quot;. Specify a non-null value for the SecondValue parameter when adding members of this type..
            </summary>
        </member>
        <member name="P:AddMember.Value2ShouldNotBeSpecified">
            <summary>
              Looks up a localized string similar to The SecondValue parameter is not necessary for a member of type &quot;{0}&quot;, and should not be specified. Do not specify the SecondValue parameter when you add members of this type..
            </summary>
        </member>
        <member name="P:AddMember.WrongMemberCount">
            <summary>
              Looks up a localized string similar to To add a member, only one member type can be specified. The member types specified are: &quot;{0}&quot;.
            </summary>
        </member>
        <member name="T:AddTypeStrings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:AddTypeStrings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:AddTypeStrings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:AddTypeStrings.AmbiguousAssemblyName">
            <summary>
              Looks up a localized string similar to Cannot add type. The assembly name {0} matches both {1} and {2}..
            </summary>
        </member>
        <member name="P:AddTypeStrings.AssemblyLoadErrors">
            <summary>
              Looks up a localized string similar to Cannot add type. One or more required assemblies are missing..
            </summary>
        </member>
        <member name="P:AddTypeStrings.AssemblyNotFound">
            <summary>
              Looks up a localized string similar to Cannot add type. The assembly &apos;{0}&apos; could not be found..
            </summary>
        </member>
        <member name="P:AddTypeStrings.CannotDefineNewType">
            <summary>
              Looks up a localized string similar to Cannot add type. Definition of new types is not supported in this language mode..
            </summary>
        </member>
        <member name="P:AddTypeStrings.CompilationErrorFormat">
            <summary>
              Looks up a localized string similar to {0}({1}) : {2}.
            </summary>
        </member>
        <member name="P:AddTypeStrings.CompilerErrors">
            <summary>
              Looks up a localized string similar to Cannot add type. Compilation errors occurred..
            </summary>
        </member>
        <member name="P:AddTypeStrings.CompilerErrorWithCSC">
            <summary>
              Looks up a localized string similar to Cannot add type due to the following exception: {0}. Verify that Microsoft .NET Framework {1}  is installed. On x64-based versions of Windows, you must also install the WOW64 feature..
            </summary>
        </member>
        <member name="P:AddTypeStrings.FileExtensionNotSupported">
            <summary>
              Looks up a localized string similar to Cannot add type. The &quot;{0}&quot; extension is not supported..
            </summary>
        </member>
        <member name="P:AddTypeStrings.FromMemberNotSupported">
            <summary>
              Looks up a localized string similar to Cannot add type. The -MemberDefinition parameter is not supported for this language..
            </summary>
        </member>
        <member name="P:AddTypeStrings.LanguageAndProviderSpecified">
            <summary>
              Looks up a localized string similar to Cannot add type. Specify only the Language or CodeDomProvider parameters..
            </summary>
        </member>
        <member name="P:AddTypeStrings.MethodDefinitionNotPublic">
            <summary>
              Looks up a localized string similar to The generated type defines no public methods or properties..
            </summary>
        </member>
        <member name="P:AddTypeStrings.MultipleExtensionsNotSupported">
            <summary>
              Looks up a localized string similar to Cannot add type. Input files must all have the same file extension..
            </summary>
        </member>
        <member name="P:AddTypeStrings.OutputAssemblyDidNotResolve">
            <summary>
              Looks up a localized string similar to Cannot set output assembly. The path {0} did not resolve to a single file..
            </summary>
        </member>
        <member name="P:AddTypeStrings.OutputTypeRequiresOutputAssembly">
            <summary>
              Looks up a localized string similar to Cannot add type. The OutputType parameter requires that the OutputAssembly parameter be specified..
            </summary>
        </member>
        <member name="P:AddTypeStrings.SpecialNetVersionRequired">
            <summary>
              Looks up a localized string similar to Cannot add type. The &apos;{0}&apos; language requires Microsoft .NET Framework {1}..
            </summary>
        </member>
        <member name="P:AddTypeStrings.TypeAlreadyExists">
            <summary>
              Looks up a localized string similar to Cannot add type. The type name &apos;{0}&apos; already exists..
            </summary>
        </member>
        <member name="P:AddTypeStrings.TypeDefinitionNotPublic">
            <summary>
              Looks up a localized string similar to The generated type is not public..
            </summary>
        </member>
        <member name="P:AddTypeStrings.WrongCompilerParameterCombination">
            <summary>
              Looks up a localized string similar to Cannot add type. The &apos;{0}&apos; parameter and the &apos;{1}&apos; parameter cannot both be specified..
            </summary>
        </member>
        <member name="T:AliasCommandStrings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:AliasCommandStrings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:AliasCommandStrings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:AliasCommandStrings.ExportAliasFileOpenFailed">
            <summary>
              Looks up a localized string similar to Cannot open file {0} to export the alias. {1}.
            </summary>
        </member>
        <member name="P:AliasCommandStrings.ExportAliasHeaderDate">
            <summary>
              Looks up a localized string similar to Date/Time : {0:F}.
            </summary>
        </member>
        <member name="P:AliasCommandStrings.ExportAliasHeaderMachine">
            <summary>
              Looks up a localized string similar to Computer : {0}.
            </summary>
        </member>
        <member name="P:AliasCommandStrings.ExportAliasHeaderTitle">
            <summary>
              Looks up a localized string similar to Alias File.
            </summary>
        </member>
        <member name="P:AliasCommandStrings.ExportAliasHeaderUser">
            <summary>
              Looks up a localized string similar to Exported by : {0}.
            </summary>
        </member>
        <member name="P:AliasCommandStrings.ExportAliasPathResolvedToMultiple">
            <summary>
              Looks up a localized string similar to Cannot export the aliases because path &apos;{0}&apos; contains wildcard characters that resolved to multiple paths. Aliases can be exported to only one file. Change the value of the Path parameter to a path that resolves to a single file..
            </summary>
        </member>
        <member name="P:AliasCommandStrings.ExportAliasToFileSystemOnly">
            <summary>
              Looks up a localized string similar to Cannot export the aliases because path &apos;{0}&apos; referred to a &apos;{1}&apos; provider path. Change the Path parameter to a file system path..
            </summary>
        </member>
        <member name="P:AliasCommandStrings.ImportAliasAction">
            <summary>
              Looks up a localized string similar to Import Alias.
            </summary>
        </member>
        <member name="P:AliasCommandStrings.ImportAliasFileInvalidFormat">
            <summary>
              Looks up a localized string similar to Cannot import an alias. Line number {1} in the file &apos;{0}&apos; is not a properly-formatted, comma-separated values (CSV) line for aliases. Change the line to contain four values separated by commas. If the value text itself contains a comma, then the value must be contained in quotation marks..
            </summary>
        </member>
        <member name="P:AliasCommandStrings.ImportAliasFileOpenFailed">
            <summary>
              Looks up a localized string similar to Cannot open file {0} to import the alias. {1}.
            </summary>
        </member>
        <member name="P:AliasCommandStrings.ImportAliasFromFileSystemOnly">
            <summary>
              Looks up a localized string similar to Cannot import the alias because the specified path &apos;{0}&apos; referred to a &apos;{1}&apos; provider path. Change the value of the Path parameter to a file system path..
            </summary>
        </member>
        <member name="P:AliasCommandStrings.ImportAliasOptionsError">
            <summary>
              Looks up a localized string similar to Cannot import the alias because line number {1} in the file &apos;{0}&apos; contains an option that is not recognized for aliases. Change the file to contain valid options..
            </summary>
        </member>
        <member name="P:AliasCommandStrings.ImportAliasPathResolvedToMultiple">
            <summary>
              Looks up a localized string similar to Cannot import alias because path &apos;{0}&apos; contains wildcard characters that resolve to multiple paths. Aliases can be imported from only one file. Change the value of the Path parameter to a path that resolves to a single file..
            </summary>
        </member>
        <member name="P:AliasCommandStrings.ImportAliasTarget">
            <summary>
              Looks up a localized string similar to Name: {0} Value: {1}.
            </summary>
        </member>
        <member name="P:AliasCommandStrings.NewAliasAction">
            <summary>
              Looks up a localized string similar to New Alias.
            </summary>
        </member>
        <member name="P:AliasCommandStrings.NewAliasTarget">
            <summary>
              Looks up a localized string similar to Name: {0} Value: {1}.
            </summary>
        </member>
        <member name="P:AliasCommandStrings.NoAliasFound">
            <summary>
              Looks up a localized string similar to This command cannot find a matching alias because an alias with the {0} &apos;{1}&apos; does not exist..
            </summary>
        </member>
        <member name="P:AliasCommandStrings.SetAliasAction">
            <summary>
              Looks up a localized string similar to Set Alias.
            </summary>
        </member>
        <member name="P:AliasCommandStrings.SetAliasTarget">
            <summary>
              Looks up a localized string similar to Name: {0} Value: {1}.
            </summary>
        </member>
        <member name="T:ConvertFromStringData">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:ConvertFromStringData.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:ConvertFromStringData.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:ConvertFromStringData.DataItemAlreadyDefined">
            <summary>
              Looks up a localized string similar to Data item &apos;{1}&apos; in line &apos;{0}&apos; is already defined. .
            </summary>
        </member>
        <member name="P:ConvertFromStringData.InvalidDataLine">
            <summary>
              Looks up a localized string similar to Data line &apos;{0}&apos; is not in &apos;name=value&apos; format. .
            </summary>
        </member>
        <member name="T:UpdateDataStrings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:UpdateDataStrings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:UpdateDataStrings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:UpdateDataStrings.CannotUpdateFormatWithFormatTable">
            <summary>
              Looks up a localized string similar to Cannot update the format data with a FormatTable instance..
            </summary>
        </member>
        <member name="P:UpdateDataStrings.CannotUpdateMemberType">
            <summary>
              Looks up a localized string similar to Cannot update a member with type &quot;{0}&quot;. Specify a different type for the MemberType parameter..
            </summary>
        </member>
        <member name="P:UpdateDataStrings.CannotUpdateTypeWithTypeTable">
            <summary>
              Looks up a localized string similar to Cannot update the type data with a TypeTable instance..
            </summary>
        </member>
        <member name="P:UpdateDataStrings.FormatUpdatesDisabled">
            <summary>
              Looks up a localized string similar to Updating format data is not allowed in this runspace. The &apos;DisableFormatUpdates&apos; property is set to True when creating the runspace..
            </summary>
        </member>
        <member name="P:UpdateDataStrings.MemberTypeIsMissing">
            <summary>
              Looks up a localized string similar to The MemberName, Value, and SecondValue parameters cannot be specified without the MemberType parameter..
            </summary>
        </member>
        <member name="P:UpdateDataStrings.RemoveTypeDataAction">
            <summary>
              Looks up a localized string similar to Remove TypeData.
            </summary>
        </member>
        <member name="P:UpdateDataStrings.RemoveTypeDataTarget">
            <summary>
              Looks up a localized string similar to Name of the type that will be removed: {0}.
            </summary>
        </member>
        <member name="P:UpdateDataStrings.RemoveTypeFileAction">
            <summary>
              Looks up a localized string similar to Remove type file.
            </summary>
        </member>
        <member name="P:UpdateDataStrings.SerializationDepthNegative">
            <summary>
              Looks up a localized string similar to The value of the SerializationDepth property should not be negative..
            </summary>
        </member>
        <member name="P:UpdateDataStrings.ShouldBeSpecified">
            <summary>
              Looks up a localized string similar to The {0} parameter is required for the type &quot;{1}&quot;. Please specify the {0} parameter..
            </summary>
        </member>
        <member name="P:UpdateDataStrings.ShouldNotBeNull">
            <summary>
              Looks up a localized string similar to The {0} parameter should not be null or an empty string for a member of type &quot;{1}&quot;. Specify a non-null value for the {0} parameter when updating this member type..
            </summary>
        </member>
        <member name="P:UpdateDataStrings.ShouldNotBeSpecified">
            <summary>
              Looks up a localized string similar to The {0} parameter is not necessary for a member of type &quot;{1}&quot;, and should not be specified. Do not specify the {0} parameter when updating this member type..
            </summary>
        </member>
        <member name="P:UpdateDataStrings.TargetTypeNameEmpty">
            <summary>
              Looks up a localized string similar to The target type name should not be null, empty, or contain only white spaces..
            </summary>
        </member>
        <member name="P:UpdateDataStrings.TypeDataEmpty">
            <summary>
              Looks up a localized string similar to No member is specified for the update on type &quot;{0}&quot;..
            </summary>
        </member>
        <member name="P:UpdateDataStrings.TypeFileNotExistsInCurrentSession">
            <summary>
              Looks up a localized string similar to The file {0} is not imported into the current session..
            </summary>
        </member>
        <member name="P:UpdateDataStrings.UpdateData_WrongExtension">
            <summary>
              Looks up a localized string similar to Cannot read the file &quot;{0}&quot;  because it does not have the file name extension &quot;{1}&quot;..
            </summary>
        </member>
        <member name="P:UpdateDataStrings.UpdateData_WrongProviderError">
            <summary>
              Looks up a localized string similar to Cannot open the file because the current provider is &quot;{0}&quot;, and this command requires a file..
            </summary>
        </member>
        <member name="P:UpdateDataStrings.UpdateFormatDataAction">
            <summary>
              Looks up a localized string similar to Update FormatData.
            </summary>
        </member>
        <member name="P:UpdateDataStrings.UpdateTarget">
            <summary>
              Looks up a localized string similar to FileName: {0}.
            </summary>
        </member>
        <member name="P:UpdateDataStrings.UpdateTypeDataAction">
            <summary>
              Looks up a localized string similar to Update TypeData.
            </summary>
        </member>
        <member name="P:UpdateDataStrings.UpdateTypeDataTarget">
            <summary>
              Looks up a localized string similar to Type to update: {0}.
            </summary>
        </member>
        <member name="P:UpdateDataStrings.Value1AndValue2AreNotBothNull">
            <summary>
              Looks up a localized string similar to The Value and SecondValue parameters should not both be null for a member of type &quot;{0}&quot;. Specify a non-null value for one of the two parameters..
            </summary>
        </member>
        <member name="P:UpdateDataStrings.WrongMemberCount">
            <summary>
              Looks up a localized string similar to Only one member type can be specified. The member types specified are: &quot;{0}&quot;. Update the type with only one member type..
            </summary>
        </member>
        <member name="T:ImportLocalizedDataStrings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:ImportLocalizedDataStrings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:ImportLocalizedDataStrings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:ImportLocalizedDataStrings.CannotDefineSupportedCommand">
            <summary>
              Looks up a localized string similar to Cannot import localized data. The definition of additional supported commands is not allowed in this language mode..
            </summary>
        </member>
        <member name="P:ImportLocalizedDataStrings.CannotFindPsd1File">
            <summary>
              Looks up a localized string similar to Cannot find the Windows PowerShell data file &apos;{0}&apos; in directory &apos;{1}&apos;, or in any parent culture directories..
            </summary>
        </member>
        <member name="P:ImportLocalizedDataStrings.ErrorLoadingDataFile">
             <summary>
               Looks up a localized string similar to The following error occurred while Windows PowerShell was loading the &apos;{0}&apos; script data file:
            {1}..
             </summary>
        </member>
        <member name="P:ImportLocalizedDataStrings.ErrorOpeningFile">
             <summary>
               Looks up a localized string similar to The following error occurred while Windows PowerShell was opening the data file &apos;{0}&apos;:
            {1}..
             </summary>
        </member>
        <member name="P:ImportLocalizedDataStrings.FileNameParameterCannotHavePath">
            <summary>
              Looks up a localized string similar to The argument for the FileName parameter should not contain a path..
            </summary>
        </member>
        <member name="P:ImportLocalizedDataStrings.FileNotExist">
            <summary>
              Looks up a localized string similar to The data file &apos;{0}&apos; cannot be found. .
            </summary>
        </member>
        <member name="P:ImportLocalizedDataStrings.IncorrectVariableName">
            <summary>
              Looks up a localized string similar to The BindingVariable name &apos;{0}&apos; is invalid..
            </summary>
        </member>
        <member name="P:ImportLocalizedDataStrings.NotCalledFromAScriptFile">
            <summary>
              Looks up a localized string similar to The FileName parameter was not specified. The FileName parameter is required when Import-LocalizedData is not called from a script file..
            </summary>
        </member>
        <member name="T:WriteProgressResourceStrings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:WriteProgressResourceStrings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:WriteProgressResourceStrings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:WriteProgressResourceStrings.ActivityParameterHelpMessage">
            <summary>
              Looks up a localized string similar to Text to describe the activity for which progress is being reported..
            </summary>
        </member>
        <member name="P:WriteProgressResourceStrings.Processing">
            <summary>
              Looks up a localized string similar to Processing.
            </summary>
        </member>
        <member name="P:WriteProgressResourceStrings.StatusParameterHelpMessage">
            <summary>
              Looks up a localized string similar to Text to describe the current state of the activity for which progress is being reported..
            </summary>
        </member>
        <member name="T:WebCmdletStrings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:WebCmdletStrings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:WebCmdletStrings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:WebCmdletStrings.AccessDenied">
            <summary>
              Looks up a localized string similar to Access to the path &apos;{0}&apos; is denied..
            </summary>
        </member>
        <member name="P:WebCmdletStrings.BodyConflict">
            <summary>
              Looks up a localized string similar to The cmdlet cannot run because the following conflicting parameters are specified: Body and InFile. Specify either Body or Infile, then retry.  .
            </summary>
        </member>
        <member name="P:WebCmdletStrings.CouldNotAutoImportJsonNetModule">
            <summary>
              Looks up a localized string similar to However, the &apos;Json.Net&apos; module could not be loaded. For more information, run &apos;Import-Module Json.Net&apos;..
            </summary>
        </member>
        <member name="P:WebCmdletStrings.CredentialConflict">
            <summary>
              Looks up a localized string similar to The cmdlet cannot run because the following conflicting parameters are specified: Credential and UseDefaultCredentials. Specify either Credential or UseDefaultCredentials, then retry..
            </summary>
        </member>
        <member name="P:WebCmdletStrings.DirecotryPathSpecified">
            <summary>
              Looks up a localized string similar to Path &apos;{0}&apos; resolves to a directory. Specify a path including a file name, and then retry the command..
            </summary>
        </member>
        <member name="P:WebCmdletStrings.DuplicateKeysInJsonString">
            <summary>
              Looks up a localized string similar to Cannot convert the JSON string because a dictionary that was converted from the string contains the duplicated keys &apos;{0}&apos; and &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:WebCmdletStrings.ExtendedProfileRequired">
            <summary>
              Looks up a localized string similar to The ConvertTo-Json and ConvertFrom-Json cmdlets require the installation of the .NET Client Profile, sometimes called the .NET extended profile..
            </summary>
        </member>
        <member name="P:WebCmdletStrings.IEDomNotSupported">
            <summary>
              Looks up a localized string similar to The response content cannot be parsed because the Internet Explorer engine is not available, or Internet Explorer&apos;s first-launch configuration is not complete. Specify the UseBasicParsing parameter and try again. .
            </summary>
        </member>
        <member name="P:WebCmdletStrings.JsonNetModuleFilesRequired">
            <summary>
              Looks up a localized string similar to Ensure &apos;Json.Net.psd1&apos; and &apos;Newtonsoft.Json.dll&apos; are available in a versioned subdirectory of &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:WebCmdletStrings.JsonNetModuleRequired">
            <summary>
              Looks up a localized string similar to The ConvertTo-Json and ConvertFrom-Json cmdlets require the &apos;Json.Net&apos; module. {0}.
            </summary>
        </member>
        <member name="P:WebCmdletStrings.JsonStringInBadFormat">
            <summary>
              Looks up a localized string similar to The converted JSON string is in bad format..
            </summary>
        </member>
        <member name="P:WebCmdletStrings.MaximumRedirectionCountExceeded">
            <summary>
              Looks up a localized string similar to The maximum redirection count has been exceeded. To increase the number of redirections allowed, supply a higher value to the -MaximumRedirection parameter..
            </summary>
        </member>
        <member name="P:WebCmdletStrings.MultiplePathsResolved">
            <summary>
              Looks up a localized string similar to Path &apos;{0}&apos; can be resolved to multiple paths..
            </summary>
        </member>
        <member name="P:WebCmdletStrings.NonStringKeyInDictionary">
            <summary>
              Looks up a localized string similar to The type &apos;{0}&apos; is not supported for serialization or deserialization of a dictionary. Keys must be strings..
            </summary>
        </member>
        <member name="P:WebCmdletStrings.NoPathResolved">
            <summary>
              Looks up a localized string similar to Path &apos;{0}&apos; cannot be resolved to a file..
            </summary>
        </member>
        <member name="P:WebCmdletStrings.NotFilesystemPath">
            <summary>
              Looks up a localized string similar to Path &apos;{0}&apos; is not a file system path. Please specify the path to a file in the file system..
            </summary>
        </member>
        <member name="P:WebCmdletStrings.OutFileMissing">
            <summary>
              Looks up a localized string similar to The cmdlet cannot run because the following parameter is missing: OutFile. Provide a valid OutFile parameter value when using the PassThru parameter, then retry..
            </summary>
        </member>
        <member name="P:WebCmdletStrings.ProxyCredentialConflict">
            <summary>
              Looks up a localized string similar to The cmdlet cannot run because the following conflicting parameters are specified: ProxyCredential and ProxyUseDefaultCredentials. Specify either ProxyCredential or ProxyUseDefaultCredentials, then retry..
            </summary>
        </member>
        <member name="P:WebCmdletStrings.ProxyUriNotSupplied">
            <summary>
              Looks up a localized string similar to The cmdlet cannot run because the following parameter is missing: Proxy. Provide a valid proxy URI for the Proxy parameter when using the ProxyCredential or UseDefaultProxyCredentials parameters, then retry..
            </summary>
        </member>
        <member name="P:WebCmdletStrings.PSModuleAutoloadingPreferenceNotEnable">
            <summary>
              Looks up a localized string similar to The cmdlet cannot run because the &apos;Json.Net&apos; module cannot be loaded. Import the module manually or set the $PSModuleAutoLoadingPreference variable to enable module auto loading. For more information, see &apos;get-help about_Preference_Variables&apos;..
            </summary>
        </member>
        <member name="P:WebCmdletStrings.ReachedMaximumDepthAllowed">
            <summary>
              Looks up a localized string similar to The maximum depth allowed for serialization is {0}..
            </summary>
        </member>
        <member name="P:WebCmdletStrings.ReadResponseComplete">
            <summary>
              Looks up a localized string similar to Reading web response completed. (Number of bytes read: {0}).
            </summary>
        </member>
        <member name="P:WebCmdletStrings.ReadResponseProgressActivity">
            <summary>
              Looks up a localized string similar to Reading web response.
            </summary>
        </member>
        <member name="P:WebCmdletStrings.ReadResponseProgressStatus">
            <summary>
              Looks up a localized string similar to Reading response stream... (Number of bytes read: {0}).
            </summary>
        </member>
        <member name="P:WebCmdletStrings.RequestTimeout">
            <summary>
              Looks up a localized string similar to The operation has timed out..
            </summary>
        </member>
        <member name="P:WebCmdletStrings.SessionConflict">
            <summary>
              Looks up a localized string similar to The cmdlet cannot run because the following conflicting parameters are specified: Session and SessionVariable. Specify either Session or SessionVariable, then retry..
            </summary>
        </member>
        <member name="P:WebCmdletStrings.ThumbprintNotFound">
            <summary>
              Looks up a localized string similar to Unable to retrieve certificates because the thumbprint is not valid. Verify the thumbprint and retry. .
            </summary>
        </member>
        <member name="P:WebCmdletStrings.WriteRequestComplete">
            <summary>
              Looks up a localized string similar to Writing web request completed. (Number of bytes remaining: {0}).
            </summary>
        </member>
        <member name="P:WebCmdletStrings.WriteRequestProgressActivity">
            <summary>
              Looks up a localized string similar to Writing web request.
            </summary>
        </member>
        <member name="P:WebCmdletStrings.WriteRequestProgressStatus">
            <summary>
              Looks up a localized string similar to Writing request stream... (Number of bytes written: {0}).
            </summary>
        </member>
        <member name="T:FormatAndOut_out_gridview">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:FormatAndOut_out_gridview.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:FormatAndOut_out_gridview.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:FormatAndOut_out_gridview.CannotWriteToConsoleInputBuffer">
            <summary>
              Looks up a localized string similar to Cannot write to console input buffer..
            </summary>
        </member>
        <member name="P:FormatAndOut_out_gridview.CommandNotFound">
            <summary>
              Looks up a localized string similar to A command named &apos;{0}&apos; was not found..
            </summary>
        </member>
        <member name="P:FormatAndOut_out_gridview.DataNotQualifiedForGridView">
            <summary>
              Looks up a localized string similar to The data format is not supported by Out-GridView..
            </summary>
        </member>
        <member name="P:FormatAndOut_out_gridview.IndexColumnName">
            <summary>
              Looks up a localized string similar to Index.
            </summary>
        </member>
        <member name="P:FormatAndOut_out_gridview.MoreThanOneCommand">
            <summary>
              Looks up a localized string similar to More than one command named &apos;{0}&apos; was found. Start &apos;{1}&apos; with no parameters, and then type &apos;{0}&apos; to filter the results..
            </summary>
        </member>
        <member name="P:FormatAndOut_out_gridview.PropertyValidate">
            <summary>
              Looks up a localized string similar to {0} should be smaller than {1}..
            </summary>
        </member>
        <member name="P:FormatAndOut_out_gridview.RestartPowerShell">
            <summary>
              Looks up a localized string similar to Microsoft .NET Framework 4.5 was installed while one or more Windows PowerShell sessions were running. To use the {0} cmdlet, close all Windows PowerShell windows, and then open a new Windows PowerShell window..
            </summary>
        </member>
        <member name="P:FormatAndOut_out_gridview.TypeColumnName">
            <summary>
              Looks up a localized string similar to Type.
            </summary>
        </member>
        <member name="P:FormatAndOut_out_gridview.ValueColumnName">
            <summary>
              Looks up a localized string similar to Value.
            </summary>
        </member>
        <member name="T:ImplicitRemotingStrings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:ImplicitRemotingStrings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:ImplicitRemotingStrings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:ImplicitRemotingStrings.CertificateNeeded">
            <summary>
              Looks up a localized string similar to Files cannot be loaded because running scripts is disabled on this system. Provide a valid certificate with which to sign the files..
            </summary>
        </member>
        <member name="P:ImplicitRemotingStrings.CreateNewRunspaceMessageTemplate">
            <summary>
              Looks up a localized string similar to Creating a new session for implicit remoting of &quot;{{0}}&quot; command....
            </summary>
        </member>
        <member name="P:ImplicitRemotingStrings.CredentialRequestBody">
            <summary>
              Looks up a localized string similar to Enter your credentials for {0}..
            </summary>
        </member>
        <member name="P:ImplicitRemotingStrings.CredentialRequestTitle">
            <summary>
              Looks up a localized string similar to Windows PowerShell Credential Request.
            </summary>
        </member>
        <member name="P:ImplicitRemotingStrings.ErrorCannotCreateTemporaryFile">
            <summary>
              Looks up a localized string similar to Cannot create temporary file for implicit remoting module..
            </summary>
        </member>
        <member name="P:ImplicitRemotingStrings.ErrorCommandSkippedBecauseOfShadowing">
            <summary>
              Looks up a localized string similar to Proxy creation has been skipped for the following command: &apos;{0}&apos;, because it would shadow an existing local command.  Use the AllowClobber parameter if you want to shadow existing local commands..
            </summary>
        </member>
        <member name="P:ImplicitRemotingStrings.ErrorCouldntResolveAlias">
            <summary>
              Looks up a localized string similar to Could not resolve remote alias &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:ImplicitRemotingStrings.ErrorFromRemoteCommand">
            <summary>
              Looks up a localized string similar to Running the {0} command in a remote session reported the following error: {1}..
            </summary>
        </member>
        <member name="P:ImplicitRemotingStrings.ErrorMalformedDataFromRemoteCommand">
            <summary>
              Looks up a localized string similar to Data returned by the remote {0} command is not in the expected format..
            </summary>
        </member>
        <member name="P:ImplicitRemotingStrings.ErrorNoCommandsImportedBecauseOfSkipping">
            <summary>
              Looks up a localized string similar to No command proxies have been created, because all of the requested remote commands would shadow existing local commands.  Use the AllowClobber parameter if you want to shadow existing local commands..
            </summary>
        </member>
        <member name="P:ImplicitRemotingStrings.ErrorNoResultsFromRemoteEnd">
            <summary>
              Looks up a localized string similar to Running the {0} command in a remote session returned no results..
            </summary>
        </member>
        <member name="P:ImplicitRemotingStrings.ErrorNoRunspaceForThisModule">
            <summary>
              Looks up a localized string similar to No session has been associated with this implicit remoting module..
            </summary>
        </member>
        <member name="P:ImplicitRemotingStrings.ErrorRequiredRemoteCommandNotFound">
            <summary>
              Looks up a localized string similar to The {0} cmdlet requires the following commands in the remote session: Get-Command, Get-FormatData, and Select-Object. The following commands are used, but optional: Get-Help, and Measure-Object. Verify that the remote session includes the required commands, and then try again..
            </summary>
        </member>
        <member name="P:ImplicitRemotingStrings.ErrorSkippedNonRequestedCommand">
            <summary>
              Looks up a localized string similar to Proxy creation has been skipped for the &apos;{0}&apos; command, because the name did not match the value of the Name  parameter..
            </summary>
        </member>
        <member name="P:ImplicitRemotingStrings.ErrorSkippedNonRequestedTypeDefinition">
            <summary>
              Looks up a localized string similar to Extended type definition has been skipped for the &apos;{0}&apos; type because its name did not match the value of the FormatTypeName parameter..
            </summary>
        </member>
        <member name="P:ImplicitRemotingStrings.ErrorSkippedUnsafeAliasName">
            <summary>
              Looks up a localized string similar to Proxy creation has been skipped for the &apos;{0}&apos; command, because Windows PowerShell could not verify the safety of a parameter alias name: &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:ImplicitRemotingStrings.ErrorSkippedUnsafeCommandName">
            <summary>
              Looks up a localized string similar to Proxy creation has been skipped for the &apos;{0}&apos; command, because Windows PowerShell could not verify the safety of the command name..
            </summary>
        </member>
        <member name="P:ImplicitRemotingStrings.ErrorSkippedUnsafeParameterName">
            <summary>
              Looks up a localized string similar to Proxy creation has been skipped for the &apos;{0}&apos; command, because Windows PowerShell could not verify the safety of a parameter name: &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:ImplicitRemotingStrings.ErrorSkippedUnsafeParameterSetName">
            <summary>
              Looks up a localized string similar to Proxy creation has been skipped for the &apos;{0}&apos; command, because Windows PowerShell could not verify the safety of a parameter set name: &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:ImplicitRemotingStrings.EventSourceIdentifier">
            <summary>
              Looks up a localized string similar to Implicit remoting event (session id: {0}; event handler id: {1}).
            </summary>
        </member>
        <member name="P:ImplicitRemotingStrings.InvalidSigningOperation">
            <summary>
              Looks up a localized string similar to The file {0} could not be signed..
            </summary>
        </member>
        <member name="P:ImplicitRemotingStrings.ModuleHeaderCommand">
            <summary>
              Looks up a localized string similar to by {0} cmdlet.
            </summary>
        </member>
        <member name="P:ImplicitRemotingStrings.ModuleHeaderCommandLine">
            <summary>
              Looks up a localized string similar to Invoked with the following command line: {0}.
            </summary>
        </member>
        <member name="P:ImplicitRemotingStrings.ModuleHeaderDate">
            <summary>
              Looks up a localized string similar to generated on {0}.
            </summary>
        </member>
        <member name="P:ImplicitRemotingStrings.ModuleHeaderRunspaceOverrideParameter">
            <summary>
              Looks up a localized string similar to Optional parameter that can be used to specify the session on which this proxy module works.
            </summary>
        </member>
        <member name="P:ImplicitRemotingStrings.ModuleHeaderTitle">
            <summary>
              Looks up a localized string similar to Implicit remoting module.
            </summary>
        </member>
        <member name="P:ImplicitRemotingStrings.ProgressActivity">
            <summary>
              Looks up a localized string similar to Creating implicit remoting module ....
            </summary>
        </member>
        <member name="P:ImplicitRemotingStrings.ProgressStatusCompleted">
            <summary>
              Looks up a localized string similar to Completed..
            </summary>
        </member>
        <member name="P:ImplicitRemotingStrings.ProgressStatusGetCommandProgress">
            <summary>
              Looks up a localized string similar to Getting command information from remote session ... {0} commands received.
            </summary>
        </member>
        <member name="P:ImplicitRemotingStrings.ProgressStatusGetCommandStart">
            <summary>
              Looks up a localized string similar to Getting command information from remote session ....
            </summary>
        </member>
        <member name="P:ImplicitRemotingStrings.ProgressStatusGetFormatDataProgress">
            <summary>
              Looks up a localized string similar to Getting formatting and output information from remote session ... {0} objects received.
            </summary>
        </member>
        <member name="P:ImplicitRemotingStrings.ProgressStatusGetFormatDataStart">
            <summary>
              Looks up a localized string similar to Getting formatting and output information from remote session ....
            </summary>
        </member>
        <member name="P:ImplicitRemotingStrings.ProgressStatusProxyGeneration">
            <summary>
              Looks up a localized string similar to Generating a proxy command for &apos;{0}&apos; ....
            </summary>
        </member>
        <member name="P:ImplicitRemotingStrings.ProxyCredentialRequestBody">
            <summary>
              Looks up a localized string similar to Enter the HTTP proxy credentials that are used for the following connection: {0}.
            </summary>
        </member>
        <member name="P:ImplicitRemotingStrings.ProxyModuleDescription">
            <summary>
              Looks up a localized string similar to Implicit remoting for {0}.
            </summary>
        </member>
        <member name="P:ImplicitRemotingStrings.ProxyRunspaceNameTemplate">
            <summary>
              Looks up a localized string similar to Session for implicit remoting module at {{0}}.
            </summary>
        </member>
        <member name="P:ImplicitRemotingStrings.WarningMismatchedImplicitRemotingHash">
            <summary>
              Looks up a localized string similar to Commands that are available in the new remote session are different than those available when the implicit remoting module was created.  Consider creating the module again by using the Export-PSSession cmdlet..
            </summary>
        </member>
        <member name="T:UtilityMshSnapInResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:UtilityMshSnapInResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:UtilityMshSnapInResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:UtilityMshSnapInResources.Description">
            <summary>
              Looks up a localized string similar to This Windows PowerShell snap-in contains utility cmdlets that are used to view and organize data in different ways..
            </summary>
        </member>
        <member name="P:UtilityMshSnapInResources.Name">
            <summary>
              Looks up a localized string similar to Windows PowerShell utility snap-in.
            </summary>
        </member>
        <member name="P:UtilityMshSnapInResources.Vendor">
            <summary>
              Looks up a localized string similar to Microsoft Corporation.
            </summary>
        </member>
        <member name="T:OutPrinterDisplayStrings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:OutPrinterDisplayStrings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:OutPrinterDisplayStrings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:OutPrinterDisplayStrings.DefaultPrintFontName">
            <summary>
              Looks up a localized string similar to Courier New.
            </summary>
        </member>
        <member name="T:TraceCommandStrings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:TraceCommandStrings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:TraceCommandStrings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:TraceCommandStrings.FileListenerNotFound">
            <summary>
              Looks up a localized string similar to A file listener with name &apos;{0}&apos; was not found..
            </summary>
        </member>
        <member name="P:TraceCommandStrings.TraceFileOnly">
            <summary>
              Looks up a localized string similar to Trace output can only be written to the file system. The path &apos;{0}&apos; referred to a &apos;{1}&apos; provider path..
            </summary>
        </member>
        <member name="P:TraceCommandStrings.TraceSingleFileOnly">
            <summary>
              Looks up a localized string similar to Trace output can only be written to a single file. The path &apos;{0}&apos; resolved to more than one file..
            </summary>
        </member>
        <member name="T:UpdateListStrings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:UpdateListStrings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:UpdateListStrings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:UpdateListStrings.MemberDoesntExist">
            <summary>
              Looks up a localized string similar to The property &apos;{0}&apos; cannot be found on this object.
            </summary>
        </member>
        <member name="P:UpdateListStrings.MissingInputObjectParameter">
            <summary>
              Looks up a localized string similar to You must specify the InputObject parameter when the Property parameter is specified..
            </summary>
        </member>
        <member name="P:UpdateListStrings.MissingPropertyParameter">
            <summary>
              Looks up a localized string similar to You must specify the Property parameter when the InputObject parameter is specified..
            </summary>
        </member>
        <member name="T:SendMailMessageStrings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:SendMailMessageStrings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:SendMailMessageStrings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:SendMailMessageStrings.HostNameValue">
            <summary>
              Looks up a localized string similar to The email cannot be sent because no SMTP server was specified. You must specify an SMTP server by using either the SmtpServer parameter or the $PSEmailServer variable..
            </summary>
        </member>
        <member name="T:ConvertFromStringResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:ConvertFromStringResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:ConvertFromStringResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:ConvertFromStringResources.DocInformation">
            <summary>
              Looks up a localized string similar to The supplied template was invalid: {0}. For more information on the template syntax, type &apos;Get-Help ConvertFrom-String&apos;.
            </summary>
        </member>
        <member name="P:ConvertFromStringResources.EmptyInputObject">
            <summary>
              Looks up a localized string similar to No input was supplied.
            </summary>
        </member>
        <member name="P:ConvertFromStringResources.InvalidRegularExpression">
            <summary>
              Looks up a localized string similar to {0} is not a valid Regular Expression delimiter.
            </summary>
        </member>
        <member name="P:ConvertFromStringResources.OneOrMorePropertyNamesAreInvalid">
            <summary>
              Looks up a localized string similar to One or more PropertyNames are invalid.
            </summary>
        </member>
        <member name="P:ConvertFromStringResources.OnlyOneTemplateSupported">
            <summary>
              Looks up a localized string similar to Template file path resolves to more than one file. Specify a path to a single file.
            </summary>
        </member>
        <member name="P:ConvertFromStringResources.ProgramNotFound">
            <summary>
              Looks up a localized string similar to ConvertFrom-String appears to be having trouble parsing your data using the template you&apos;ve provided. We&apos;d love to take a look at what went wrong, if you&apos;d like to share the data and template used to parse it. We&apos;ve saved these files to {0} and {1} - feel free to attach them in a mail to psdmfb@microsoft.com. We will review all submissions, although we can&apos;t guarantee a response..
            </summary>
        </member>
        <member name="P:ConvertFromStringResources.ResultNotFound">
            <summary>
              Looks up a localized string similar to ConvertFrom-String appears to be having trouble parsing your data using the template you&apos;ve provided. We&apos;d love to take a look at what went wrong, if you&apos;d like to share the data and template used to parse it. We&apos;ve saved these files to {0} and {1} - feel free to attach them in a mail to psdmfb@microsoft.com. We will review all submissions, although we can&apos;t guarantee a response..
            </summary>
        </member>
        <member name="P:ConvertFromStringResources.StringConversionError">
            <summary>
              Looks up a localized string similar to Error converting string value to specified type at file character position {0}.
            </summary>
        </member>
        <member name="P:ConvertFromStringResources.TemplateFileRequired">
            <summary>
              Looks up a localized string similar to Template file is required for UpdateTemplate parameter.
            </summary>
        </member>
        <member name="P:ConvertFromStringResources.TemplateNotFound">
            <summary>
              Looks up a localized string similar to Template file was not found.
            </summary>
        </member>
        <member name="T:ConvertStringResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:ConvertStringResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:ConvertStringResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:ConvertStringResources.InvalidExample">
            <summary>
              Looks up a localized string similar to Text examples must follow the pattern &quot;input value = output value&quot;.
            </summary>
        </member>
        <member name="P:ConvertStringResources.InvalidPsObjectExample">
            <summary>
              Looks up a localized string similar to PSObject examples should have &apos;Before&apos; and &apos;After&apos; properties.
            </summary>
        </member>
        <member name="P:ConvertStringResources.NoProgramFound">
            <summary>
              Looks up a localized string similar to Convert-String appears to be having trouble parsing your data using the examples you&apos;ve provided. We&apos;d love to take a look at what went wrong - feel free to send the command you tried in a mail to psdmfb@microsoft.com. We will review all submissions, although we can&apos;t guarantee a response..
            </summary>
        </member>
        <member name="T:FlashExtractStrings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:FlashExtractStrings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:FlashExtractStrings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:FlashExtractStrings.AtPosition">
            <summary>
              Looks up a localized string similar to at {0}.
            </summary>
        </member>
        <member name="P:FlashExtractStrings.AttributeSuffixWithinName">
            <summary>
              Looks up a localized string similar to Cannot embed attribute suffixes (e.g. optional, sequence) in names at {0} while processing {1}.
            </summary>
        </member>
        <member name="P:FlashExtractStrings.CachedProgramNotFound">
            <summary>
              Looks up a localized string similar to Cached program was not found in template file for property: {0}.
            </summary>
        </member>
        <member name="P:FlashExtractStrings.CannotConvertValue">
            <summary>
              Looks up a localized string similar to Unable to convert string value to specified type while processing {0}.
            </summary>
        </member>
        <member name="P:FlashExtractStrings.ChildNamesMustBeUnique">
            <summary>
              Looks up a localized string similar to There are two instances of non-sequence Property &apos;{0}&apos; at {1} and {2} in parent Span {3}.
            </summary>
        </member>
        <member name="P:FlashExtractStrings.DifferentTemplateHash">
            <summary>
              Looks up a localized string similar to Template text does not match cached programs.
            </summary>
        </member>
        <member name="P:FlashExtractStrings.InconsistentPropertyDefinition">
            <summary>
              Looks up a localized string similar to Property &apos;{0}&apos; definition at {1} is inconsistent with earlier definition(s).
            </summary>
        </member>
        <member name="P:FlashExtractStrings.InvalidFirstNameChar">
            <summary>
              Looks up a localized string similar to First character of a name must be a letter or underscore at {0} while processing {1}.
            </summary>
        </member>
        <member name="P:FlashExtractStrings.InvalidFormat">
            <summary>
              Looks up a localized string similar to Invalid format at {0} while processing {1}.
            </summary>
        </member>
        <member name="P:FlashExtractStrings.InvalidNameChar">
            <summary>
              Looks up a localized string similar to Characters of a name must be letters, digits, or underscores at {0} while processing {1}.
            </summary>
        </member>
        <member name="P:FlashExtractStrings.InvalidOperation">
            <summary>
              Looks up a localized string similar to Internal error: Invalid parser operation.
            </summary>
        </member>
        <member name="P:FlashExtractStrings.InvalidSpanName">
            <summary>
              Looks up a localized string similar to Missing Span name at {0} while processing {1}.
            </summary>
        </member>
        <member name="P:FlashExtractStrings.InvalidTypeName">
            <summary>
              Looks up a localized string similar to Invalid type name &apos;{0}&apos; at {1} while processing {2}.
            </summary>
        </member>
        <member name="P:FlashExtractStrings.MarkupCharPosition">
            <summary>
              Looks up a localized string similar to line {0} column {1}.
            </summary>
        </member>
        <member name="P:FlashExtractStrings.MissingSpan">
            <summary>
              Looks up a localized string similar to Missing Span value at {0} while processing {1}.
            </summary>
        </member>
        <member name="P:FlashExtractStrings.NoExampleFound">
            <summary>
              Looks up a localized string similar to The template text contains no example to parse.
            </summary>
        </member>
        <member name="P:FlashExtractStrings.NonOptionalNonStructMustHaveValue">
            <summary>
              Looks up a localized string similar to Property &apos;{0}&apos; at {1} has no value and is not optional or a containing span.
            </summary>
        </member>
        <member name="P:FlashExtractStrings.NoParent">
            <summary>
              Looks up a localized string similar to Internal error: Property &apos;{0}&apos; at {1} has no containing parent.
            </summary>
        </member>
        <member name="P:FlashExtractStrings.NoParentRegionFound">
            <summary>
              Looks up a localized string similar to Internal error: no parent region found..
            </summary>
        </member>
        <member name="P:FlashExtractStrings.NoProgramFound">
            <summary>
              Looks up a localized string similar to No program can be found for the given input.
            </summary>
        </member>
        <member name="P:FlashExtractStrings.NoStrippedTemplateFileStart">
            <summary>
              Looks up a localized string similar to No template text file start for Span {0}.
            </summary>
        </member>
        <member name="P:FlashExtractStrings.NullProperty">
            <summary>
              Looks up a localized string similar to Internal error: Property cannot be null.
            </summary>
        </member>
        <member name="P:FlashExtractStrings.ParentRegionsCannotBeEmpty">
            <summary>
              Looks up a localized string similar to Internal error: parent regions cannot be null or empty..
            </summary>
        </member>
        <member name="P:FlashExtractStrings.ParserSpanStartPosition">
            <summary>
              Looks up a localized string similar to line {0} column {1}.
            </summary>
        </member>
        <member name="P:FlashExtractStrings.PropertyNotFound">
            <summary>
              Looks up a localized string similar to Internal error: Property &apos;{0}&apos; not found.
            </summary>
        </member>
        <member name="P:FlashExtractStrings.ReservedWord">
            <summary>
              Looks up a localized string similar to Cannot use reserved word &apos;{2}&apos; at {0} while processing {1}.
            </summary>
        </member>
        <member name="P:FlashExtractStrings.SingleNameString">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:FlashExtractStrings.SpanStartPosition">
            <summary>
              Looks up a localized string similar to Span starting at line {0} column {1}.
            </summary>
        </member>
        <member name="P:FlashExtractStrings.UnexpectedEndingBracket">
            <summary>
              Looks up a localized string similar to Unexpected Span ending bracket found at {0}.
            </summary>
        </member>
        <member name="P:FlashExtractStrings.UnexpectedEOF">
            <summary>
              Looks up a localized string similar to Unexpected EOF while processing {0}.
            </summary>
        </member>
        <member name="P:FlashExtractStrings.ValueIndicatorNotFound">
            <summary>
              Looks up a localized string similar to Expected value indicator at {0} while processing {1}.
            </summary>
        </member>
        <member name="T:ImmutableStrings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:ImmutableStrings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:ImmutableStrings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:ImmutableStrings.ArrayInitializedStateNotEqual">
            <summary>
              Looks up a localized string similar to Object is not a array with the same initialization state as the array to compare it to..
            </summary>
        </member>
        <member name="P:ImmutableStrings.ArrayLengthsNotEqual">
            <summary>
              Looks up a localized string similar to Object is not a array with the same number of elements as the array to compare it to..
            </summary>
        </member>
        <member name="P:ImmutableStrings.CannotFindOldValue">
            <summary>
              Looks up a localized string similar to Cannot find the old value.
            </summary>
        </member>
        <member name="P:ImmutableStrings.CapacityMustBeGreaterThanOrEqualToCount">
            <summary>
              Looks up a localized string similar to Capacity was less than the current Count of elements..
            </summary>
        </member>
        <member name="P:ImmutableStrings.CapacityMustEqualCountOnMove">
            <summary>
              Looks up a localized string similar to MoveToImmutable can only be performed when Count equals Capacity..
            </summary>
        </member>
        <member name="P:ImmutableStrings.CollectionModifiedDuringEnumeration">
            <summary>
              Looks up a localized string similar to Collection was modified; enumeration operation may not execute..
            </summary>
        </member>
        <member name="P:ImmutableStrings.DuplicateKey">
            <summary>
              Looks up a localized string similar to An element with the same key but a different value already exists. Key: {0}.
            </summary>
        </member>
        <member name="P:ImmutableStrings.InvalidEmptyOperation">
            <summary>
              Looks up a localized string similar to This operation does not apply to an empty instance..
            </summary>
        </member>
        <member name="P:ImmutableStrings.InvalidOperationOnDefaultArray">
            <summary>
              Looks up a localized string similar to This operation cannot be performed on a default instance of ImmutableArray&lt;T&gt;.  Consider initializing the array, or checking the ImmutableArray&lt;T&gt;.IsDefault property..
            </summary>
        </member>
    </members>
</doc>
